import {
  __publicField
} from "./chunk-M4H726CL.js";

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/async/esm/promise-resolver.js
var PromiseResolver = function() {
  function PromiseResolver2() {
    var _this = this;
    this._state = "running";
    this.resolve = function(value) {
      _this._resolve(value);
      _this._state = "resolved";
    };
    this.reject = function(reason) {
      _this._reject(reason);
      _this._state = "rejected";
    };
    this._promise = new Promise(function(resolve, reject) {
      _this._resolve = resolve;
      _this._reject = reject;
    });
  }
  Object.defineProperty(PromiseResolver2.prototype, "promise", {
    get: function() {
      return this._promise;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PromiseResolver2.prototype, "state", {
    get: function() {
      return this._state;
    },
    enumerable: false,
    configurable: true
  });
  return PromiseResolver2;
}();

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/async/esm/async-operation-manager.js
var AsyncOperationManager = function() {
  function AsyncOperationManager2(startId) {
    if (startId === void 0) {
      startId = 0;
    }
    this.pendingResolvers = /* @__PURE__ */ new Map();
    this.nextId = startId;
  }
  AsyncOperationManager2.prototype.add = function() {
    var id = this.nextId++;
    var resolver = new PromiseResolver();
    this.pendingResolvers.set(id, resolver);
    return [id, resolver.promise];
  };
  AsyncOperationManager2.prototype.getResolver = function(id) {
    if (!this.pendingResolvers.has(id)) {
      return null;
    }
    var resolver = this.pendingResolvers.get(id);
    this.pendingResolvers.delete(id);
    return resolver;
  };
  AsyncOperationManager2.prototype.resolve = function(id, result) {
    var resolver = this.getResolver(id);
    if (resolver !== null) {
      resolver.resolve(result);
      return true;
    }
    return false;
  };
  AsyncOperationManager2.prototype.reject = function(id, reason) {
    var resolver = this.getResolver(id);
    if (resolver !== null) {
      resolver.reject(reason);
      return true;
    }
    return false;
  };
  return AsyncOperationManager2;
}();

// node_modules/web-streams-polyfill/dist/ponyfill.mjs
function e() {
}
function t(e2) {
  return "object" == typeof e2 && null !== e2 || "function" == typeof e2;
}
var r = e;
function o(e2, t2) {
  try {
    Object.defineProperty(e2, "name", { value: t2, configurable: true });
  } catch (e3) {
  }
}
var n = Promise;
var a = Promise.resolve.bind(n);
var i = Promise.prototype.then;
var l = Promise.reject.bind(n);
var s = a;
function u(e2) {
  return new n(e2);
}
function c(e2) {
  return u((t2) => t2(e2));
}
function d(e2) {
  return l(e2);
}
function f(e2, t2, r2) {
  return i.call(e2, t2, r2);
}
function b(e2, t2, o2) {
  f(f(e2, t2, o2), void 0, r);
}
function h(e2, t2) {
  b(e2, t2);
}
function m(e2, t2) {
  b(e2, void 0, t2);
}
function _(e2, t2, r2) {
  return f(e2, t2, r2);
}
function p(e2) {
  f(e2, void 0, r);
}
var y = (e2) => {
  if ("function" == typeof queueMicrotask) y = queueMicrotask;
  else {
    const e3 = c(void 0);
    y = (t2) => f(e3, t2);
  }
  return y(e2);
};
function S(e2, t2, r2) {
  if ("function" != typeof e2) throw new TypeError("Argument is not a function");
  return Function.prototype.apply.call(e2, t2, r2);
}
function g(e2, t2, r2) {
  try {
    return c(S(e2, t2, r2));
  } catch (e3) {
    return d(e3);
  }
}
var v = class {
  constructor() {
    this._cursor = 0, this._size = 0, this._front = { _elements: [], _next: void 0 }, this._back = this._front, this._cursor = 0, this._size = 0;
  }
  get length() {
    return this._size;
  }
  push(e2) {
    const t2 = this._back;
    let r2 = t2;
    16383 === t2._elements.length && (r2 = { _elements: [], _next: void 0 }), t2._elements.push(e2), r2 !== t2 && (this._back = r2, t2._next = r2), ++this._size;
  }
  shift() {
    const e2 = this._front;
    let t2 = e2;
    const r2 = this._cursor;
    let o2 = r2 + 1;
    const n2 = e2._elements, a2 = n2[r2];
    return 16384 === o2 && (t2 = e2._next, o2 = 0), --this._size, this._cursor = o2, e2 !== t2 && (this._front = t2), n2[r2] = void 0, a2;
  }
  forEach(e2) {
    let t2 = this._cursor, r2 = this._front, o2 = r2._elements;
    for (; !(t2 === o2.length && void 0 === r2._next || t2 === o2.length && (r2 = r2._next, o2 = r2._elements, t2 = 0, 0 === o2.length)); ) e2(o2[t2]), ++t2;
  }
  peek() {
    const e2 = this._front, t2 = this._cursor;
    return e2._elements[t2];
  }
};
var w = Symbol("[[AbortSteps]]");
var R = Symbol("[[ErrorSteps]]");
var T = Symbol("[[CancelSteps]]");
var C = Symbol("[[PullSteps]]");
var P = Symbol("[[ReleaseSteps]]");
function q(e2, t2) {
  e2._ownerReadableStream = t2, t2._reader = e2, "readable" === t2._state ? B(e2) : "closed" === t2._state ? function(e3) {
    B(e3), A(e3);
  }(e2) : k(e2, t2._storedError);
}
function E(e2, t2) {
  return Or(e2._ownerReadableStream, t2);
}
function W(e2) {
  const t2 = e2._ownerReadableStream;
  "readable" === t2._state ? j(e2, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function(e3, t3) {
    k(e3, t3);
  }(e2, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), t2._readableStreamController[P](), t2._reader = void 0, e2._ownerReadableStream = void 0;
}
function O(e2) {
  return new TypeError("Cannot " + e2 + " a stream using a released reader");
}
function B(e2) {
  e2._closedPromise = u((t2, r2) => {
    e2._closedPromise_resolve = t2, e2._closedPromise_reject = r2;
  });
}
function k(e2, t2) {
  B(e2), j(e2, t2);
}
function j(e2, t2) {
  void 0 !== e2._closedPromise_reject && (p(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0);
}
function A(e2) {
  void 0 !== e2._closedPromise_resolve && (e2._closedPromise_resolve(void 0), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0);
}
var z = Number.isFinite || function(e2) {
  return "number" == typeof e2 && isFinite(e2);
};
var D = Math.trunc || function(e2) {
  return e2 < 0 ? Math.ceil(e2) : Math.floor(e2);
};
function L(e2, t2) {
  if (void 0 !== e2 && ("object" != typeof (r2 = e2) && "function" != typeof r2)) throw new TypeError(`${t2} is not an object.`);
  var r2;
}
function F(e2, t2) {
  if ("function" != typeof e2) throw new TypeError(`${t2} is not a function.`);
}
function I(e2, t2) {
  if (!/* @__PURE__ */ function(e3) {
    return "object" == typeof e3 && null !== e3 || "function" == typeof e3;
  }(e2)) throw new TypeError(`${t2} is not an object.`);
}
function $(e2, t2, r2) {
  if (void 0 === e2) throw new TypeError(`Parameter ${t2} is required in '${r2}'.`);
}
function M(e2, t2, r2) {
  if (void 0 === e2) throw new TypeError(`${t2} is required in '${r2}'.`);
}
function Y(e2) {
  return Number(e2);
}
function x(e2) {
  return 0 === e2 ? 0 : e2;
}
function Q(e2, t2) {
  const r2 = Number.MAX_SAFE_INTEGER;
  let o2 = Number(e2);
  if (o2 = x(o2), !z(o2)) throw new TypeError(`${t2} is not a finite number`);
  if (o2 = function(e3) {
    return x(D(e3));
  }(o2), o2 < 0 || o2 > r2) throw new TypeError(`${t2} is outside the accepted range of 0 to ${r2}, inclusive`);
  return z(o2) && 0 !== o2 ? o2 : 0;
}
function N(e2, t2) {
  if (!Er(e2)) throw new TypeError(`${t2} is not a ReadableStream.`);
}
function H(e2) {
  return new ReadableStreamDefaultReader(e2);
}
function V(e2, t2) {
  e2._reader._readRequests.push(t2);
}
function U(e2, t2, r2) {
  const o2 = e2._reader._readRequests.shift();
  r2 ? o2._closeSteps() : o2._chunkSteps(t2);
}
function G(e2) {
  return e2._reader._readRequests.length;
}
function X(e2) {
  const t2 = e2._reader;
  return void 0 !== t2 && !!J(t2);
}
var ReadableStreamDefaultReader = class {
  constructor(e2) {
    if ($(e2, 1, "ReadableStreamDefaultReader"), N(e2, "First parameter"), Wr(e2)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
    q(this, e2), this._readRequests = new v();
  }
  get closed() {
    return J(this) ? this._closedPromise : d(ee("closed"));
  }
  cancel(e2 = void 0) {
    return J(this) ? void 0 === this._ownerReadableStream ? d(O("cancel")) : E(this, e2) : d(ee("cancel"));
  }
  read() {
    if (!J(this)) return d(ee("read"));
    if (void 0 === this._ownerReadableStream) return d(O("read from"));
    let e2, t2;
    const r2 = u((r3, o2) => {
      e2 = r3, t2 = o2;
    });
    return K(this, { _chunkSteps: (t3) => e2({ value: t3, done: false }), _closeSteps: () => e2({ value: void 0, done: true }), _errorSteps: (e3) => t2(e3) }), r2;
  }
  releaseLock() {
    if (!J(this)) throw ee("releaseLock");
    void 0 !== this._ownerReadableStream && function(e2) {
      W(e2);
      const t2 = new TypeError("Reader was released");
      Z(e2, t2);
    }(this);
  }
};
function J(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_readRequests") && e2 instanceof ReadableStreamDefaultReader);
}
function K(e2, t2) {
  const r2 = e2._ownerReadableStream;
  r2._disturbed = true, "closed" === r2._state ? t2._closeSteps() : "errored" === r2._state ? t2._errorSteps(r2._storedError) : r2._readableStreamController[C](t2);
}
function Z(e2, t2) {
  const r2 = e2._readRequests;
  e2._readRequests = new v(), r2.forEach((e3) => {
    e3._errorSteps(t2);
  });
}
function ee(e2) {
  return new TypeError(`ReadableStreamDefaultReader.prototype.${e2} can only be used on a ReadableStreamDefaultReader`);
}
var te;
var re;
var oe;
function ne(e2) {
  return e2.slice();
}
function ae(e2, t2, r2, o2, n2) {
  new Uint8Array(e2).set(new Uint8Array(r2, o2, n2), t2);
}
Object.defineProperties(ReadableStreamDefaultReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), o(ReadableStreamDefaultReader.prototype.cancel, "cancel"), o(ReadableStreamDefaultReader.prototype.read, "read"), o(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, { value: "ReadableStreamDefaultReader", configurable: true });
var ie = (e2) => (ie = "function" == typeof e2.transfer ? (e3) => e3.transfer() : "function" == typeof structuredClone ? (e3) => structuredClone(e3, { transfer: [e3] }) : (e3) => e3, ie(e2));
var le = (e2) => (le = "boolean" == typeof e2.detached ? (e3) => e3.detached : (e3) => 0 === e3.byteLength, le(e2));
function se(e2, t2, r2) {
  if (e2.slice) return e2.slice(t2, r2);
  const o2 = r2 - t2, n2 = new ArrayBuffer(o2);
  return ae(n2, 0, e2, t2, o2), n2;
}
function ue(e2, t2) {
  const r2 = e2[t2];
  if (null != r2) {
    if ("function" != typeof r2) throw new TypeError(`${String(t2)} is not a function`);
    return r2;
  }
}
function ce(e2) {
  try {
    const t2 = e2.done, r2 = e2.value;
    return f(s(r2), (e3) => ({ done: t2, value: e3 }));
  } catch (e3) {
    return d(e3);
  }
}
var de = null !== (oe = null !== (te = Symbol.asyncIterator) && void 0 !== te ? te : null === (re = Symbol.for) || void 0 === re ? void 0 : re.call(Symbol, "Symbol.asyncIterator")) && void 0 !== oe ? oe : "@@asyncIterator";
function fe(e2, r2 = "sync", o2) {
  if (void 0 === o2) if ("async" === r2) {
    if (void 0 === (o2 = ue(e2, de))) {
      return function(e3) {
        const r3 = { next() {
          let t2;
          try {
            t2 = be(e3);
          } catch (e4) {
            return d(e4);
          }
          return ce(t2);
        }, return(r4) {
          let o3;
          try {
            const t2 = ue(e3.iterator, "return");
            if (void 0 === t2) return c({ done: true, value: r4 });
            o3 = S(t2, e3.iterator, [r4]);
          } catch (e4) {
            return d(e4);
          }
          return t(o3) ? ce(o3) : d(new TypeError("The iterator.return() method must return an object"));
        } };
        return { iterator: r3, nextMethod: r3.next, done: false };
      }(fe(e2, "sync", ue(e2, Symbol.iterator)));
    }
  } else o2 = ue(e2, Symbol.iterator);
  if (void 0 === o2) throw new TypeError("The object is not iterable");
  const n2 = S(o2, e2, []);
  if (!t(n2)) throw new TypeError("The iterator method must return an object");
  return { iterator: n2, nextMethod: n2.next, done: false };
}
function be(e2) {
  const r2 = S(e2.nextMethod, e2.iterator, []);
  if (!t(r2)) throw new TypeError("The iterator.next() method must return an object");
  return r2;
}
var he = class {
  constructor(e2, t2) {
    this._ongoingPromise = void 0, this._isFinished = false, this._reader = e2, this._preventCancel = t2;
  }
  next() {
    const e2 = () => this._nextSteps();
    return this._ongoingPromise = this._ongoingPromise ? _(this._ongoingPromise, e2, e2) : e2(), this._ongoingPromise;
  }
  return(e2) {
    const t2 = () => this._returnSteps(e2);
    return this._ongoingPromise = this._ongoingPromise ? _(this._ongoingPromise, t2, t2) : t2(), this._ongoingPromise;
  }
  _nextSteps() {
    if (this._isFinished) return Promise.resolve({ value: void 0, done: true });
    const e2 = this._reader;
    let t2, r2;
    const o2 = u((e3, o3) => {
      t2 = e3, r2 = o3;
    });
    return K(e2, { _chunkSteps: (e3) => {
      this._ongoingPromise = void 0, y(() => t2({ value: e3, done: false }));
    }, _closeSteps: () => {
      this._ongoingPromise = void 0, this._isFinished = true, W(e2), t2({ value: void 0, done: true });
    }, _errorSteps: (t3) => {
      this._ongoingPromise = void 0, this._isFinished = true, W(e2), r2(t3);
    } }), o2;
  }
  _returnSteps(e2) {
    if (this._isFinished) return Promise.resolve({ value: e2, done: true });
    this._isFinished = true;
    const t2 = this._reader;
    if (!this._preventCancel) {
      const r2 = E(t2, e2);
      return W(t2), _(r2, () => ({ value: e2, done: true }));
    }
    return W(t2), c({ value: e2, done: true });
  }
};
var me = { next() {
  return _e(this) ? this._asyncIteratorImpl.next() : d(pe("next"));
}, return(e2) {
  return _e(this) ? this._asyncIteratorImpl.return(e2) : d(pe("return"));
}, [de]() {
  return this;
} };
function _e(e2) {
  if (!t(e2)) return false;
  if (!Object.prototype.hasOwnProperty.call(e2, "_asyncIteratorImpl")) return false;
  try {
    return e2._asyncIteratorImpl instanceof he;
  } catch (e3) {
    return false;
  }
}
function pe(e2) {
  return new TypeError(`ReadableStreamAsyncIterator.${e2} can only be used on a ReadableSteamAsyncIterator`);
}
Object.defineProperty(me, de, { enumerable: false });
var ye = Number.isNaN || function(e2) {
  return e2 != e2;
};
function Se(e2) {
  const t2 = se(e2.buffer, e2.byteOffset, e2.byteOffset + e2.byteLength);
  return new Uint8Array(t2);
}
function ge(e2) {
  const t2 = e2._queue.shift();
  return e2._queueTotalSize -= t2.size, e2._queueTotalSize < 0 && (e2._queueTotalSize = 0), t2.value;
}
function ve(e2, t2, r2) {
  if ("number" != typeof (o2 = r2) || ye(o2) || o2 < 0 || r2 === 1 / 0) throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
  var o2;
  e2._queue.push({ value: t2, size: r2 }), e2._queueTotalSize += r2;
}
function we(e2) {
  e2._queue = new v(), e2._queueTotalSize = 0;
}
function Re(e2) {
  return e2 === DataView;
}
var ReadableStreamBYOBRequest = class {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get view() {
    if (!Ce(this)) throw Ke("view");
    return this._view;
  }
  respond(e2) {
    if (!Ce(this)) throw Ke("respond");
    if ($(e2, 1, "respond"), e2 = Q(e2, "First parameter"), void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
    if (le(this._view.buffer)) throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");
    Ge(this._associatedReadableByteStreamController, e2);
  }
  respondWithNewView(e2) {
    if (!Ce(this)) throw Ke("respondWithNewView");
    if ($(e2, 1, "respondWithNewView"), !ArrayBuffer.isView(e2)) throw new TypeError("You can only respond with array buffer views");
    if (void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
    if (le(e2.buffer)) throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
    Xe(this._associatedReadableByteStreamController, e2);
  }
};
Object.defineProperties(ReadableStreamBYOBRequest.prototype, { respond: { enumerable: true }, respondWithNewView: { enumerable: true }, view: { enumerable: true } }), o(ReadableStreamBYOBRequest.prototype.respond, "respond"), o(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, { value: "ReadableStreamBYOBRequest", configurable: true });
var ReadableByteStreamController = class {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get byobRequest() {
    if (!Te(this)) throw Ze("byobRequest");
    return Ve(this);
  }
  get desiredSize() {
    if (!Te(this)) throw Ze("desiredSize");
    return Ue(this);
  }
  close() {
    if (!Te(this)) throw Ze("close");
    if (this._closeRequested) throw new TypeError("The stream has already been closed; do not close it again!");
    const e2 = this._controlledReadableByteStream._state;
    if ("readable" !== e2) throw new TypeError(`The stream (in ${e2} state) is not in the readable state and cannot be closed`);
    xe(this);
  }
  enqueue(e2) {
    if (!Te(this)) throw Ze("enqueue");
    if ($(e2, 1, "enqueue"), !ArrayBuffer.isView(e2)) throw new TypeError("chunk must be an array buffer view");
    if (0 === e2.byteLength) throw new TypeError("chunk must have non-zero byteLength");
    if (0 === e2.buffer.byteLength) throw new TypeError("chunk's buffer must have non-zero byteLength");
    if (this._closeRequested) throw new TypeError("stream is closed or draining");
    const t2 = this._controlledReadableByteStream._state;
    if ("readable" !== t2) throw new TypeError(`The stream (in ${t2} state) is not in the readable state and cannot be enqueued to`);
    Qe(this, e2);
  }
  error(e2 = void 0) {
    if (!Te(this)) throw Ze("error");
    Ne(this, e2);
  }
  [T](e2) {
    qe(this), we(this);
    const t2 = this._cancelAlgorithm(e2);
    return Ye(this), t2;
  }
  [C](e2) {
    const t2 = this._controlledReadableByteStream;
    if (this._queueTotalSize > 0) return void He(this, e2);
    const r2 = this._autoAllocateChunkSize;
    if (void 0 !== r2) {
      let t3;
      try {
        t3 = new ArrayBuffer(r2);
      } catch (t4) {
        return void e2._errorSteps(t4);
      }
      const o2 = { buffer: t3, bufferByteLength: r2, byteOffset: 0, byteLength: r2, bytesFilled: 0, minimumFill: 1, elementSize: 1, viewConstructor: Uint8Array, readerType: "default" };
      this._pendingPullIntos.push(o2);
    }
    V(t2, e2), Pe(this);
  }
  [P]() {
    if (this._pendingPullIntos.length > 0) {
      const e2 = this._pendingPullIntos.peek();
      e2.readerType = "none", this._pendingPullIntos = new v(), this._pendingPullIntos.push(e2);
    }
  }
};
function Te(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_controlledReadableByteStream") && e2 instanceof ReadableByteStreamController);
}
function Ce(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_associatedReadableByteStreamController") && e2 instanceof ReadableStreamBYOBRequest);
}
function Pe(e2) {
  const t2 = function(e3) {
    const t3 = e3._controlledReadableByteStream;
    if ("readable" !== t3._state) return false;
    if (e3._closeRequested) return false;
    if (!e3._started) return false;
    if (X(t3) && G(t3) > 0) return true;
    if (nt(t3) && ot(t3) > 0) return true;
    const r2 = Ue(e3);
    if (r2 > 0) return true;
    return false;
  }(e2);
  if (!t2) return;
  if (e2._pulling) return void (e2._pullAgain = true);
  e2._pulling = true;
  b(e2._pullAlgorithm(), () => (e2._pulling = false, e2._pullAgain && (e2._pullAgain = false, Pe(e2)), null), (t3) => (Ne(e2, t3), null));
}
function qe(e2) {
  Le(e2), e2._pendingPullIntos = new v();
}
function Ee(e2, t2) {
  let r2 = false;
  "closed" === e2._state && (r2 = true);
  const o2 = Oe(t2);
  "default" === t2.readerType ? U(e2, o2, r2) : function(e3, t3, r3) {
    const o3 = e3._reader, n2 = o3._readIntoRequests.shift();
    r3 ? n2._closeSteps(t3) : n2._chunkSteps(t3);
  }(e2, o2, r2);
}
function We(e2, t2) {
  for (let r2 = 0; r2 < t2.length; ++r2) Ee(e2, t2[r2]);
}
function Oe(e2) {
  const t2 = e2.bytesFilled, r2 = e2.elementSize;
  return new e2.viewConstructor(e2.buffer, e2.byteOffset, t2 / r2);
}
function Be(e2, t2, r2, o2) {
  e2._queue.push({ buffer: t2, byteOffset: r2, byteLength: o2 }), e2._queueTotalSize += o2;
}
function ke(e2, t2, r2, o2) {
  let n2;
  try {
    n2 = se(t2, r2, r2 + o2);
  } catch (t3) {
    throw Ne(e2, t3), t3;
  }
  Be(e2, n2, 0, o2);
}
function je(e2, t2) {
  t2.bytesFilled > 0 && ke(e2, t2.buffer, t2.byteOffset, t2.bytesFilled), Me(e2);
}
function Ae(e2, t2) {
  const r2 = Math.min(e2._queueTotalSize, t2.byteLength - t2.bytesFilled), o2 = t2.bytesFilled + r2;
  let n2 = r2, a2 = false;
  const i2 = o2 - o2 % t2.elementSize;
  i2 >= t2.minimumFill && (n2 = i2 - t2.bytesFilled, a2 = true);
  const l2 = e2._queue;
  for (; n2 > 0; ) {
    const r3 = l2.peek(), o3 = Math.min(n2, r3.byteLength), a3 = t2.byteOffset + t2.bytesFilled;
    ae(t2.buffer, a3, r3.buffer, r3.byteOffset, o3), r3.byteLength === o3 ? l2.shift() : (r3.byteOffset += o3, r3.byteLength -= o3), e2._queueTotalSize -= o3, ze(e2, o3, t2), n2 -= o3;
  }
  return a2;
}
function ze(e2, t2, r2) {
  r2.bytesFilled += t2;
}
function De(e2) {
  0 === e2._queueTotalSize && e2._closeRequested ? (Ye(e2), Br(e2._controlledReadableByteStream)) : Pe(e2);
}
function Le(e2) {
  null !== e2._byobRequest && (e2._byobRequest._associatedReadableByteStreamController = void 0, e2._byobRequest._view = null, e2._byobRequest = null);
}
function Fe(e2) {
  const t2 = [];
  for (; e2._pendingPullIntos.length > 0 && 0 !== e2._queueTotalSize; ) {
    const r2 = e2._pendingPullIntos.peek();
    Ae(e2, r2) && (Me(e2), t2.push(r2));
  }
  return t2;
}
function Ie(e2, t2, r2, o2) {
  const n2 = e2._controlledReadableByteStream, a2 = t2.constructor, i2 = function(e3) {
    return Re(e3) ? 1 : e3.BYTES_PER_ELEMENT;
  }(a2), { byteOffset: l2, byteLength: s2 } = t2, u2 = r2 * i2;
  let c2;
  try {
    c2 = ie(t2.buffer);
  } catch (e3) {
    return void o2._errorSteps(e3);
  }
  const d2 = { buffer: c2, bufferByteLength: c2.byteLength, byteOffset: l2, byteLength: s2, bytesFilled: 0, minimumFill: u2, elementSize: i2, viewConstructor: a2, readerType: "byob" };
  if (e2._pendingPullIntos.length > 0) return e2._pendingPullIntos.push(d2), void rt(n2, o2);
  if ("closed" === n2._state) {
    const e3 = new a2(d2.buffer, d2.byteOffset, 0);
    return void o2._closeSteps(e3);
  }
  if (e2._queueTotalSize > 0) {
    if (Ae(e2, d2)) {
      const t3 = Oe(d2);
      return De(e2), void o2._chunkSteps(t3);
    }
    if (e2._closeRequested) {
      const t3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
      return Ne(e2, t3), void o2._errorSteps(t3);
    }
  }
  e2._pendingPullIntos.push(d2), rt(n2, o2), Pe(e2);
}
function $e(e2, t2) {
  const r2 = e2._pendingPullIntos.peek();
  Le(e2);
  "closed" === e2._controlledReadableByteStream._state ? function(e3, t3) {
    "none" === t3.readerType && Me(e3);
    const r3 = e3._controlledReadableByteStream;
    if (nt(r3)) {
      const t4 = [];
      for (; t4.length < ot(r3); ) t4.push(Me(e3));
      We(r3, t4);
    }
  }(e2, r2) : function(e3, t3, r3) {
    if (ze(0, t3, r3), "none" === r3.readerType) {
      je(e3, r3);
      const t4 = Fe(e3);
      return void We(e3._controlledReadableByteStream, t4);
    }
    if (r3.bytesFilled < r3.minimumFill) return;
    Me(e3);
    const o2 = r3.bytesFilled % r3.elementSize;
    if (o2 > 0) {
      const t4 = r3.byteOffset + r3.bytesFilled;
      ke(e3, r3.buffer, t4 - o2, o2);
    }
    r3.bytesFilled -= o2;
    const n2 = Fe(e3);
    Ee(e3._controlledReadableByteStream, r3), We(e3._controlledReadableByteStream, n2);
  }(e2, t2, r2), Pe(e2);
}
function Me(e2) {
  return e2._pendingPullIntos.shift();
}
function Ye(e2) {
  e2._pullAlgorithm = void 0, e2._cancelAlgorithm = void 0;
}
function xe(e2) {
  const t2 = e2._controlledReadableByteStream;
  if (!e2._closeRequested && "readable" === t2._state) if (e2._queueTotalSize > 0) e2._closeRequested = true;
  else {
    if (e2._pendingPullIntos.length > 0) {
      const t3 = e2._pendingPullIntos.peek();
      if (t3.bytesFilled % t3.elementSize !== 0) {
        const t4 = new TypeError("Insufficient bytes to fill elements in the given buffer");
        throw Ne(e2, t4), t4;
      }
    }
    Ye(e2), Br(t2);
  }
}
function Qe(e2, t2) {
  const r2 = e2._controlledReadableByteStream;
  if (e2._closeRequested || "readable" !== r2._state) return;
  const { buffer: o2, byteOffset: n2, byteLength: a2 } = t2;
  if (le(o2)) throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
  const i2 = ie(o2);
  if (e2._pendingPullIntos.length > 0) {
    const t3 = e2._pendingPullIntos.peek();
    if (le(t3.buffer)) throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
    Le(e2), t3.buffer = ie(t3.buffer), "none" === t3.readerType && je(e2, t3);
  }
  if (X(r2)) if (function(e3) {
    const t3 = e3._controlledReadableByteStream._reader;
    for (; t3._readRequests.length > 0; ) {
      if (0 === e3._queueTotalSize) return;
      He(e3, t3._readRequests.shift());
    }
  }(e2), 0 === G(r2)) Be(e2, i2, n2, a2);
  else {
    e2._pendingPullIntos.length > 0 && Me(e2);
    U(r2, new Uint8Array(i2, n2, a2), false);
  }
  else if (nt(r2)) {
    Be(e2, i2, n2, a2);
    We(r2, Fe(e2));
  } else Be(e2, i2, n2, a2);
  Pe(e2);
}
function Ne(e2, t2) {
  const r2 = e2._controlledReadableByteStream;
  "readable" === r2._state && (qe(e2), we(e2), Ye(e2), kr(r2, t2));
}
function He(e2, t2) {
  const r2 = e2._queue.shift();
  e2._queueTotalSize -= r2.byteLength, De(e2);
  const o2 = new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  t2._chunkSteps(o2);
}
function Ve(e2) {
  if (null === e2._byobRequest && e2._pendingPullIntos.length > 0) {
    const t2 = e2._pendingPullIntos.peek(), r2 = new Uint8Array(t2.buffer, t2.byteOffset + t2.bytesFilled, t2.byteLength - t2.bytesFilled), o2 = Object.create(ReadableStreamBYOBRequest.prototype);
    !function(e3, t3, r3) {
      e3._associatedReadableByteStreamController = t3, e3._view = r3;
    }(o2, e2, r2), e2._byobRequest = o2;
  }
  return e2._byobRequest;
}
function Ue(e2) {
  const t2 = e2._controlledReadableByteStream._state;
  return "errored" === t2 ? null : "closed" === t2 ? 0 : e2._strategyHWM - e2._queueTotalSize;
}
function Ge(e2, t2) {
  const r2 = e2._pendingPullIntos.peek();
  if ("closed" === e2._controlledReadableByteStream._state) {
    if (0 !== t2) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
  } else {
    if (0 === t2) throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
    if (r2.bytesFilled + t2 > r2.byteLength) throw new RangeError("bytesWritten out of range");
  }
  r2.buffer = ie(r2.buffer), $e(e2, t2);
}
function Xe(e2, t2) {
  const r2 = e2._pendingPullIntos.peek();
  if ("closed" === e2._controlledReadableByteStream._state) {
    if (0 !== t2.byteLength) throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
  } else if (0 === t2.byteLength) throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
  if (r2.byteOffset + r2.bytesFilled !== t2.byteOffset) throw new RangeError("The region specified by view does not match byobRequest");
  if (r2.bufferByteLength !== t2.buffer.byteLength) throw new RangeError("The buffer of view has different capacity than byobRequest");
  if (r2.bytesFilled + t2.byteLength > r2.byteLength) throw new RangeError("The region specified by view is larger than byobRequest");
  const o2 = t2.byteLength;
  r2.buffer = ie(t2.buffer), $e(e2, o2);
}
function Je(e2, t2, r2, o2, n2, a2, i2) {
  t2._controlledReadableByteStream = e2, t2._pullAgain = false, t2._pulling = false, t2._byobRequest = null, t2._queue = t2._queueTotalSize = void 0, we(t2), t2._closeRequested = false, t2._started = false, t2._strategyHWM = a2, t2._pullAlgorithm = o2, t2._cancelAlgorithm = n2, t2._autoAllocateChunkSize = i2, t2._pendingPullIntos = new v(), e2._readableStreamController = t2;
  b(c(r2()), () => (t2._started = true, Pe(t2), null), (e3) => (Ne(t2, e3), null));
}
function Ke(e2) {
  return new TypeError(`ReadableStreamBYOBRequest.prototype.${e2} can only be used on a ReadableStreamBYOBRequest`);
}
function Ze(e2) {
  return new TypeError(`ReadableByteStreamController.prototype.${e2} can only be used on a ReadableByteStreamController`);
}
function et(e2, t2) {
  if ("byob" !== (e2 = `${e2}`)) throw new TypeError(`${t2} '${e2}' is not a valid enumeration value for ReadableStreamReaderMode`);
  return e2;
}
function tt(e2) {
  return new ReadableStreamBYOBReader(e2);
}
function rt(e2, t2) {
  e2._reader._readIntoRequests.push(t2);
}
function ot(e2) {
  return e2._reader._readIntoRequests.length;
}
function nt(e2) {
  const t2 = e2._reader;
  return void 0 !== t2 && !!at(t2);
}
Object.defineProperties(ReadableByteStreamController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, byobRequest: { enumerable: true }, desiredSize: { enumerable: true } }), o(ReadableByteStreamController.prototype.close, "close"), o(ReadableByteStreamController.prototype.enqueue, "enqueue"), o(ReadableByteStreamController.prototype.error, "error"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, { value: "ReadableByteStreamController", configurable: true });
var ReadableStreamBYOBReader = class {
  constructor(e2) {
    if ($(e2, 1, "ReadableStreamBYOBReader"), N(e2, "First parameter"), Wr(e2)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
    if (!Te(e2._readableStreamController)) throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
    q(this, e2), this._readIntoRequests = new v();
  }
  get closed() {
    return at(this) ? this._closedPromise : d(st("closed"));
  }
  cancel(e2 = void 0) {
    return at(this) ? void 0 === this._ownerReadableStream ? d(O("cancel")) : E(this, e2) : d(st("cancel"));
  }
  read(e2, t2 = {}) {
    if (!at(this)) return d(st("read"));
    if (!ArrayBuffer.isView(e2)) return d(new TypeError("view must be an array buffer view"));
    if (0 === e2.byteLength) return d(new TypeError("view must have non-zero byteLength"));
    if (0 === e2.buffer.byteLength) return d(new TypeError("view's buffer must have non-zero byteLength"));
    if (le(e2.buffer)) return d(new TypeError("view's buffer has been detached"));
    let r2;
    try {
      r2 = function(e3, t3) {
        var r3;
        return L(e3, t3), { min: Q(null !== (r3 = null == e3 ? void 0 : e3.min) && void 0 !== r3 ? r3 : 1, `${t3} has member 'min' that`) };
      }(t2, "options");
    } catch (e3) {
      return d(e3);
    }
    const o2 = r2.min;
    if (0 === o2) return d(new TypeError("options.min must be greater than 0"));
    if (function(e3) {
      return Re(e3.constructor);
    }(e2)) {
      if (o2 > e2.byteLength) return d(new RangeError("options.min must be less than or equal to view's byteLength"));
    } else if (o2 > e2.length) return d(new RangeError("options.min must be less than or equal to view's length"));
    if (void 0 === this._ownerReadableStream) return d(O("read from"));
    let n2, a2;
    const i2 = u((e3, t3) => {
      n2 = e3, a2 = t3;
    });
    return it(this, e2, o2, { _chunkSteps: (e3) => n2({ value: e3, done: false }), _closeSteps: (e3) => n2({ value: e3, done: true }), _errorSteps: (e3) => a2(e3) }), i2;
  }
  releaseLock() {
    if (!at(this)) throw st("releaseLock");
    void 0 !== this._ownerReadableStream && function(e2) {
      W(e2);
      const t2 = new TypeError("Reader was released");
      lt(e2, t2);
    }(this);
  }
};
function at(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_readIntoRequests") && e2 instanceof ReadableStreamBYOBReader);
}
function it(e2, t2, r2, o2) {
  const n2 = e2._ownerReadableStream;
  n2._disturbed = true, "errored" === n2._state ? o2._errorSteps(n2._storedError) : Ie(n2._readableStreamController, t2, r2, o2);
}
function lt(e2, t2) {
  const r2 = e2._readIntoRequests;
  e2._readIntoRequests = new v(), r2.forEach((e3) => {
    e3._errorSteps(t2);
  });
}
function st(e2) {
  return new TypeError(`ReadableStreamBYOBReader.prototype.${e2} can only be used on a ReadableStreamBYOBReader`);
}
function ut(e2, t2) {
  const { highWaterMark: r2 } = e2;
  if (void 0 === r2) return t2;
  if (ye(r2) || r2 < 0) throw new RangeError("Invalid highWaterMark");
  return r2;
}
function ct(e2) {
  const { size: t2 } = e2;
  return t2 || (() => 1);
}
function dt(e2, t2) {
  L(e2, t2);
  const r2 = null == e2 ? void 0 : e2.highWaterMark, o2 = null == e2 ? void 0 : e2.size;
  return { highWaterMark: void 0 === r2 ? void 0 : Y(r2), size: void 0 === o2 ? void 0 : ft(o2, `${t2} has member 'size' that`) };
}
function ft(e2, t2) {
  return F(e2, t2), (t3) => Y(e2(t3));
}
function bt(e2, t2, r2) {
  return F(e2, r2), (r3) => g(e2, t2, [r3]);
}
function ht(e2, t2, r2) {
  return F(e2, r2), () => g(e2, t2, []);
}
function mt(e2, t2, r2) {
  return F(e2, r2), (r3) => S(e2, t2, [r3]);
}
function _t(e2, t2, r2) {
  return F(e2, r2), (r3, o2) => g(e2, t2, [r3, o2]);
}
function pt(e2, t2) {
  if (!gt(e2)) throw new TypeError(`${t2} is not a WritableStream.`);
}
Object.defineProperties(ReadableStreamBYOBReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), o(ReadableStreamBYOBReader.prototype.cancel, "cancel"), o(ReadableStreamBYOBReader.prototype.read, "read"), o(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, { value: "ReadableStreamBYOBReader", configurable: true });
var WritableStream = class {
  constructor(e2 = {}, t2 = {}) {
    void 0 === e2 ? e2 = null : I(e2, "First parameter");
    const r2 = dt(t2, "Second parameter"), o2 = function(e3, t3) {
      L(e3, t3);
      const r3 = null == e3 ? void 0 : e3.abort, o3 = null == e3 ? void 0 : e3.close, n3 = null == e3 ? void 0 : e3.start, a2 = null == e3 ? void 0 : e3.type, i2 = null == e3 ? void 0 : e3.write;
      return { abort: void 0 === r3 ? void 0 : bt(r3, e3, `${t3} has member 'abort' that`), close: void 0 === o3 ? void 0 : ht(o3, e3, `${t3} has member 'close' that`), start: void 0 === n3 ? void 0 : mt(n3, e3, `${t3} has member 'start' that`), write: void 0 === i2 ? void 0 : _t(i2, e3, `${t3} has member 'write' that`), type: a2 };
    }(e2, "First parameter");
    St(this);
    if (void 0 !== o2.type) throw new RangeError("Invalid type is specified");
    const n2 = ct(r2);
    !function(e3, t3, r3, o3) {
      const n3 = Object.create(WritableStreamDefaultController.prototype);
      let a2, i2, l2, s2;
      a2 = void 0 !== t3.start ? () => t3.start(n3) : () => {
      };
      i2 = void 0 !== t3.write ? (e4) => t3.write(e4, n3) : () => c(void 0);
      l2 = void 0 !== t3.close ? () => t3.close() : () => c(void 0);
      s2 = void 0 !== t3.abort ? (e4) => t3.abort(e4) : () => c(void 0);
      Ft(e3, n3, a2, i2, l2, s2, r3, o3);
    }(this, o2, ut(r2, 1), n2);
  }
  get locked() {
    if (!gt(this)) throw Nt("locked");
    return vt(this);
  }
  abort(e2 = void 0) {
    return gt(this) ? vt(this) ? d(new TypeError("Cannot abort a stream that already has a writer")) : wt(this, e2) : d(Nt("abort"));
  }
  close() {
    return gt(this) ? vt(this) ? d(new TypeError("Cannot close a stream that already has a writer")) : qt(this) ? d(new TypeError("Cannot close an already-closing stream")) : Rt(this) : d(Nt("close"));
  }
  getWriter() {
    if (!gt(this)) throw Nt("getWriter");
    return yt(this);
  }
};
function yt(e2) {
  return new WritableStreamDefaultWriter(e2);
}
function St(e2) {
  e2._state = "writable", e2._storedError = void 0, e2._writer = void 0, e2._writableStreamController = void 0, e2._writeRequests = new v(), e2._inFlightWriteRequest = void 0, e2._closeRequest = void 0, e2._inFlightCloseRequest = void 0, e2._pendingAbortRequest = void 0, e2._backpressure = false;
}
function gt(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_writableStreamController") && e2 instanceof WritableStream);
}
function vt(e2) {
  return void 0 !== e2._writer;
}
function wt(e2, t2) {
  var r2;
  if ("closed" === e2._state || "errored" === e2._state) return c(void 0);
  e2._writableStreamController._abortReason = t2, null === (r2 = e2._writableStreamController._abortController) || void 0 === r2 || r2.abort(t2);
  const o2 = e2._state;
  if ("closed" === o2 || "errored" === o2) return c(void 0);
  if (void 0 !== e2._pendingAbortRequest) return e2._pendingAbortRequest._promise;
  let n2 = false;
  "erroring" === o2 && (n2 = true, t2 = void 0);
  const a2 = u((r3, o3) => {
    e2._pendingAbortRequest = { _promise: void 0, _resolve: r3, _reject: o3, _reason: t2, _wasAlreadyErroring: n2 };
  });
  return e2._pendingAbortRequest._promise = a2, n2 || Ct(e2, t2), a2;
}
function Rt(e2) {
  const t2 = e2._state;
  if ("closed" === t2 || "errored" === t2) return d(new TypeError(`The stream (in ${t2} state) is not in the writable state and cannot be closed`));
  const r2 = u((t3, r3) => {
    const o3 = { _resolve: t3, _reject: r3 };
    e2._closeRequest = o3;
  }), o2 = e2._writer;
  var n2;
  return void 0 !== o2 && e2._backpressure && "writable" === t2 && or(o2), ve(n2 = e2._writableStreamController, Dt, 0), Mt(n2), r2;
}
function Tt(e2, t2) {
  "writable" !== e2._state ? Pt(e2) : Ct(e2, t2);
}
function Ct(e2, t2) {
  const r2 = e2._writableStreamController;
  e2._state = "erroring", e2._storedError = t2;
  const o2 = e2._writer;
  void 0 !== o2 && jt(o2, t2), !function(e3) {
    if (void 0 === e3._inFlightWriteRequest && void 0 === e3._inFlightCloseRequest) return false;
    return true;
  }(e2) && r2._started && Pt(e2);
}
function Pt(e2) {
  e2._state = "errored", e2._writableStreamController[R]();
  const t2 = e2._storedError;
  if (e2._writeRequests.forEach((e3) => {
    e3._reject(t2);
  }), e2._writeRequests = new v(), void 0 === e2._pendingAbortRequest) return void Et(e2);
  const r2 = e2._pendingAbortRequest;
  if (e2._pendingAbortRequest = void 0, r2._wasAlreadyErroring) return r2._reject(t2), void Et(e2);
  b(e2._writableStreamController[w](r2._reason), () => (r2._resolve(), Et(e2), null), (t3) => (r2._reject(t3), Et(e2), null));
}
function qt(e2) {
  return void 0 !== e2._closeRequest || void 0 !== e2._inFlightCloseRequest;
}
function Et(e2) {
  void 0 !== e2._closeRequest && (e2._closeRequest._reject(e2._storedError), e2._closeRequest = void 0);
  const t2 = e2._writer;
  void 0 !== t2 && Jt(t2, e2._storedError);
}
function Wt(e2, t2) {
  const r2 = e2._writer;
  void 0 !== r2 && t2 !== e2._backpressure && (t2 ? function(e3) {
    Zt(e3);
  }(r2) : or(r2)), e2._backpressure = t2;
}
Object.defineProperties(WritableStream.prototype, { abort: { enumerable: true }, close: { enumerable: true }, getWriter: { enumerable: true }, locked: { enumerable: true } }), o(WritableStream.prototype.abort, "abort"), o(WritableStream.prototype.close, "close"), o(WritableStream.prototype.getWriter, "getWriter"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, { value: "WritableStream", configurable: true });
var WritableStreamDefaultWriter = class {
  constructor(e2) {
    if ($(e2, 1, "WritableStreamDefaultWriter"), pt(e2, "First parameter"), vt(e2)) throw new TypeError("This stream has already been locked for exclusive writing by another writer");
    this._ownerWritableStream = e2, e2._writer = this;
    const t2 = e2._state;
    if ("writable" === t2) !qt(e2) && e2._backpressure ? Zt(this) : tr(this), Gt(this);
    else if ("erroring" === t2) er(this, e2._storedError), Gt(this);
    else if ("closed" === t2) tr(this), Gt(r2 = this), Kt(r2);
    else {
      const t3 = e2._storedError;
      er(this, t3), Xt(this, t3);
    }
    var r2;
  }
  get closed() {
    return Ot(this) ? this._closedPromise : d(Vt("closed"));
  }
  get desiredSize() {
    if (!Ot(this)) throw Vt("desiredSize");
    if (void 0 === this._ownerWritableStream) throw Ut("desiredSize");
    return function(e2) {
      const t2 = e2._ownerWritableStream, r2 = t2._state;
      if ("errored" === r2 || "erroring" === r2) return null;
      if ("closed" === r2) return 0;
      return $t(t2._writableStreamController);
    }(this);
  }
  get ready() {
    return Ot(this) ? this._readyPromise : d(Vt("ready"));
  }
  abort(e2 = void 0) {
    return Ot(this) ? void 0 === this._ownerWritableStream ? d(Ut("abort")) : function(e3, t2) {
      return wt(e3._ownerWritableStream, t2);
    }(this, e2) : d(Vt("abort"));
  }
  close() {
    if (!Ot(this)) return d(Vt("close"));
    const e2 = this._ownerWritableStream;
    return void 0 === e2 ? d(Ut("close")) : qt(e2) ? d(new TypeError("Cannot close an already-closing stream")) : Bt(this);
  }
  releaseLock() {
    if (!Ot(this)) throw Vt("releaseLock");
    void 0 !== this._ownerWritableStream && At(this);
  }
  write(e2 = void 0) {
    return Ot(this) ? void 0 === this._ownerWritableStream ? d(Ut("write to")) : zt(this, e2) : d(Vt("write"));
  }
};
function Ot(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_ownerWritableStream") && e2 instanceof WritableStreamDefaultWriter);
}
function Bt(e2) {
  return Rt(e2._ownerWritableStream);
}
function kt(e2, t2) {
  "pending" === e2._closedPromiseState ? Jt(e2, t2) : function(e3, t3) {
    Xt(e3, t3);
  }(e2, t2);
}
function jt(e2, t2) {
  "pending" === e2._readyPromiseState ? rr(e2, t2) : function(e3, t3) {
    er(e3, t3);
  }(e2, t2);
}
function At(e2) {
  const t2 = e2._ownerWritableStream, r2 = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
  jt(e2, r2), kt(e2, r2), t2._writer = void 0, e2._ownerWritableStream = void 0;
}
function zt(e2, t2) {
  const r2 = e2._ownerWritableStream, o2 = r2._writableStreamController, n2 = function(e3, t3) {
    if (void 0 === e3._strategySizeAlgorithm) return 1;
    try {
      return e3._strategySizeAlgorithm(t3);
    } catch (t4) {
      return Yt(e3, t4), 1;
    }
  }(o2, t2);
  if (r2 !== e2._ownerWritableStream) return d(Ut("write to"));
  const a2 = r2._state;
  if ("errored" === a2) return d(r2._storedError);
  if (qt(r2) || "closed" === a2) return d(new TypeError("The stream is closing or closed and cannot be written to"));
  if ("erroring" === a2) return d(r2._storedError);
  const i2 = function(e3) {
    return u((t3, r3) => {
      const o3 = { _resolve: t3, _reject: r3 };
      e3._writeRequests.push(o3);
    });
  }(r2);
  return function(e3, t3, r3) {
    try {
      ve(e3, t3, r3);
    } catch (t4) {
      return void Yt(e3, t4);
    }
    const o3 = e3._controlledWritableStream;
    if (!qt(o3) && "writable" === o3._state) {
      Wt(o3, xt(e3));
    }
    Mt(e3);
  }(o2, t2, n2), i2;
}
Object.defineProperties(WritableStreamDefaultWriter.prototype, { abort: { enumerable: true }, close: { enumerable: true }, releaseLock: { enumerable: true }, write: { enumerable: true }, closed: { enumerable: true }, desiredSize: { enumerable: true }, ready: { enumerable: true } }), o(WritableStreamDefaultWriter.prototype.abort, "abort"), o(WritableStreamDefaultWriter.prototype.close, "close"), o(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock"), o(WritableStreamDefaultWriter.prototype.write, "write"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, { value: "WritableStreamDefaultWriter", configurable: true });
var Dt = {};
var WritableStreamDefaultController = class {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get abortReason() {
    if (!Lt(this)) throw Ht("abortReason");
    return this._abortReason;
  }
  get signal() {
    if (!Lt(this)) throw Ht("signal");
    if (void 0 === this._abortController) throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
    return this._abortController.signal;
  }
  error(e2 = void 0) {
    if (!Lt(this)) throw Ht("error");
    "writable" === this._controlledWritableStream._state && Qt(this, e2);
  }
  [w](e2) {
    const t2 = this._abortAlgorithm(e2);
    return It(this), t2;
  }
  [R]() {
    we(this);
  }
};
function Lt(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_controlledWritableStream") && e2 instanceof WritableStreamDefaultController);
}
function Ft(e2, t2, r2, o2, n2, a2, i2, l2) {
  t2._controlledWritableStream = e2, e2._writableStreamController = t2, t2._queue = void 0, t2._queueTotalSize = void 0, we(t2), t2._abortReason = void 0, t2._abortController = function() {
    if ("function" == typeof AbortController) return new AbortController();
  }(), t2._started = false, t2._strategySizeAlgorithm = l2, t2._strategyHWM = i2, t2._writeAlgorithm = o2, t2._closeAlgorithm = n2, t2._abortAlgorithm = a2;
  const s2 = xt(t2);
  Wt(e2, s2);
  b(c(r2()), () => (t2._started = true, Mt(t2), null), (r3) => (t2._started = true, Tt(e2, r3), null));
}
function It(e2) {
  e2._writeAlgorithm = void 0, e2._closeAlgorithm = void 0, e2._abortAlgorithm = void 0, e2._strategySizeAlgorithm = void 0;
}
function $t(e2) {
  return e2._strategyHWM - e2._queueTotalSize;
}
function Mt(e2) {
  const t2 = e2._controlledWritableStream;
  if (!e2._started) return;
  if (void 0 !== t2._inFlightWriteRequest) return;
  if ("erroring" === t2._state) return void Pt(t2);
  if (0 === e2._queue.length) return;
  const r2 = e2._queue.peek().value;
  r2 === Dt ? function(e3) {
    const t3 = e3._controlledWritableStream;
    (function(e4) {
      e4._inFlightCloseRequest = e4._closeRequest, e4._closeRequest = void 0;
    })(t3), ge(e3);
    const r3 = e3._closeAlgorithm();
    It(e3), b(r3, () => (function(e4) {
      e4._inFlightCloseRequest._resolve(void 0), e4._inFlightCloseRequest = void 0, "erroring" === e4._state && (e4._storedError = void 0, void 0 !== e4._pendingAbortRequest && (e4._pendingAbortRequest._resolve(), e4._pendingAbortRequest = void 0)), e4._state = "closed";
      const t4 = e4._writer;
      void 0 !== t4 && Kt(t4);
    }(t3), null), (e4) => (function(e5, t4) {
      e5._inFlightCloseRequest._reject(t4), e5._inFlightCloseRequest = void 0, void 0 !== e5._pendingAbortRequest && (e5._pendingAbortRequest._reject(t4), e5._pendingAbortRequest = void 0), Tt(e5, t4);
    }(t3, e4), null));
  }(e2) : function(e3, t3) {
    const r3 = e3._controlledWritableStream;
    !function(e4) {
      e4._inFlightWriteRequest = e4._writeRequests.shift();
    }(r3);
    const o2 = e3._writeAlgorithm(t3);
    b(o2, () => {
      !function(e4) {
        e4._inFlightWriteRequest._resolve(void 0), e4._inFlightWriteRequest = void 0;
      }(r3);
      const t4 = r3._state;
      if (ge(e3), !qt(r3) && "writable" === t4) {
        const t5 = xt(e3);
        Wt(r3, t5);
      }
      return Mt(e3), null;
    }, (t4) => ("writable" === r3._state && It(e3), function(e4, t5) {
      e4._inFlightWriteRequest._reject(t5), e4._inFlightWriteRequest = void 0, Tt(e4, t5);
    }(r3, t4), null));
  }(e2, r2);
}
function Yt(e2, t2) {
  "writable" === e2._controlledWritableStream._state && Qt(e2, t2);
}
function xt(e2) {
  return $t(e2) <= 0;
}
function Qt(e2, t2) {
  const r2 = e2._controlledWritableStream;
  It(e2), Ct(r2, t2);
}
function Nt(e2) {
  return new TypeError(`WritableStream.prototype.${e2} can only be used on a WritableStream`);
}
function Ht(e2) {
  return new TypeError(`WritableStreamDefaultController.prototype.${e2} can only be used on a WritableStreamDefaultController`);
}
function Vt(e2) {
  return new TypeError(`WritableStreamDefaultWriter.prototype.${e2} can only be used on a WritableStreamDefaultWriter`);
}
function Ut(e2) {
  return new TypeError("Cannot " + e2 + " a stream using a released writer");
}
function Gt(e2) {
  e2._closedPromise = u((t2, r2) => {
    e2._closedPromise_resolve = t2, e2._closedPromise_reject = r2, e2._closedPromiseState = "pending";
  });
}
function Xt(e2, t2) {
  Gt(e2), Jt(e2, t2);
}
function Jt(e2, t2) {
  void 0 !== e2._closedPromise_reject && (p(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0, e2._closedPromiseState = "rejected");
}
function Kt(e2) {
  void 0 !== e2._closedPromise_resolve && (e2._closedPromise_resolve(void 0), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0, e2._closedPromiseState = "resolved");
}
function Zt(e2) {
  e2._readyPromise = u((t2, r2) => {
    e2._readyPromise_resolve = t2, e2._readyPromise_reject = r2;
  }), e2._readyPromiseState = "pending";
}
function er(e2, t2) {
  Zt(e2), rr(e2, t2);
}
function tr(e2) {
  Zt(e2), or(e2);
}
function rr(e2, t2) {
  void 0 !== e2._readyPromise_reject && (p(e2._readyPromise), e2._readyPromise_reject(t2), e2._readyPromise_resolve = void 0, e2._readyPromise_reject = void 0, e2._readyPromiseState = "rejected");
}
function or(e2) {
  void 0 !== e2._readyPromise_resolve && (e2._readyPromise_resolve(void 0), e2._readyPromise_resolve = void 0, e2._readyPromise_reject = void 0, e2._readyPromiseState = "fulfilled");
}
Object.defineProperties(WritableStreamDefaultController.prototype, { abortReason: { enumerable: true }, signal: { enumerable: true }, error: { enumerable: true } }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, { value: "WritableStreamDefaultController", configurable: true });
var nr = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof global ? global : void 0;
var ar = function() {
  const e2 = null == nr ? void 0 : nr.DOMException;
  return function(e3) {
    if ("function" != typeof e3 && "object" != typeof e3) return false;
    if ("DOMException" !== e3.name) return false;
    try {
      return new e3(), true;
    } catch (e4) {
      return false;
    }
  }(e2) ? e2 : void 0;
}() || function() {
  const e2 = function(e3, t2) {
    this.message = e3 || "", this.name = t2 || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
  };
  return o(e2, "DOMException"), e2.prototype = Object.create(Error.prototype), Object.defineProperty(e2.prototype, "constructor", { value: e2, writable: true, configurable: true }), e2;
}();
function ir(t2, r2, o2, n2, a2, i2) {
  const l2 = H(t2), s2 = yt(r2);
  t2._disturbed = true;
  let _2 = false, y2 = c(void 0);
  return u((S2, g2) => {
    let v2;
    if (void 0 !== i2) {
      if (v2 = () => {
        const e2 = void 0 !== i2.reason ? i2.reason : new ar("Aborted", "AbortError"), o3 = [];
        n2 || o3.push(() => "writable" === r2._state ? wt(r2, e2) : c(void 0)), a2 || o3.push(() => "readable" === t2._state ? Or(t2, e2) : c(void 0)), q2(() => Promise.all(o3.map((e3) => e3())), true, e2);
      }, i2.aborted) return void v2();
      i2.addEventListener("abort", v2);
    }
    var w2, R2, T2;
    if (P2(t2, l2._closedPromise, (e2) => (n2 ? E2(true, e2) : q2(() => wt(r2, e2), true, e2), null)), P2(r2, s2._closedPromise, (e2) => (a2 ? E2(true, e2) : q2(() => Or(t2, e2), true, e2), null)), w2 = t2, R2 = l2._closedPromise, T2 = () => (o2 ? E2() : q2(() => function(e2) {
      const t3 = e2._ownerWritableStream, r3 = t3._state;
      return qt(t3) || "closed" === r3 ? c(void 0) : "errored" === r3 ? d(t3._storedError) : Bt(e2);
    }(s2)), null), "closed" === w2._state ? T2() : h(R2, T2), qt(r2) || "closed" === r2._state) {
      const e2 = new TypeError("the destination writable stream closed before all data could be piped to it");
      a2 ? E2(true, e2) : q2(() => Or(t2, e2), true, e2);
    }
    function C2() {
      const e2 = y2;
      return f(y2, () => e2 !== y2 ? C2() : void 0);
    }
    function P2(e2, t3, r3) {
      "errored" === e2._state ? r3(e2._storedError) : m(t3, r3);
    }
    function q2(e2, t3, o3) {
      function n3() {
        return b(e2(), () => O2(t3, o3), (e3) => O2(true, e3)), null;
      }
      _2 || (_2 = true, "writable" !== r2._state || qt(r2) ? n3() : h(C2(), n3));
    }
    function E2(e2, t3) {
      _2 || (_2 = true, "writable" !== r2._state || qt(r2) ? O2(e2, t3) : h(C2(), () => O2(e2, t3)));
    }
    function O2(e2, t3) {
      return At(s2), W(l2), void 0 !== i2 && i2.removeEventListener("abort", v2), e2 ? g2(t3) : S2(void 0), null;
    }
    p(u((t3, r3) => {
      !function o3(n3) {
        n3 ? t3() : f(_2 ? c(true) : f(s2._readyPromise, () => u((t4, r4) => {
          K(l2, { _chunkSteps: (r5) => {
            y2 = f(zt(s2, r5), void 0, e), t4(false);
          }, _closeSteps: () => t4(true), _errorSteps: r4 });
        })), o3, r3);
      }(false);
    }));
  });
}
var ReadableStreamDefaultController = class {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get desiredSize() {
    if (!lr(this)) throw pr("desiredSize");
    return hr(this);
  }
  close() {
    if (!lr(this)) throw pr("close");
    if (!mr(this)) throw new TypeError("The stream is not in a state that permits close");
    dr(this);
  }
  enqueue(e2 = void 0) {
    if (!lr(this)) throw pr("enqueue");
    if (!mr(this)) throw new TypeError("The stream is not in a state that permits enqueue");
    return fr(this, e2);
  }
  error(e2 = void 0) {
    if (!lr(this)) throw pr("error");
    br(this, e2);
  }
  [T](e2) {
    we(this);
    const t2 = this._cancelAlgorithm(e2);
    return cr(this), t2;
  }
  [C](e2) {
    const t2 = this._controlledReadableStream;
    if (this._queue.length > 0) {
      const r2 = ge(this);
      this._closeRequested && 0 === this._queue.length ? (cr(this), Br(t2)) : sr(this), e2._chunkSteps(r2);
    } else V(t2, e2), sr(this);
  }
  [P]() {
  }
};
function lr(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_controlledReadableStream") && e2 instanceof ReadableStreamDefaultController);
}
function sr(e2) {
  if (!ur(e2)) return;
  if (e2._pulling) return void (e2._pullAgain = true);
  e2._pulling = true;
  b(e2._pullAlgorithm(), () => (e2._pulling = false, e2._pullAgain && (e2._pullAgain = false, sr(e2)), null), (t2) => (br(e2, t2), null));
}
function ur(e2) {
  const t2 = e2._controlledReadableStream;
  if (!mr(e2)) return false;
  if (!e2._started) return false;
  if (Wr(t2) && G(t2) > 0) return true;
  return hr(e2) > 0;
}
function cr(e2) {
  e2._pullAlgorithm = void 0, e2._cancelAlgorithm = void 0, e2._strategySizeAlgorithm = void 0;
}
function dr(e2) {
  if (!mr(e2)) return;
  const t2 = e2._controlledReadableStream;
  e2._closeRequested = true, 0 === e2._queue.length && (cr(e2), Br(t2));
}
function fr(e2, t2) {
  if (!mr(e2)) return;
  const r2 = e2._controlledReadableStream;
  if (Wr(r2) && G(r2) > 0) U(r2, t2, false);
  else {
    let r3;
    try {
      r3 = e2._strategySizeAlgorithm(t2);
    } catch (t3) {
      throw br(e2, t3), t3;
    }
    try {
      ve(e2, t2, r3);
    } catch (t3) {
      throw br(e2, t3), t3;
    }
  }
  sr(e2);
}
function br(e2, t2) {
  const r2 = e2._controlledReadableStream;
  "readable" === r2._state && (we(e2), cr(e2), kr(r2, t2));
}
function hr(e2) {
  const t2 = e2._controlledReadableStream._state;
  return "errored" === t2 ? null : "closed" === t2 ? 0 : e2._strategyHWM - e2._queueTotalSize;
}
function mr(e2) {
  const t2 = e2._controlledReadableStream._state;
  return !e2._closeRequested && "readable" === t2;
}
function _r(e2, t2, r2, o2, n2, a2, i2) {
  t2._controlledReadableStream = e2, t2._queue = void 0, t2._queueTotalSize = void 0, we(t2), t2._started = false, t2._closeRequested = false, t2._pullAgain = false, t2._pulling = false, t2._strategySizeAlgorithm = i2, t2._strategyHWM = a2, t2._pullAlgorithm = o2, t2._cancelAlgorithm = n2, e2._readableStreamController = t2;
  b(c(r2()), () => (t2._started = true, sr(t2), null), (e3) => (br(t2, e3), null));
}
function pr(e2) {
  return new TypeError(`ReadableStreamDefaultController.prototype.${e2} can only be used on a ReadableStreamDefaultController`);
}
function yr(e2, t2) {
  return Te(e2._readableStreamController) ? function(e3) {
    let t3, r2, o2, n2, a2, i2 = H(e3), l2 = false, s2 = false, d2 = false, f2 = false, b2 = false;
    const h2 = u((e4) => {
      a2 = e4;
    });
    function _2(e4) {
      m(e4._closedPromise, (t4) => (e4 !== i2 || (Ne(o2._readableStreamController, t4), Ne(n2._readableStreamController, t4), f2 && b2 || a2(void 0)), null));
    }
    function p2() {
      at(i2) && (W(i2), i2 = H(e3), _2(i2));
      K(i2, { _chunkSteps: (t4) => {
        y(() => {
          s2 = false, d2 = false;
          const r3 = t4;
          let i3 = t4;
          if (!f2 && !b2) try {
            i3 = Se(t4);
          } catch (t5) {
            return Ne(o2._readableStreamController, t5), Ne(n2._readableStreamController, t5), void a2(Or(e3, t5));
          }
          f2 || Qe(o2._readableStreamController, r3), b2 || Qe(n2._readableStreamController, i3), l2 = false, s2 ? g2() : d2 && v2();
        });
      }, _closeSteps: () => {
        l2 = false, f2 || xe(o2._readableStreamController), b2 || xe(n2._readableStreamController), o2._readableStreamController._pendingPullIntos.length > 0 && Ge(o2._readableStreamController, 0), n2._readableStreamController._pendingPullIntos.length > 0 && Ge(n2._readableStreamController, 0), f2 && b2 || a2(void 0);
      }, _errorSteps: () => {
        l2 = false;
      } });
    }
    function S2(t4, r3) {
      J(i2) && (W(i2), i2 = tt(e3), _2(i2));
      const u2 = r3 ? n2 : o2, c2 = r3 ? o2 : n2;
      it(i2, t4, 1, { _chunkSteps: (t5) => {
        y(() => {
          s2 = false, d2 = false;
          const o3 = r3 ? b2 : f2;
          if (r3 ? f2 : b2) o3 || Xe(u2._readableStreamController, t5);
          else {
            let r4;
            try {
              r4 = Se(t5);
            } catch (t6) {
              return Ne(u2._readableStreamController, t6), Ne(c2._readableStreamController, t6), void a2(Or(e3, t6));
            }
            o3 || Xe(u2._readableStreamController, t5), Qe(c2._readableStreamController, r4);
          }
          l2 = false, s2 ? g2() : d2 && v2();
        });
      }, _closeSteps: (e4) => {
        l2 = false;
        const t5 = r3 ? b2 : f2, o3 = r3 ? f2 : b2;
        t5 || xe(u2._readableStreamController), o3 || xe(c2._readableStreamController), void 0 !== e4 && (t5 || Xe(u2._readableStreamController, e4), !o3 && c2._readableStreamController._pendingPullIntos.length > 0 && Ge(c2._readableStreamController, 0)), t5 && o3 || a2(void 0);
      }, _errorSteps: () => {
        l2 = false;
      } });
    }
    function g2() {
      if (l2) return s2 = true, c(void 0);
      l2 = true;
      const e4 = Ve(o2._readableStreamController);
      return null === e4 ? p2() : S2(e4._view, false), c(void 0);
    }
    function v2() {
      if (l2) return d2 = true, c(void 0);
      l2 = true;
      const e4 = Ve(n2._readableStreamController);
      return null === e4 ? p2() : S2(e4._view, true), c(void 0);
    }
    function w2(o3) {
      if (f2 = true, t3 = o3, b2) {
        const o4 = ne([t3, r2]), n3 = Or(e3, o4);
        a2(n3);
      }
      return h2;
    }
    function R2(o3) {
      if (b2 = true, r2 = o3, f2) {
        const o4 = ne([t3, r2]), n3 = Or(e3, o4);
        a2(n3);
      }
      return h2;
    }
    function T2() {
    }
    return o2 = Pr(T2, g2, w2), n2 = Pr(T2, v2, R2), _2(i2), [o2, n2];
  }(e2) : function(e3) {
    const t3 = H(e3);
    let r2, o2, n2, a2, i2, l2 = false, s2 = false, d2 = false, f2 = false;
    const b2 = u((e4) => {
      i2 = e4;
    });
    function h2() {
      if (l2) return s2 = true, c(void 0);
      l2 = true;
      return K(t3, { _chunkSteps: (e4) => {
        y(() => {
          s2 = false;
          const t4 = e4, r3 = e4;
          d2 || fr(n2._readableStreamController, t4), f2 || fr(a2._readableStreamController, r3), l2 = false, s2 && h2();
        });
      }, _closeSteps: () => {
        l2 = false, d2 || dr(n2._readableStreamController), f2 || dr(a2._readableStreamController), d2 && f2 || i2(void 0);
      }, _errorSteps: () => {
        l2 = false;
      } }), c(void 0);
    }
    function _2(t4) {
      if (d2 = true, r2 = t4, f2) {
        const t5 = ne([r2, o2]), n3 = Or(e3, t5);
        i2(n3);
      }
      return b2;
    }
    function p2(t4) {
      if (f2 = true, o2 = t4, d2) {
        const t5 = ne([r2, o2]), n3 = Or(e3, t5);
        i2(n3);
      }
      return b2;
    }
    function S2() {
    }
    return n2 = Cr(S2, h2, _2), a2 = Cr(S2, h2, p2), m(t3._closedPromise, (e4) => (br(n2._readableStreamController, e4), br(a2._readableStreamController, e4), d2 && f2 || i2(void 0), null)), [n2, a2];
  }(e2);
}
function Sr(r2) {
  return t(o2 = r2) && void 0 !== o2.getReader ? function(r3) {
    let o3;
    function n2() {
      let e2;
      try {
        e2 = r3.read();
      } catch (e3) {
        return d(e3);
      }
      return _(e2, (e3) => {
        if (!t(e3)) throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
        if (e3.done) dr(o3._readableStreamController);
        else {
          const t2 = e3.value;
          fr(o3._readableStreamController, t2);
        }
      });
    }
    function a2(e2) {
      try {
        return c(r3.cancel(e2));
      } catch (e3) {
        return d(e3);
      }
    }
    return o3 = Cr(e, n2, a2, 0), o3;
  }(r2.getReader()) : function(r3) {
    let o3;
    const n2 = fe(r3, "async");
    function a2() {
      let e2;
      try {
        e2 = be(n2);
      } catch (e3) {
        return d(e3);
      }
      return _(c(e2), (e3) => {
        if (!t(e3)) throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
        if (e3.done) dr(o3._readableStreamController);
        else {
          const t2 = e3.value;
          fr(o3._readableStreamController, t2);
        }
      });
    }
    function i2(e2) {
      const r4 = n2.iterator;
      let o4;
      try {
        o4 = ue(r4, "return");
      } catch (e3) {
        return d(e3);
      }
      if (void 0 === o4) return c(void 0);
      return _(g(o4, r4, [e2]), (e3) => {
        if (!t(e3)) throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
      });
    }
    return o3 = Cr(e, a2, i2, 0), o3;
  }(r2);
  var o2;
}
function gr(e2, t2, r2) {
  return F(e2, r2), (r3) => g(e2, t2, [r3]);
}
function vr(e2, t2, r2) {
  return F(e2, r2), (r3) => g(e2, t2, [r3]);
}
function wr(e2, t2, r2) {
  return F(e2, r2), (r3) => S(e2, t2, [r3]);
}
function Rr(e2, t2) {
  if ("bytes" !== (e2 = `${e2}`)) throw new TypeError(`${t2} '${e2}' is not a valid enumeration value for ReadableStreamType`);
  return e2;
}
function Tr(e2, t2) {
  L(e2, t2);
  const r2 = null == e2 ? void 0 : e2.preventAbort, o2 = null == e2 ? void 0 : e2.preventCancel, n2 = null == e2 ? void 0 : e2.preventClose, a2 = null == e2 ? void 0 : e2.signal;
  return void 0 !== a2 && function(e3, t3) {
    if (!function(e4) {
      if ("object" != typeof e4 || null === e4) return false;
      try {
        return "boolean" == typeof e4.aborted;
      } catch (e5) {
        return false;
      }
    }(e3)) throw new TypeError(`${t3} is not an AbortSignal.`);
  }(a2, `${t2} has member 'signal' that`), { preventAbort: Boolean(r2), preventCancel: Boolean(o2), preventClose: Boolean(n2), signal: a2 };
}
Object.defineProperties(ReadableStreamDefaultController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, desiredSize: { enumerable: true } }), o(ReadableStreamDefaultController.prototype.close, "close"), o(ReadableStreamDefaultController.prototype.enqueue, "enqueue"), o(ReadableStreamDefaultController.prototype.error, "error"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, { value: "ReadableStreamDefaultController", configurable: true });
var ReadableStream = class {
  constructor(e2 = {}, t2 = {}) {
    void 0 === e2 ? e2 = null : I(e2, "First parameter");
    const r2 = dt(t2, "Second parameter"), o2 = function(e3, t3) {
      L(e3, t3);
      const r3 = e3, o3 = null == r3 ? void 0 : r3.autoAllocateChunkSize, n2 = null == r3 ? void 0 : r3.cancel, a2 = null == r3 ? void 0 : r3.pull, i2 = null == r3 ? void 0 : r3.start, l2 = null == r3 ? void 0 : r3.type;
      return { autoAllocateChunkSize: void 0 === o3 ? void 0 : Q(o3, `${t3} has member 'autoAllocateChunkSize' that`), cancel: void 0 === n2 ? void 0 : gr(n2, r3, `${t3} has member 'cancel' that`), pull: void 0 === a2 ? void 0 : vr(a2, r3, `${t3} has member 'pull' that`), start: void 0 === i2 ? void 0 : wr(i2, r3, `${t3} has member 'start' that`), type: void 0 === l2 ? void 0 : Rr(l2, `${t3} has member 'type' that`) };
    }(e2, "First parameter");
    if (qr(this), "bytes" === o2.type) {
      if (void 0 !== r2.size) throw new RangeError("The strategy for a byte stream cannot have a size function");
      !function(e3, t3, r3) {
        const o3 = Object.create(ReadableByteStreamController.prototype);
        let n2, a2, i2;
        n2 = void 0 !== t3.start ? () => t3.start(o3) : () => {
        }, a2 = void 0 !== t3.pull ? () => t3.pull(o3) : () => c(void 0), i2 = void 0 !== t3.cancel ? (e4) => t3.cancel(e4) : () => c(void 0);
        const l2 = t3.autoAllocateChunkSize;
        if (0 === l2) throw new TypeError("autoAllocateChunkSize must be greater than 0");
        Je(e3, o3, n2, a2, i2, r3, l2);
      }(this, o2, ut(r2, 0));
    } else {
      const e3 = ct(r2);
      !function(e4, t3, r3, o3) {
        const n2 = Object.create(ReadableStreamDefaultController.prototype);
        let a2, i2, l2;
        a2 = void 0 !== t3.start ? () => t3.start(n2) : () => {
        }, i2 = void 0 !== t3.pull ? () => t3.pull(n2) : () => c(void 0), l2 = void 0 !== t3.cancel ? (e5) => t3.cancel(e5) : () => c(void 0), _r(e4, n2, a2, i2, l2, r3, o3);
      }(this, o2, ut(r2, 1), e3);
    }
  }
  get locked() {
    if (!Er(this)) throw jr("locked");
    return Wr(this);
  }
  cancel(e2 = void 0) {
    return Er(this) ? Wr(this) ? d(new TypeError("Cannot cancel a stream that already has a reader")) : Or(this, e2) : d(jr("cancel"));
  }
  getReader(e2 = void 0) {
    if (!Er(this)) throw jr("getReader");
    return void 0 === function(e3, t2) {
      L(e3, t2);
      const r2 = null == e3 ? void 0 : e3.mode;
      return { mode: void 0 === r2 ? void 0 : et(r2, `${t2} has member 'mode' that`) };
    }(e2, "First parameter").mode ? H(this) : tt(this);
  }
  pipeThrough(e2, t2 = {}) {
    if (!Er(this)) throw jr("pipeThrough");
    $(e2, 1, "pipeThrough");
    const r2 = function(e3, t3) {
      L(e3, t3);
      const r3 = null == e3 ? void 0 : e3.readable;
      M(r3, "readable", "ReadableWritablePair"), N(r3, `${t3} has member 'readable' that`);
      const o3 = null == e3 ? void 0 : e3.writable;
      return M(o3, "writable", "ReadableWritablePair"), pt(o3, `${t3} has member 'writable' that`), { readable: r3, writable: o3 };
    }(e2, "First parameter"), o2 = Tr(t2, "Second parameter");
    if (Wr(this)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
    if (vt(r2.writable)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
    return p(ir(this, r2.writable, o2.preventClose, o2.preventAbort, o2.preventCancel, o2.signal)), r2.readable;
  }
  pipeTo(e2, t2 = {}) {
    if (!Er(this)) return d(jr("pipeTo"));
    if (void 0 === e2) return d("Parameter 1 is required in 'pipeTo'.");
    if (!gt(e2)) return d(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
    let r2;
    try {
      r2 = Tr(t2, "Second parameter");
    } catch (e3) {
      return d(e3);
    }
    return Wr(this) ? d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : vt(e2) ? d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : ir(this, e2, r2.preventClose, r2.preventAbort, r2.preventCancel, r2.signal);
  }
  tee() {
    if (!Er(this)) throw jr("tee");
    return ne(yr(this));
  }
  values(e2 = void 0) {
    if (!Er(this)) throw jr("values");
    return function(e3, t2) {
      const r2 = H(e3), o2 = new he(r2, t2), n2 = Object.create(me);
      return n2._asyncIteratorImpl = o2, n2;
    }(this, function(e3, t2) {
      L(e3, t2);
      const r2 = null == e3 ? void 0 : e3.preventCancel;
      return { preventCancel: Boolean(r2) };
    }(e2, "First parameter").preventCancel);
  }
  [de](e2) {
    return this.values(e2);
  }
  static from(e2) {
    return Sr(e2);
  }
};
function Cr(e2, t2, r2, o2 = 1, n2 = () => 1) {
  const a2 = Object.create(ReadableStream.prototype);
  qr(a2);
  return _r(a2, Object.create(ReadableStreamDefaultController.prototype), e2, t2, r2, o2, n2), a2;
}
function Pr(e2, t2, r2) {
  const o2 = Object.create(ReadableStream.prototype);
  qr(o2);
  return Je(o2, Object.create(ReadableByteStreamController.prototype), e2, t2, r2, 0, void 0), o2;
}
function qr(e2) {
  e2._state = "readable", e2._reader = void 0, e2._storedError = void 0, e2._disturbed = false;
}
function Er(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_readableStreamController") && e2 instanceof ReadableStream);
}
function Wr(e2) {
  return void 0 !== e2._reader;
}
function Or(t2, r2) {
  if (t2._disturbed = true, "closed" === t2._state) return c(void 0);
  if ("errored" === t2._state) return d(t2._storedError);
  Br(t2);
  const o2 = t2._reader;
  if (void 0 !== o2 && at(o2)) {
    const e2 = o2._readIntoRequests;
    o2._readIntoRequests = new v(), e2.forEach((e3) => {
      e3._closeSteps(void 0);
    });
  }
  return _(t2._readableStreamController[T](r2), e);
}
function Br(e2) {
  e2._state = "closed";
  const t2 = e2._reader;
  if (void 0 !== t2 && (A(t2), J(t2))) {
    const e3 = t2._readRequests;
    t2._readRequests = new v(), e3.forEach((e4) => {
      e4._closeSteps();
    });
  }
}
function kr(e2, t2) {
  e2._state = "errored", e2._storedError = t2;
  const r2 = e2._reader;
  void 0 !== r2 && (j(r2, t2), J(r2) ? Z(r2, t2) : lt(r2, t2));
}
function jr(e2) {
  return new TypeError(`ReadableStream.prototype.${e2} can only be used on a ReadableStream`);
}
function Ar(e2, t2) {
  L(e2, t2);
  const r2 = null == e2 ? void 0 : e2.highWaterMark;
  return M(r2, "highWaterMark", "QueuingStrategyInit"), { highWaterMark: Y(r2) };
}
Object.defineProperties(ReadableStream, { from: { enumerable: true } }), Object.defineProperties(ReadableStream.prototype, { cancel: { enumerable: true }, getReader: { enumerable: true }, pipeThrough: { enumerable: true }, pipeTo: { enumerable: true }, tee: { enumerable: true }, values: { enumerable: true }, locked: { enumerable: true } }), o(ReadableStream.from, "from"), o(ReadableStream.prototype.cancel, "cancel"), o(ReadableStream.prototype.getReader, "getReader"), o(ReadableStream.prototype.pipeThrough, "pipeThrough"), o(ReadableStream.prototype.pipeTo, "pipeTo"), o(ReadableStream.prototype.tee, "tee"), o(ReadableStream.prototype.values, "values"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, { value: "ReadableStream", configurable: true }), Object.defineProperty(ReadableStream.prototype, de, { value: ReadableStream.prototype.values, writable: true, configurable: true });
var zr = (e2) => e2.byteLength;
o(zr, "size");
var ByteLengthQueuingStrategy = class {
  constructor(e2) {
    $(e2, 1, "ByteLengthQueuingStrategy"), e2 = Ar(e2, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = e2.highWaterMark;
  }
  get highWaterMark() {
    if (!Lr(this)) throw Dr("highWaterMark");
    return this._byteLengthQueuingStrategyHighWaterMark;
  }
  get size() {
    if (!Lr(this)) throw Dr("size");
    return zr;
  }
};
function Dr(e2) {
  return new TypeError(`ByteLengthQueuingStrategy.prototype.${e2} can only be used on a ByteLengthQueuingStrategy`);
}
function Lr(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_byteLengthQueuingStrategyHighWaterMark") && e2 instanceof ByteLengthQueuingStrategy);
}
Object.defineProperties(ByteLengthQueuingStrategy.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, { value: "ByteLengthQueuingStrategy", configurable: true });
var Fr = () => 1;
o(Fr, "size");
var CountQueuingStrategy = class {
  constructor(e2) {
    $(e2, 1, "CountQueuingStrategy"), e2 = Ar(e2, "First parameter"), this._countQueuingStrategyHighWaterMark = e2.highWaterMark;
  }
  get highWaterMark() {
    if (!$r(this)) throw Ir("highWaterMark");
    return this._countQueuingStrategyHighWaterMark;
  }
  get size() {
    if (!$r(this)) throw Ir("size");
    return Fr;
  }
};
function Ir(e2) {
  return new TypeError(`CountQueuingStrategy.prototype.${e2} can only be used on a CountQueuingStrategy`);
}
function $r(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_countQueuingStrategyHighWaterMark") && e2 instanceof CountQueuingStrategy);
}
function Mr(e2, t2, r2) {
  return F(e2, r2), (r3) => g(e2, t2, [r3]);
}
function Yr(e2, t2, r2) {
  return F(e2, r2), (r3) => S(e2, t2, [r3]);
}
function xr(e2, t2, r2) {
  return F(e2, r2), (r3, o2) => g(e2, t2, [r3, o2]);
}
function Qr(e2, t2, r2) {
  return F(e2, r2), (r3) => g(e2, t2, [r3]);
}
Object.defineProperties(CountQueuingStrategy.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, { value: "CountQueuingStrategy", configurable: true });
var TransformStream = class {
  constructor(e2 = {}, t2 = {}, r2 = {}) {
    void 0 === e2 && (e2 = null);
    const o2 = dt(t2, "Second parameter"), n2 = dt(r2, "Third parameter"), a2 = function(e3, t3) {
      L(e3, t3);
      const r3 = null == e3 ? void 0 : e3.cancel, o3 = null == e3 ? void 0 : e3.flush, n3 = null == e3 ? void 0 : e3.readableType, a3 = null == e3 ? void 0 : e3.start, i3 = null == e3 ? void 0 : e3.transform, l3 = null == e3 ? void 0 : e3.writableType;
      return { cancel: void 0 === r3 ? void 0 : Qr(r3, e3, `${t3} has member 'cancel' that`), flush: void 0 === o3 ? void 0 : Mr(o3, e3, `${t3} has member 'flush' that`), readableType: n3, start: void 0 === a3 ? void 0 : Yr(a3, e3, `${t3} has member 'start' that`), transform: void 0 === i3 ? void 0 : xr(i3, e3, `${t3} has member 'transform' that`), writableType: l3 };
    }(e2, "First parameter");
    if (void 0 !== a2.readableType) throw new RangeError("Invalid readableType specified");
    if (void 0 !== a2.writableType) throw new RangeError("Invalid writableType specified");
    const i2 = ut(n2, 0), l2 = ct(n2), s2 = ut(o2, 1), f2 = ct(o2);
    let h2;
    !function(e3, t3, r3, o3, n3, a3) {
      function i3() {
        return t3;
      }
      function l3(t4) {
        return function(e4, t5) {
          const r4 = e4._transformStreamController;
          if (e4._backpressure) {
            return _(e4._backpressureChangePromise, () => {
              const o4 = e4._writable;
              if ("erroring" === o4._state) throw o4._storedError;
              return Zr(r4, t5);
            });
          }
          return Zr(r4, t5);
        }(e3, t4);
      }
      function s3(t4) {
        return function(e4, t5) {
          const r4 = e4._transformStreamController;
          if (void 0 !== r4._finishPromise) return r4._finishPromise;
          const o4 = e4._readable;
          r4._finishPromise = u((e5, t6) => {
            r4._finishPromise_resolve = e5, r4._finishPromise_reject = t6;
          });
          const n4 = r4._cancelAlgorithm(t5);
          return Jr(r4), b(n4, () => ("errored" === o4._state ? ro(r4, o4._storedError) : (br(o4._readableStreamController, t5), to(r4)), null), (e5) => (br(o4._readableStreamController, e5), ro(r4, e5), null)), r4._finishPromise;
        }(e3, t4);
      }
      function c2() {
        return function(e4) {
          const t4 = e4._transformStreamController;
          if (void 0 !== t4._finishPromise) return t4._finishPromise;
          const r4 = e4._readable;
          t4._finishPromise = u((e5, r5) => {
            t4._finishPromise_resolve = e5, t4._finishPromise_reject = r5;
          });
          const o4 = t4._flushAlgorithm();
          return Jr(t4), b(o4, () => ("errored" === r4._state ? ro(t4, r4._storedError) : (dr(r4._readableStreamController), to(t4)), null), (e5) => (br(r4._readableStreamController, e5), ro(t4, e5), null)), t4._finishPromise;
        }(e3);
      }
      function d2() {
        return function(e4) {
          return Gr(e4, false), e4._backpressureChangePromise;
        }(e3);
      }
      function f3(t4) {
        return function(e4, t5) {
          const r4 = e4._transformStreamController;
          if (void 0 !== r4._finishPromise) return r4._finishPromise;
          const o4 = e4._writable;
          r4._finishPromise = u((e5, t6) => {
            r4._finishPromise_resolve = e5, r4._finishPromise_reject = t6;
          });
          const n4 = r4._cancelAlgorithm(t5);
          return Jr(r4), b(n4, () => ("errored" === o4._state ? ro(r4, o4._storedError) : (Yt(o4._writableStreamController, t5), Ur(e4), to(r4)), null), (t6) => (Yt(o4._writableStreamController, t6), Ur(e4), ro(r4, t6), null)), r4._finishPromise;
        }(e3, t4);
      }
      e3._writable = function(e4, t4, r4, o4, n4 = 1, a4 = () => 1) {
        const i4 = Object.create(WritableStream.prototype);
        return St(i4), Ft(i4, Object.create(WritableStreamDefaultController.prototype), e4, t4, r4, o4, n4, a4), i4;
      }(i3, l3, c2, s3, r3, o3), e3._readable = Cr(i3, d2, f3, n3, a3), e3._backpressure = void 0, e3._backpressureChangePromise = void 0, e3._backpressureChangePromise_resolve = void 0, Gr(e3, true), e3._transformStreamController = void 0;
    }(this, u((e3) => {
      h2 = e3;
    }), s2, f2, i2, l2), function(e3, t3) {
      const r3 = Object.create(TransformStreamDefaultController.prototype);
      let o3, n3, a3;
      o3 = void 0 !== t3.transform ? (e4) => t3.transform(e4, r3) : (e4) => {
        try {
          return Kr(r3, e4), c(void 0);
        } catch (e5) {
          return d(e5);
        }
      };
      n3 = void 0 !== t3.flush ? () => t3.flush(r3) : () => c(void 0);
      a3 = void 0 !== t3.cancel ? (e4) => t3.cancel(e4) : () => c(void 0);
      !function(e4, t4, r4, o4, n4) {
        t4._controlledTransformStream = e4, e4._transformStreamController = t4, t4._transformAlgorithm = r4, t4._flushAlgorithm = o4, t4._cancelAlgorithm = n4, t4._finishPromise = void 0, t4._finishPromise_resolve = void 0, t4._finishPromise_reject = void 0;
      }(e3, r3, o3, n3, a3);
    }(this, a2), void 0 !== a2.start ? h2(a2.start(this._transformStreamController)) : h2(void 0);
  }
  get readable() {
    if (!Nr(this)) throw oo("readable");
    return this._readable;
  }
  get writable() {
    if (!Nr(this)) throw oo("writable");
    return this._writable;
  }
};
function Nr(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_transformStreamController") && e2 instanceof TransformStream);
}
function Hr(e2, t2) {
  br(e2._readable._readableStreamController, t2), Vr(e2, t2);
}
function Vr(e2, t2) {
  Jr(e2._transformStreamController), Yt(e2._writable._writableStreamController, t2), Ur(e2);
}
function Ur(e2) {
  e2._backpressure && Gr(e2, false);
}
function Gr(e2, t2) {
  void 0 !== e2._backpressureChangePromise && e2._backpressureChangePromise_resolve(), e2._backpressureChangePromise = u((t3) => {
    e2._backpressureChangePromise_resolve = t3;
  }), e2._backpressure = t2;
}
Object.defineProperties(TransformStream.prototype, { readable: { enumerable: true }, writable: { enumerable: true } }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, { value: "TransformStream", configurable: true });
var TransformStreamDefaultController = class {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get desiredSize() {
    if (!Xr(this)) throw eo("desiredSize");
    return hr(this._controlledTransformStream._readable._readableStreamController);
  }
  enqueue(e2 = void 0) {
    if (!Xr(this)) throw eo("enqueue");
    Kr(this, e2);
  }
  error(e2 = void 0) {
    if (!Xr(this)) throw eo("error");
    var t2;
    t2 = e2, Hr(this._controlledTransformStream, t2);
  }
  terminate() {
    if (!Xr(this)) throw eo("terminate");
    !function(e2) {
      const t2 = e2._controlledTransformStream;
      dr(t2._readable._readableStreamController);
      const r2 = new TypeError("TransformStream terminated");
      Vr(t2, r2);
    }(this);
  }
};
function Xr(e2) {
  return !!t(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_controlledTransformStream") && e2 instanceof TransformStreamDefaultController);
}
function Jr(e2) {
  e2._transformAlgorithm = void 0, e2._flushAlgorithm = void 0, e2._cancelAlgorithm = void 0;
}
function Kr(e2, t2) {
  const r2 = e2._controlledTransformStream, o2 = r2._readable._readableStreamController;
  if (!mr(o2)) throw new TypeError("Readable side is not in a state that permits enqueue");
  try {
    fr(o2, t2);
  } catch (e3) {
    throw Vr(r2, e3), r2._readable._storedError;
  }
  const n2 = function(e3) {
    return !ur(e3);
  }(o2);
  n2 !== r2._backpressure && Gr(r2, true);
}
function Zr(e2, t2) {
  return _(e2._transformAlgorithm(t2), void 0, (t3) => {
    throw Hr(e2._controlledTransformStream, t3), t3;
  });
}
function eo(e2) {
  return new TypeError(`TransformStreamDefaultController.prototype.${e2} can only be used on a TransformStreamDefaultController`);
}
function to(e2) {
  void 0 !== e2._finishPromise_resolve && (e2._finishPromise_resolve(), e2._finishPromise_resolve = void 0, e2._finishPromise_reject = void 0);
}
function ro(e2, t2) {
  void 0 !== e2._finishPromise_reject && (p(e2._finishPromise), e2._finishPromise_reject(t2), e2._finishPromise_resolve = void 0, e2._finishPromise_reject = void 0);
}
function oo(e2) {
  return new TypeError(`TransformStream.prototype.${e2} can only be used on a TransformStream`);
}
Object.defineProperties(TransformStreamDefaultController.prototype, { enqueue: { enumerable: true }, error: { enumerable: true }, terminate: { enumerable: true }, desiredSize: { enumerable: true } }), o(TransformStreamDefaultController.prototype.enqueue, "enqueue"), o(TransformStreamDefaultController.prototype.error, "error"), o(TransformStreamDefaultController.prototype.terminate, "terminate"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, { value: "TransformStreamDefaultController", configurable: true });

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/stream-extra/esm/stream.js
var GLOBAL = globalThis;
var AbortController2 = GLOBAL.AbortController;
var ReadableStream2 = ReadableStream;
var WritableStream2 = WritableStream;
var TransformStream2 = TransformStream;
if (GLOBAL.ReadableStream && GLOBAL.WritableStream && GLOBAL.TransformStream) {
  ReadableStream2 = GLOBAL.ReadableStream;
  WritableStream2 = GLOBAL.WritableStream;
  TransformStream2 = GLOBAL.TransformStream;
} else {
}

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/stream-extra/esm/consumable.js
var { console } = globalThis;
var _a;
var createTask = ((_a = console.createTask) == null ? void 0 : _a.bind(console)) ?? (() => ({
  run(callback) {
    return callback();
  }
}));
var Consumable = class {
  constructor(value) {
    __publicField(this, "task");
    __publicField(this, "resolver");
    __publicField(this, "value");
    __publicField(this, "consumed");
    this.task = createTask("Consumable");
    this.value = value;
    this.resolver = new PromiseResolver();
    this.consumed = this.resolver.promise;
  }
  consume() {
    this.resolver.resolve();
  }
  error(error) {
    this.resolver.reject(error);
  }
  async tryConsume(callback) {
    try {
      const result = await this.task.run(() => callback(this.value));
      this.consume();
      return result;
    } catch (e2) {
      this.resolver.reject(e2);
      throw e2;
    }
  }
};
async function enqueue(controller, chunk) {
  const output = new Consumable(chunk);
  controller.enqueue(output);
  await output.consumed;
}
var ConsumableWritableStream = class extends WritableStream2 {
  static async write(writer, value) {
    const consumable = new Consumable(value);
    await writer.write(consumable);
    await consumable.consumed;
  }
  constructor(sink, strategy) {
    let wrappedStrategy;
    if (strategy) {
      wrappedStrategy = {};
      if ("highWaterMark" in strategy) {
        wrappedStrategy.highWaterMark = strategy.highWaterMark;
      }
      if ("size" in strategy) {
        wrappedStrategy.size = (chunk) => {
          return strategy.size(chunk.value);
        };
      }
    }
    super({
      start() {
        var _a2;
        return (_a2 = sink.start) == null ? void 0 : _a2.call(sink);
      },
      async write(chunk) {
        await chunk.tryConsume((value) => {
          var _a2;
          return (_a2 = sink.write) == null ? void 0 : _a2.call(sink, value);
        });
        chunk.consume();
      },
      abort(reason) {
        var _a2;
        return (_a2 = sink.abort) == null ? void 0 : _a2.call(sink, reason);
      },
      close() {
        var _a2;
        return (_a2 = sink.close) == null ? void 0 : _a2.call(sink);
      }
    }, wrappedStrategy);
  }
};
var ConsumableTransformStream = class extends TransformStream2 {
  constructor(transformer) {
    let wrappedController;
    super({
      async start(controller) {
        var _a2;
        wrappedController = {
          async enqueue(chunk) {
            await enqueue(controller, chunk);
          },
          close() {
            controller.terminate();
          },
          error(reason) {
            controller.error(reason);
          }
        };
        await ((_a2 = transformer.start) == null ? void 0 : _a2.call(transformer, wrappedController));
      },
      async transform(chunk) {
        await chunk.tryConsume((value) => {
          var _a2;
          return (_a2 = transformer.transform) == null ? void 0 : _a2.call(transformer, value, wrappedController);
        });
        chunk.consume();
      },
      async flush() {
        var _a2;
        await ((_a2 = transformer.flush) == null ? void 0 : _a2.call(transformer, wrappedController));
      }
    });
  }
};

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/struct/esm/basic/definition.js
var StructFieldDefinition = class {
  constructor(options) {
    /**
     * When `T` is a type initiated `StructFieldDefinition`,
     * use `T['TValue']` to retrieve its `TValue` type parameter.
     */
    __publicField(this, "TValue");
    /**
     * When `T` is a type initiated `StructFieldDefinition`,
     * use `T['TOmitInitKey']` to retrieve its `TOmitInitKey` type parameter.
     */
    __publicField(this, "TOmitInitKey");
    __publicField(this, "options");
    this.options = options;
  }
};

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/struct/esm/basic/field-value.js
var StructFieldValue = class _StructFieldValue {
  constructor(definition, options, struct, value) {
    /** Gets the definition associated with this runtime value */
    __publicField(this, "definition");
    /** Gets the options of the associated `Struct` */
    __publicField(this, "options");
    /** Gets the associated `Struct` instance */
    __publicField(this, "struct");
    __publicField(this, "value");
    this.definition = definition;
    this.options = options;
    this.struct = struct;
    this.value = value;
  }
  get hasCustomAccessors() {
    return this.get !== _StructFieldValue.prototype.get || this.set !== _StructFieldValue.prototype.set;
  }
  /**
   * Gets size of this field. By default, it returns its `definition`'s size.
   *
   * When overridden in derived classes, can have custom logic to calculate the actual size.
   */
  getSize() {
    return this.definition.getSize();
  }
  /**
   * When implemented in derived classes, reads current field's value.
   */
  get() {
    return this.value;
  }
  /**
   * When implemented in derived classes, updates current field's value.
   */
  set(value) {
    this.value = value;
  }
};

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/struct/esm/basic/options.js
var StructDefaultOptions = {
  littleEndian: false
};

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/struct/esm/basic/struct-value.js
var STRUCT_VALUE_SYMBOL = Symbol("struct-value");
var StructValue = class {
  constructor(prototype) {
    /** @internal */
    __publicField(this, "fieldValues", {});
    /**
     * Gets the result struct value object
     */
    __publicField(this, "value");
    this.value = Object.create(prototype);
    Object.defineProperty(this.value, STRUCT_VALUE_SYMBOL, {
      enumerable: false,
      value: this
    });
  }
  /**
   * Sets a `StructFieldValue` for `key`
   *
   * @param name The field name
   * @param fieldValue The associated `StructFieldValue`
   */
  set(name, fieldValue) {
    this.fieldValues[name] = fieldValue;
    if (fieldValue.hasCustomAccessors) {
      Object.defineProperty(this.value, name, {
        configurable: true,
        enumerable: true,
        get() {
          return fieldValue.get();
        },
        set(v2) {
          fieldValue.set(v2);
        }
      });
    } else {
      this.value[name] = fieldValue.get();
    }
  }
  /**
   * Gets the `StructFieldValue` for `key`
   *
   * @param name The field name
   */
  get(name) {
    return this.fieldValues[name];
  }
};

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/struct/esm/sync-promise.js
var SyncPromise = {
  reject(reason) {
    return new RejectedSyncPromise(reason);
  },
  resolve(value) {
    if (typeof value === "object" && value !== null && typeof value.then === "function") {
      if (value instanceof PendingSyncPromise || value instanceof ResolvedSyncPromise || value instanceof RejectedSyncPromise) {
        return value;
      }
      return new PendingSyncPromise(value);
    } else {
      return new ResolvedSyncPromise(value);
    }
  },
  try(executor) {
    try {
      return SyncPromise.resolve(executor());
    } catch (e2) {
      return SyncPromise.reject(e2);
    }
  }
};
var PendingSyncPromise = class _PendingSyncPromise {
  constructor(promise) {
    __publicField(this, "promise");
    this.promise = promise;
  }
  then(onfulfilled, onrejected) {
    return new _PendingSyncPromise(this.promise.then(onfulfilled, onrejected));
  }
  valueOrPromise() {
    return this.promise;
  }
};
var ResolvedSyncPromise = class {
  constructor(value) {
    __publicField(this, "value");
    this.value = value;
  }
  then(onfulfilled) {
    if (!onfulfilled) {
      return this;
    }
    return SyncPromise.try(() => onfulfilled(this.value));
  }
  valueOrPromise() {
    return this.value;
  }
};
var RejectedSyncPromise = class {
  constructor(reason) {
    __publicField(this, "reason");
    this.reason = reason;
  }
  then(onfulfilled, onrejected) {
    if (!onrejected) {
      return this;
    }
    return SyncPromise.try(() => onrejected(this.reason));
  }
  valueOrPromise() {
    throw this.reason;
  }
};

// node_modules/@yume-chan/dataview-bigint-polyfill/esm/pure.js
var BigInt32 = BigInt(32);
function getBigInt64(dataView, byteOffset, littleEndian) {
  const littleEndianMask = Number(!!littleEndian);
  const bigEndianMask = Number(!littleEndian);
  return BigInt(dataView.getInt32(byteOffset, littleEndian) * bigEndianMask + dataView.getInt32(byteOffset + 4, littleEndian) * littleEndianMask) << BigInt32 | BigInt(dataView.getUint32(byteOffset, littleEndian) * littleEndianMask + dataView.getUint32(byteOffset + 4, littleEndian) * bigEndianMask);
}
function getBigUint64(dataView, byteOffset, littleEndian) {
  const a2 = dataView.getUint32(byteOffset, littleEndian);
  const b2 = dataView.getUint32(byteOffset + 4, littleEndian);
  const littleEndianMask = Number(!!littleEndian);
  const bigEndianMask = Number(!littleEndian);
  return BigInt(a2 * bigEndianMask + b2 * littleEndianMask) << BigInt32 | BigInt(a2 * littleEndianMask + b2 * bigEndianMask);
}
function setBigInt64(dataView, byteOffset, value, littleEndian) {
  const hi = Number(value >> BigInt32);
  const lo = Number(value & BigInt(4294967295));
  if (littleEndian) {
    dataView.setInt32(byteOffset + 4, hi, littleEndian);
    dataView.setUint32(byteOffset, lo, littleEndian);
  } else {
    dataView.setInt32(byteOffset, hi, littleEndian);
    dataView.setUint32(byteOffset + 4, lo, littleEndian);
  }
}
function setBigUint64(dataView, byteOffset, value, littleEndian) {
  const hi = Number(value >> BigInt32);
  const lo = Number(value & BigInt(4294967295));
  if (littleEndian) {
    dataView.setUint32(byteOffset + 4, hi, littleEndian);
    dataView.setUint32(byteOffset, lo, littleEndian);
  } else {
    dataView.setUint32(byteOffset, hi, littleEndian);
    dataView.setUint32(byteOffset + 4, lo, littleEndian);
  }
}

// node_modules/@yume-chan/dataview-bigint-polyfill/esm/fallback.js
var getBigInt642 = "getBigInt64" in DataView.prototype ? (dataView, byteOffset, littleEndian) => dataView.getBigInt64(byteOffset, littleEndian) : getBigInt64;
var getBigUint642 = "getBigUint64" in DataView.prototype ? (dataView, byteOffset, littleEndian) => dataView.getBigUint64(byteOffset, littleEndian) : getBigUint64;
var setBigInt642 = "setBigInt64" in DataView.prototype ? (dataView, byteOffset, value, littleEndian) => dataView.setBigInt64(byteOffset, value, littleEndian) : setBigInt64;
var setBigUint642 = "setBigUint64" in DataView.prototype ? (dataView, byteOffset, value, littleEndian) => dataView.setBigUint64(byteOffset, value, littleEndian) : setBigUint64;

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/struct/esm/types/bigint.js
var _BigIntFieldType = class _BigIntFieldType {
  constructor(size, getter, setter) {
    __publicField(this, "TTypeScriptType");
    __publicField(this, "size");
    __publicField(this, "getter");
    __publicField(this, "setter");
    this.size = size;
    this.getter = getter;
    this.setter = setter;
  }
};
__publicField(_BigIntFieldType, "Int64", new _BigIntFieldType(8, getBigInt642, setBigInt642));
__publicField(_BigIntFieldType, "Uint64", new _BigIntFieldType(8, getBigUint642, setBigUint642));
var BigIntFieldType = _BigIntFieldType;
var BigIntFieldDefinition = class extends StructFieldDefinition {
  constructor(type, typescriptType) {
    super();
    __publicField(this, "type");
    this.type = type;
  }
  getSize() {
    return this.type.size;
  }
  create(options, struct, value) {
    return new BigIntFieldValue(this, options, struct, value);
  }
  deserialize(options, stream, struct) {
    return SyncPromise.try(() => {
      return stream.read(this.getSize());
    }).then((array) => {
      const view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      const value = this.type.getter(view, 0, options.littleEndian);
      return this.create(options, struct, value);
    }).valueOrPromise();
  }
};
var BigIntFieldValue = class extends StructFieldValue {
  serialize(dataView, offset) {
    this.definition.type.setter(dataView, offset, this.value, this.options.littleEndian);
  }
};

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/struct/esm/utils.js
function placeholder() {
  return void 0;
}
var { TextEncoder, TextDecoder } = globalThis;
var Utf8Encoder = new TextEncoder();
var Utf8Decoder = new TextDecoder();
function encodeUtf8(input) {
  return Utf8Encoder.encode(input);
}
function decodeUtf8(buffer) {
  return Utf8Decoder.decode(buffer);
}

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/struct/esm/types/buffer/base.js
var BufferFieldSubType = class {
  constructor() {
    __publicField(this, "TTypeScriptType");
  }
};
var _Uint8ArrayBufferFieldSubType = class _Uint8ArrayBufferFieldSubType extends BufferFieldSubType {
  constructor() {
    super();
  }
  toBuffer(value) {
    return value;
  }
  toValue(buffer) {
    return buffer;
  }
  getSize(value) {
    return value.byteLength;
  }
};
__publicField(_Uint8ArrayBufferFieldSubType, "Instance", new _Uint8ArrayBufferFieldSubType());
var Uint8ArrayBufferFieldSubType = _Uint8ArrayBufferFieldSubType;
var _StringBufferFieldSubType = class _StringBufferFieldSubType extends BufferFieldSubType {
  toBuffer(value) {
    return encodeUtf8(value);
  }
  toValue(array) {
    return decodeUtf8(array);
  }
  getSize() {
    return -1;
  }
};
__publicField(_StringBufferFieldSubType, "Instance", new _StringBufferFieldSubType());
var StringBufferFieldSubType = _StringBufferFieldSubType;
var EMPTY_UINT8_ARRAY = new Uint8Array(0);
var BufferLikeFieldDefinition = class extends StructFieldDefinition {
  constructor(type, options) {
    super(options);
    __publicField(this, "type");
    this.type = type;
  }
  getDeserializeSize(struct) {
    return this.getSize();
  }
  /**
   * When implemented in derived classes, creates a `StructFieldValue` for the current field definition.
   */
  create(options, struct, value, array) {
    return new BufferLikeFieldValue(this, options, struct, value, array);
  }
  deserialize(options, stream, struct) {
    return SyncPromise.try(() => {
      const size = this.getDeserializeSize(struct);
      if (size === 0) {
        return EMPTY_UINT8_ARRAY;
      } else {
        return stream.read(size);
      }
    }).then((array) => {
      const value = this.type.toValue(array);
      return this.create(options, struct, value, array);
    }).valueOrPromise();
  }
};
var BufferLikeFieldValue = class extends StructFieldValue {
  constructor(definition, options, struct, value, array) {
    super(definition, options, struct, value);
    __publicField(this, "array");
    this.array = array;
  }
  set(value) {
    super.set(value);
    this.array = void 0;
  }
  serialize(dataView, offset) {
    if (!this.array) {
      this.array = this.definition.type.toBuffer(this.value);
    }
    new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength).set(this.array, offset);
  }
};

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/struct/esm/types/buffer/fixed-length.js
var FixedLengthBufferLikeFieldDefinition = class extends BufferLikeFieldDefinition {
  getSize() {
    return this.options.length;
  }
};

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/struct/esm/types/buffer/variable-length.js
var VariableLengthBufferLikeFieldDefinition = class extends BufferLikeFieldDefinition {
  getSize() {
    return 0;
  }
  getDeserializeSize(struct) {
    let value = struct.value[this.options.lengthField];
    if (typeof value === "string") {
      value = Number.parseInt(value, this.options.lengthFieldRadix ?? 10);
    }
    return value;
  }
  create(options, struct, value, array) {
    return new VariableLengthBufferLikeStructFieldValue(this, options, struct, value, array);
  }
};
var VariableLengthBufferLikeStructFieldValue = class extends BufferLikeFieldValue {
  constructor(definition, options, struct, value, array) {
    super(definition, options, struct, value, array);
    __publicField(this, "length");
    __publicField(this, "lengthFieldValue");
    if (array) {
      this.length = array.byteLength;
    }
    const lengthField = this.definition.options.lengthField;
    const originalValue = struct.get(lengthField);
    this.lengthFieldValue = new VariableLengthBufferLikeFieldLengthValue(originalValue, this);
    struct.set(lengthField, this.lengthFieldValue);
  }
  getSize() {
    if (this.length === void 0) {
      this.length = this.definition.type.getSize(this.value);
      if (this.length === -1) {
        this.array = this.definition.type.toBuffer(this.value);
        this.length = this.array.byteLength;
      }
    }
    return this.length;
  }
  set(value) {
    super.set(value);
    this.array = void 0;
    this.length = void 0;
  }
};
var VariableLengthBufferLikeFieldLengthValue = class extends StructFieldValue {
  constructor(originalField, arrayBufferField) {
    super(originalField.definition, originalField.options, originalField.struct, 0);
    __publicField(this, "originalField");
    __publicField(this, "bufferField");
    this.originalField = originalField;
    this.bufferField = arrayBufferField;
  }
  getSize() {
    return this.originalField.getSize();
  }
  get() {
    let value = this.bufferField.getSize();
    const originalValue = this.originalField.get();
    if (typeof originalValue === "string") {
      value = value.toString(this.bufferField.definition.options.lengthFieldRadix ?? 10);
    }
    return value;
  }
  set() {
  }
  serialize(dataView, offset) {
    this.originalField.set(this.get());
    this.originalField.serialize(dataView, offset);
  }
};

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/struct/esm/types/number.js
var NumberFieldType;
(function(NumberFieldType2) {
  NumberFieldType2.Uint8 = {
    signed: false,
    size: 1,
    deserialize(array) {
      return array[0];
    },
    serialize(dataView, offset, value) {
      dataView.setUint8(offset, value);
    }
  };
  NumberFieldType2.Int8 = {
    signed: true,
    size: 1,
    deserialize(array) {
      const value = NumberFieldType2.Uint8.deserialize(array, false);
      return value << 24 >> 24;
    },
    serialize(dataView, offset, value) {
      dataView.setInt8(offset, value);
    }
  };
  NumberFieldType2.Uint16 = {
    signed: false,
    size: 2,
    deserialize(array, littleEndian) {
      return (array[1] << 8 | array[0]) * littleEndian | (array[0] << 8 | array[1]) * !littleEndian;
    },
    serialize(dataView, offset, value, littleEndian) {
      dataView.setUint16(offset, value, littleEndian);
    }
  };
  NumberFieldType2.Int16 = {
    signed: true,
    size: 2,
    deserialize(array, littleEndian) {
      const value = NumberFieldType2.Uint16.deserialize(array, littleEndian);
      return value << 16 >> 16;
    },
    serialize(dataView, offset, value, littleEndian) {
      dataView.setInt16(offset, value, littleEndian);
    }
  };
  NumberFieldType2.Uint32 = {
    signed: false,
    size: 4,
    deserialize(array, littleEndian) {
      const value = NumberFieldType2.Int32.deserialize(array, littleEndian);
      return value >>> 0;
    },
    serialize(dataView, offset, value, littleEndian) {
      dataView.setUint32(offset, value, littleEndian);
    }
  };
  NumberFieldType2.Int32 = {
    signed: true,
    size: 4,
    deserialize(array, littleEndian) {
      return (array[3] << 24 | array[2] << 16 | array[1] << 8 | array[0]) * littleEndian | (array[0] << 24 | array[1] << 16 | array[2] << 8 | array[3]) * !littleEndian;
    },
    serialize(dataView, offset, value, littleEndian) {
      dataView.setInt32(offset, value, littleEndian);
    }
  };
})(NumberFieldType = NumberFieldType || (NumberFieldType = {}));
var NumberFieldDefinition = class extends StructFieldDefinition {
  constructor(type, typescriptType) {
    super();
    __publicField(this, "type");
    this.type = type;
  }
  getSize() {
    return this.type.size;
  }
  create(options, struct, value) {
    return new NumberFieldValue(this, options, struct, value);
  }
  deserialize(options, stream, struct) {
    return SyncPromise.try(() => {
      return stream.read(this.getSize());
    }).then((array) => {
      const value = this.type.deserialize(array, options.littleEndian);
      return this.create(options, struct, value);
    }).valueOrPromise();
  }
};
var NumberFieldValue = class extends StructFieldValue {
  serialize(dataView, offset) {
    this.definition.type.serialize(dataView, offset, this.value, this.options.littleEndian);
  }
};

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/struct/esm/struct.js
var Struct = class {
  constructor(options) {
    __publicField(this, "TFields");
    __publicField(this, "TOmitInitKey");
    __publicField(this, "TExtra");
    __publicField(this, "TInit");
    __publicField(this, "TDeserializeResult");
    __publicField(this, "options");
    __publicField(this, "_size", 0);
    __publicField(this, "_fields", []);
    __publicField(this, "_extra", {});
    __publicField(this, "_postDeserialized");
    __publicField(this, "arrayBufferLike", (name, type, options) => {
      if ("length" in options) {
        return this.field(name, new FixedLengthBufferLikeFieldDefinition(type, options));
      } else {
        return this.field(name, new VariableLengthBufferLikeFieldDefinition(type, options));
      }
    });
    __publicField(this, "uint8Array", (name, options, typeScriptType) => {
      return this.arrayBufferLike(name, Uint8ArrayBufferFieldSubType.Instance, options, typeScriptType);
    });
    __publicField(this, "string", (name, options, typeScriptType) => {
      return this.arrayBufferLike(name, StringBufferFieldSubType.Instance, options, typeScriptType);
    });
    this.options = { ...StructDefaultOptions, ...options };
  }
  /**
   * Gets the static size (exclude fields that can change size at runtime)
   */
  get size() {
    return this._size;
  }
  /**
   * Appends a `StructFieldDefinition` to the `Struct
   */
  field(name, definition) {
    for (const field of this._fields) {
      if (field[0] === name) {
        throw new Error(`This struct already have a field with name '${String(name)}'`);
      }
    }
    this._fields.push([name, definition]);
    const size = definition.getSize();
    this._size += size;
    return this;
  }
  /**
   * Merges (flats) another `Struct`'s fields and extra fields into this one.
   */
  fields(other) {
    for (const field of other._fields) {
      this._fields.push(field);
    }
    this._size += other._size;
    Object.defineProperties(this._extra, Object.getOwnPropertyDescriptors(other._extra));
    return this;
  }
  number(name, type, typeScriptType) {
    return this.field(name, new NumberFieldDefinition(type, typeScriptType));
  }
  /**
   * Appends an `int8` field to the `Struct`
   */
  int8(name, typeScriptType) {
    return this.number(name, NumberFieldType.Int8, typeScriptType);
  }
  /**
   * Appends an `uint8` field to the `Struct`
   */
  uint8(name, typeScriptType) {
    return this.number(name, NumberFieldType.Uint8, typeScriptType);
  }
  /**
   * Appends an `int16` field to the `Struct`
   */
  int16(name, typeScriptType) {
    return this.number(name, NumberFieldType.Int16, typeScriptType);
  }
  /**
   * Appends an `uint16` field to the `Struct`
   */
  uint16(name, typeScriptType) {
    return this.number(name, NumberFieldType.Uint16, typeScriptType);
  }
  /**
   * Appends an `int32` field to the `Struct`
   */
  int32(name, typeScriptType) {
    return this.number(name, NumberFieldType.Int32, typeScriptType);
  }
  /**
   * Appends an `uint32` field to the `Struct`
   */
  uint32(name, typeScriptType) {
    return this.number(name, NumberFieldType.Uint32, typeScriptType);
  }
  bigint(name, type, typeScriptType) {
    return this.field(name, new BigIntFieldDefinition(type, typeScriptType));
  }
  /**
   * Appends an `int64` field to the `Struct`
   *
   * Requires native `BigInt` support
   */
  int64(name, typeScriptType) {
    return this.bigint(name, BigIntFieldType.Int64, typeScriptType);
  }
  /**
   * Appends an `uint64` field to the `Struct`
   *
   * Requires native `BigInt` support
   */
  uint64(name, typeScriptType) {
    return this.bigint(name, BigIntFieldType.Uint64, typeScriptType);
  }
  /**
   * Adds some extra properties into every `Struct` value.
   *
   * Extra properties will not affect serialize or deserialize process.
   *
   * Multiple calls to `extra` will merge all properties together.
   *
   * @param value
   * An object containing properties to be added to the result value. Accessors and methods are also allowed.
   */
  extra(value) {
    Object.defineProperties(this._extra, Object.getOwnPropertyDescriptors(value));
    return this;
  }
  postDeserialize(callback) {
    this._postDeserialized = callback;
    return this;
  }
  deserialize(stream) {
    const structValue = new StructValue(this._extra);
    let promise = SyncPromise.resolve();
    for (const [name, definition] of this._fields) {
      promise = promise.then(() => definition.deserialize(this.options, stream, structValue)).then((fieldValue) => {
        structValue.set(name, fieldValue);
      });
    }
    return promise.then(() => {
      const object = structValue.value;
      if (this._postDeserialized) {
        const override = this._postDeserialized.call(object, object);
        if (override !== void 0) {
          return override;
        }
      }
      return object;
    }).valueOrPromise();
  }
  serialize(init, output) {
    let structValue;
    if (STRUCT_VALUE_SYMBOL in init) {
      structValue = init[STRUCT_VALUE_SYMBOL];
      for (const [key, value] of Object.entries(init)) {
        const fieldValue = structValue.get(key);
        if (fieldValue) {
          fieldValue.set(value);
        }
      }
    } else {
      structValue = new StructValue({});
      for (const [name, definition] of this._fields) {
        const fieldValue = definition.create(this.options, structValue, init[name]);
        structValue.set(name, fieldValue);
      }
    }
    let structSize = 0;
    const fieldsInfo = [];
    for (const [name] of this._fields) {
      const fieldValue = structValue.get(name);
      const size = fieldValue.getSize();
      fieldsInfo.push({ fieldValue, size });
      structSize += size;
    }
    let outputType = "number";
    if (!output) {
      output = new Uint8Array(structSize);
      outputType = "Uint8Array";
    }
    const dataView = new DataView(output.buffer, output.byteOffset, output.byteLength);
    let offset = 0;
    for (const { fieldValue, size } of fieldsInfo) {
      fieldValue.serialize(dataView, offset);
      offset += size;
    }
    if (outputType === "number") {
      return structSize;
    } else {
      return output;
    }
  }
};

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/stream-extra/esm/wrap-readable.js
function getWrappedReadableStream(wrapper, controller) {
  if ("start" in wrapper) {
    return wrapper.start(controller);
  } else if (typeof wrapper === "function") {
    return wrapper(controller);
  } else {
    return wrapper;
  }
}
var WrapReadableStream = class extends ReadableStream2 {
  constructor(wrapper) {
    super({
      start: async (controller) => {
        await Promise.resolve();
        this.readable = await getWrappedReadableStream(wrapper, controller);
        this.reader = this.readable.getReader();
      },
      cancel: async (reason) => {
        var _a2;
        await this.reader.cancel(reason);
        if ("cancel" in wrapper) {
          await ((_a2 = wrapper.cancel) == null ? void 0 : _a2.call(wrapper, reason));
        }
      },
      pull: async (controller) => {
        var _a2;
        const result = await this.reader.read();
        if (result.done) {
          controller.close();
          if ("close" in wrapper) {
            await ((_a2 = wrapper.close) == null ? void 0 : _a2.call(wrapper));
          }
        } else {
          controller.enqueue(result.value);
        }
      }
    });
    __publicField(this, "readable");
    __publicField(this, "reader");
  }
};

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/stream-extra/esm/duplex.js
var NOOP = () => {
};
var DuplexStreamFactory = class {
  constructor(options) {
    __publicField(this, "readableControllers", []);
    __publicField(this, "writers", []);
    __publicField(this, "_writableClosed", false);
    __publicField(this, "_closed", new PromiseResolver());
    __publicField(this, "options");
    this.options = options ?? {};
  }
  get writableClosed() {
    return this._writableClosed;
  }
  get closed() {
    return this._closed.promise;
  }
  wrapReadable(readable) {
    return new WrapReadableStream({
      start: (controller) => {
        this.readableControllers.push(controller);
        return readable;
      },
      cancel: async () => {
        await this.close();
      },
      close: async () => {
        await this.dispose();
      }
    });
  }
  createWritable(stream) {
    const writer = stream.getWriter();
    this.writers.push(writer);
    return new WritableStream2({
      write: async (chunk) => {
        await writer.write(chunk);
      },
      abort: async (reason) => {
        await writer.abort(reason);
        await this.close();
      },
      close: async () => {
        await writer.close().catch(NOOP);
        await this.close();
      }
    });
  }
  async close() {
    var _a2, _b;
    if (this._writableClosed) {
      return;
    }
    this._writableClosed = true;
    if (await ((_b = (_a2 = this.options).close) == null ? void 0 : _b.call(_a2)) !== false) {
      await this.dispose();
    }
    for (const writer of this.writers) {
      await writer.close().catch(NOOP);
    }
  }
  async dispose() {
    var _a2, _b;
    this._writableClosed = true;
    this._closed.resolve();
    for (const controller of this.readableControllers) {
      try {
        controller.close();
      } catch {
      }
    }
    await ((_b = (_a2 = this.options).dispose) == null ? void 0 : _b.call(_a2));
  }
};

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/stream-extra/esm/pipe-from.js
function pipeFrom(writable, pair) {
  const writer = pair.writable.getWriter();
  const pipe = pair.readable.pipeTo(writable);
  return new WritableStream2({
    async write(chunk) {
      await writer.write(chunk);
    },
    async close() {
      await writer.close();
      await pipe;
    }
  });
}

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/adb/esm/crypto.js
var BigInt0 = BigInt(0);
var BigInt1 = BigInt(1);
var BigInt2 = BigInt(2);
var BigInt64 = BigInt(64);
var RsaPrivateKeyNLength = 2048 / 8;
var RsaPrivateKeyDLength = 2048 / 8;
var SHA1_DIGEST_LENGTH = 20;
var ASN1_SEQUENCE = 48;
var ASN1_OCTET_STRING = 4;
var ASN1_NULL = 5;
var ASN1_OID = 6;
var SHA1_DIGEST_INFO = new Uint8Array([
  ASN1_SEQUENCE,
  13 + SHA1_DIGEST_LENGTH,
  ASN1_SEQUENCE,
  9,
  // SHA-1 (1 3 14 3 2 26)
  ASN1_OID,
  5,
  1 * 40 + 3,
  14,
  3,
  2,
  26,
  ASN1_NULL,
  0,
  ASN1_OCTET_STRING,
  SHA1_DIGEST_LENGTH
]);

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/adb/esm/packet.js
var AdbCommand;
(function(AdbCommand2) {
  AdbCommand2[AdbCommand2["Auth"] = 1213486401] = "Auth";
  AdbCommand2[AdbCommand2["Close"] = 1163086915] = "Close";
  AdbCommand2[AdbCommand2["Connect"] = 1314410051] = "Connect";
  AdbCommand2[AdbCommand2["OK"] = 1497451343] = "OK";
  AdbCommand2[AdbCommand2["Open"] = 1313165391] = "Open";
  AdbCommand2[AdbCommand2["Write"] = 1163154007] = "Write";
})(AdbCommand = AdbCommand || (AdbCommand = {}));
var AdbPacketHeader = new Struct({ littleEndian: true }).uint32("command").uint32("arg0").uint32("arg1").uint32("payloadLength").uint32("checksum").int32("magic");
var AdbPacket = new Struct({ littleEndian: true }).fields(AdbPacketHeader).uint8Array("payload", { lengthField: "payloadLength" });
var AdbPacketSerializeStream = class extends ConsumableTransformStream {
  constructor() {
    const headerBuffer = new Uint8Array(AdbPacketHeader.size);
    super({
      transform: async (chunk, controller) => {
        const init = chunk;
        init.payloadLength = init.payload.byteLength;
        AdbPacketHeader.serialize(init, headerBuffer);
        await controller.enqueue(headerBuffer);
        if (init.payload.byteLength) {
          await controller.enqueue(init.payload);
        }
      }
    });
  }
};

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/adb/esm/utils/base64.js
var charToIndex = [];
var indexToChar = [];
var paddingChar = "=".charCodeAt(0);
function addRange(start, end) {
  const charCodeStart = start.charCodeAt(0);
  const charCodeEnd = end.charCodeAt(0);
  for (let charCode = charCodeStart; charCode <= charCodeEnd; charCode += 1) {
    charToIndex[charCode] = indexToChar.length;
    indexToChar.push(charCode);
  }
}
addRange("A", "Z");
addRange("a", "z");
addRange("0", "9");
addRange("+", "+");
addRange("/", "/");

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/adb/esm/auth.js
var AdbAuthType;
(function(AdbAuthType2) {
  AdbAuthType2[AdbAuthType2["Token"] = 1] = "Token";
  AdbAuthType2[AdbAuthType2["Signature"] = 2] = "Signature";
  AdbAuthType2[AdbAuthType2["PublicKey"] = 3] = "PublicKey";
})(AdbAuthType = AdbAuthType || (AdbAuthType = {}));

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/adb/esm/commands/framebuffer.js
var Version = new Struct({ littleEndian: true }).uint32("version");
var AdbFrameBufferV1 = new Struct({ littleEndian: true }).uint32("bpp").uint32("size").uint32("width").uint32("height").uint32("red_offset").uint32("red_length").uint32("blue_offset").uint32("blue_length").uint32("green_offset").uint32("green_length").uint32("alpha_offset").uint32("alpha_length").uint8Array("data", { lengthField: "size" });
var AdbFrameBufferV2 = new Struct({ littleEndian: true }).uint32("bpp").uint32("colorSpace").uint32("size").uint32("width").uint32("height").uint32("red_offset").uint32("red_length").uint32("blue_offset").uint32("blue_length").uint32("green_offset").uint32("green_length").uint32("alpha_offset").uint32("alpha_length").uint8Array("data", { lengthField: "size" });

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/adb/esm/commands/reverse.js
var AdbReverseStringResponse = new Struct().string("length", { length: 4 }).string("content", { lengthField: "length", lengthFieldRadix: 16 });
var AdbReverseError = class _AdbReverseError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _AdbReverseError.prototype);
  }
};
var AdbReverseNotSupportedError = class _AdbReverseNotSupportedError extends Error {
  constructor() {
    super("ADB reverse tunnel is not supported on this device when connected wirelessly.");
    Object.setPrototypeOf(this, _AdbReverseNotSupportedError.prototype);
  }
};
var AdbReverseErrorResponse = new Struct().fields(AdbReverseStringResponse).postDeserialize((value) => {
  if (value.content === "more than one device/emulator") {
    throw new AdbReverseNotSupportedError();
  } else {
    throw new AdbReverseError(value.content);
  }
});

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/adb/esm/features.js
var AdbFeature;
(function(AdbFeature2) {
  AdbFeature2["ShellV2"] = "shell_v2";
  AdbFeature2["Cmd"] = "cmd";
  AdbFeature2["StatV2"] = "stat_v2";
  AdbFeature2["ListV2"] = "ls_v2";
  AdbFeature2["FixedPushMkdir"] = "fixed_push_mkdir";
  AdbFeature2["Abb"] = "abb";
  AdbFeature2["AbbExec"] = "abb_exec";
  AdbFeature2["SendReceiveV2"] = "sendrecv_v2";
})(AdbFeature = AdbFeature || (AdbFeature = {}));

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/adb/esm/commands/subprocess/protocols/shell.js
var AdbShellProtocolId;
(function(AdbShellProtocolId2) {
  AdbShellProtocolId2[AdbShellProtocolId2["Stdin"] = 0] = "Stdin";
  AdbShellProtocolId2[AdbShellProtocolId2["Stdout"] = 1] = "Stdout";
  AdbShellProtocolId2[AdbShellProtocolId2["Stderr"] = 2] = "Stderr";
  AdbShellProtocolId2[AdbShellProtocolId2["Exit"] = 3] = "Exit";
  AdbShellProtocolId2[AdbShellProtocolId2["CloseStdin"] = 4] = "CloseStdin";
  AdbShellProtocolId2[AdbShellProtocolId2["WindowSizeChange"] = 5] = "WindowSizeChange";
})(AdbShellProtocolId = AdbShellProtocolId || (AdbShellProtocolId = {}));
var AdbShellProtocolPacket = new Struct({ littleEndian: true }).uint8("id", placeholder()).uint32("length").uint8Array("data", { lengthField: "length" });

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/adb/esm/commands/sync/request.js
var AdbSyncRequestId;
(function(AdbSyncRequestId2) {
  AdbSyncRequestId2["List"] = "LIST";
  AdbSyncRequestId2["ListV2"] = "LIS2";
  AdbSyncRequestId2["Send"] = "SEND";
  AdbSyncRequestId2["SendV2"] = "SND2";
  AdbSyncRequestId2["Lstat"] = "STAT";
  AdbSyncRequestId2["Stat"] = "STA2";
  AdbSyncRequestId2["LstatV2"] = "LST2";
  AdbSyncRequestId2["Data"] = "DATA";
  AdbSyncRequestId2["Done"] = "DONE";
  AdbSyncRequestId2["Receive"] = "RECV";
})(AdbSyncRequestId = AdbSyncRequestId || (AdbSyncRequestId = {}));
var AdbSyncNumberRequest = new Struct({ littleEndian: true }).string("id", { length: 4 }).uint32("arg");
var AdbSyncDataRequest = new Struct({ littleEndian: true }).fields(AdbSyncNumberRequest).uint8Array("data", { lengthField: "arg" });

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/adb/esm/commands/sync/response.js
var AdbSyncResponseId;
(function(AdbSyncResponseId2) {
  AdbSyncResponseId2["Entry"] = "DENT";
  AdbSyncResponseId2["Entry2"] = "DNT2";
  AdbSyncResponseId2["Lstat"] = "STAT";
  AdbSyncResponseId2["Stat"] = "STA2";
  AdbSyncResponseId2["Lstat2"] = "LST2";
  AdbSyncResponseId2["Done"] = "DONE";
  AdbSyncResponseId2["Data"] = "DATA";
  AdbSyncResponseId2["Ok"] = "OKAY";
  AdbSyncResponseId2["Fail"] = "FAIL";
})(AdbSyncResponseId = AdbSyncResponseId || (AdbSyncResponseId = {}));
var AdbSyncFailResponse = new Struct({ littleEndian: true }).uint32("messageLength").string("message", { lengthField: "messageLength" }).postDeserialize((object) => {
  throw new Error(object.message);
});

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/adb/esm/commands/sync/stat.js
var LinuxFileType;
(function(LinuxFileType2) {
  LinuxFileType2[LinuxFileType2["Directory"] = 4] = "Directory";
  LinuxFileType2[LinuxFileType2["File"] = 8] = "File";
  LinuxFileType2[LinuxFileType2["Link"] = 10] = "Link";
})(LinuxFileType = LinuxFileType || (LinuxFileType = {}));
var AdbSyncLstatResponse = new Struct({ littleEndian: true }).int32("mode").int32("size").int32("mtime").extra({
  id: AdbSyncResponseId.Lstat,
  get type() {
    return this.mode >> 12;
  },
  get permission() {
    return this.mode & 4095;
  }
}).postDeserialize((object) => {
  if (object.mode === 0 && object.size === 0 && object.mtime === 0) {
    throw new Error("lstat error");
  }
});
var AdbSyncStatErrorCode;
(function(AdbSyncStatErrorCode2) {
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["SUCCESS"] = 0] = "SUCCESS";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["EACCES"] = 13] = "EACCES";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["EEXIST"] = 17] = "EEXIST";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["EFAULT"] = 14] = "EFAULT";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["EFBIG"] = 27] = "EFBIG";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["EINTR"] = 4] = "EINTR";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["EINVAL"] = 22] = "EINVAL";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["EIO"] = 5] = "EIO";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["EISDIR"] = 21] = "EISDIR";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["ELOOP"] = 40] = "ELOOP";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["EMFILE"] = 24] = "EMFILE";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["ENAMETOOLONG"] = 36] = "ENAMETOOLONG";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["ENFILE"] = 23] = "ENFILE";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["ENOENT"] = 2] = "ENOENT";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["ENOMEM"] = 12] = "ENOMEM";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["ENOSPC"] = 28] = "ENOSPC";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["ENOTDIR"] = 20] = "ENOTDIR";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["EOVERFLOW"] = 75] = "EOVERFLOW";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["EPERM"] = 1] = "EPERM";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["EROFS"] = 30] = "EROFS";
  AdbSyncStatErrorCode2[AdbSyncStatErrorCode2["ETXTBSY"] = 26] = "ETXTBSY";
})(AdbSyncStatErrorCode = AdbSyncStatErrorCode || (AdbSyncStatErrorCode = {}));
var AdbSyncStatResponse = new Struct({ littleEndian: true }).uint32("error", placeholder()).uint64("dev").uint64("ino").uint32("mode").uint32("nlink").uint32("uid").uint32("gid").uint64("size").uint64("atime").uint64("mtime").uint64("ctime").extra({
  id: AdbSyncResponseId.Stat,
  get type() {
    return this.mode >> 12;
  },
  get permission() {
    return this.mode & 4095;
  }
}).postDeserialize((object) => {
  if (object.error) {
    throw new Error(AdbSyncStatErrorCode[object.error]);
  }
});

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/adb/esm/commands/sync/list.js
var AdbSyncEntryResponse = new Struct({ littleEndian: true }).fields(AdbSyncLstatResponse).uint32("nameLength").string("name", { lengthField: "nameLength" }).extra({ id: AdbSyncResponseId.Entry });
var AdbSyncEntry2Response = new Struct({ littleEndian: true }).fields(AdbSyncStatResponse).uint32("nameLength").string("name", { lengthField: "nameLength" }).extra({ id: AdbSyncResponseId.Entry2 });

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/adb/esm/commands/sync/pull.js
var AdbSyncDataResponse = new Struct({ littleEndian: true }).uint32("dataLength").uint8Array("data", { lengthField: "dataLength" }).extra({ id: AdbSyncResponseId.Data });

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/adb/esm/commands/sync/push.js
var ADB_SYNC_MAX_PACKET_SIZE = 64 * 1024;
var AdbSyncOkResponse = new Struct({ littleEndian: true }).uint32("unused");
var AdbSyncSendV2Flags;
(function(AdbSyncSendV2Flags2) {
  AdbSyncSendV2Flags2[AdbSyncSendV2Flags2["None"] = 0] = "None";
  AdbSyncSendV2Flags2[AdbSyncSendV2Flags2["Brotli"] = 1] = "Brotli";
  AdbSyncSendV2Flags2[AdbSyncSendV2Flags2["Lz4"] = 2] = "Lz4";
  AdbSyncSendV2Flags2[AdbSyncSendV2Flags2["Zstd"] = 4] = "Zstd";
  AdbSyncSendV2Flags2[AdbSyncSendV2Flags2["DryRun"] = 2147483648] = "DryRun";
})(AdbSyncSendV2Flags = AdbSyncSendV2Flags || (AdbSyncSendV2Flags = {}));
var AdbSyncSendV2Request = new Struct({ littleEndian: true }).uint32("id", placeholder()).uint32("mode").uint32("flags", placeholder());

// node_modules/@yume-chan/adb-backend-webusb/node_modules/@yume-chan/adb/esm/adb.js
var AdbPropKey;
(function(AdbPropKey2) {
  AdbPropKey2["Product"] = "ro.product.name";
  AdbPropKey2["Model"] = "ro.product.model";
  AdbPropKey2["Device"] = "ro.product.device";
  AdbPropKey2["Features"] = "features";
})(AdbPropKey = AdbPropKey || (AdbPropKey = {}));

// node_modules/@yume-chan/adb-backend-webusb/esm/backend.js
var ADB_DEFAULT_DEVICE_FILTER = {
  classCode: 255,
  subclassCode: 66,
  protocolCode: 1
};
function alternateMatchesFilter(alternate, filters) {
  return filters.some((filter) => alternate.interfaceClass === filter.classCode && alternate.interfaceSubclass === filter.subclassCode && alternate.interfaceProtocol === filter.protocolCode);
}
function findUsbAlternateInterface(device, filters) {
  for (const configuration of device.configurations) {
    for (const interface_ of configuration.interfaces) {
      for (const alternate of interface_.alternates) {
        if (alternateMatchesFilter(alternate, filters)) {
          return { configuration, interface_, alternate };
        }
      }
    }
  }
  throw new Error("No matched alternate interface found");
}
function findUsbEndpoints(endpoints) {
  if (endpoints.length === 0) {
    throw new Error("No endpoints given");
  }
  let inEndpoint;
  let outEndpoint;
  for (const endpoint of endpoints) {
    switch (endpoint.direction) {
      case "in":
        inEndpoint = endpoint;
        if (outEndpoint) {
          return { inEndpoint, outEndpoint };
        }
        break;
      case "out":
        outEndpoint = endpoint;
        if (inEndpoint) {
          return { inEndpoint, outEndpoint };
        }
        break;
    }
  }
  if (!inEndpoint) {
    throw new Error("No input endpoint found.");
  }
  if (!outEndpoint) {
    throw new Error("No output endpoint found.");
  }
  throw new Error("unreachable");
}
var Uint8ArrayStructDeserializeStream = class {
  constructor(buffer) {
    __publicField(this, "buffer");
    __publicField(this, "offset");
    this.buffer = buffer;
    this.offset = 0;
  }
  read(length) {
    const result = this.buffer.subarray(this.offset, this.offset + length);
    this.offset += length;
    return result;
  }
};
var AdbWebUsbBackendStream = class {
  constructor(device, inEndpoint, outEndpoint, usbManager) {
    __publicField(this, "_readable");
    __publicField(this, "_writable");
    let closed = false;
    const factory = new DuplexStreamFactory({
      close: async () => {
        try {
          closed = true;
          await device.close();
        } catch {
        }
      },
      dispose: () => {
        usbManager.removeEventListener("disconnect", handleUsbDisconnect);
      }
    });
    function handleUsbDisconnect(e2) {
      if (e2.device === device) {
        factory.dispose().catch((e3) => {
        });
      }
    }
    usbManager.addEventListener("disconnect", handleUsbDisconnect);
    this._readable = factory.wrapReadable(new ReadableStream2({
      async pull(controller) {
        const result = await device.transferIn(inEndpoint.endpointNumber, 24);
        const buffer = new Uint8Array(result.data.buffer);
        const stream = new Uint8ArrayStructDeserializeStream(buffer);
        const packet = AdbPacketHeader.deserialize(stream);
        if (packet.payloadLength !== 0) {
          const result2 = await device.transferIn(inEndpoint.endpointNumber, packet.payloadLength);
          packet.payload = new Uint8Array(result2.data.buffer);
        } else {
          packet.payload = EMPTY_UINT8_ARRAY;
        }
        controller.enqueue(packet);
      }
    }));
    const zeroMask = outEndpoint.packetSize - 1;
    this._writable = pipeFrom(factory.createWritable(new ConsumableWritableStream({
      write: async (chunk) => {
        try {
          await device.transferOut(outEndpoint.endpointNumber, chunk);
          if (zeroMask && (chunk.byteLength & zeroMask) === 0) {
            await device.transferOut(outEndpoint.endpointNumber, EMPTY_UINT8_ARRAY);
          }
        } catch (e2) {
          if (closed) {
            return;
          }
          throw e2;
        }
      }
    })), new AdbPacketSerializeStream());
  }
  get readable() {
    return this._readable;
  }
  get writable() {
    return this._writable;
  }
};
var AdbWebUsbBackend = class {
  /**
   * Create a new instance of `AdbWebBackend` using a specified `USBDevice` instance
   *
   * @param device The `USBDevice` instance obtained elsewhere.
   * @param filters The filters to use when searching for ADB interface. Defaults to {@link ADB_DEFAULT_DEVICE_FILTER}.
   */
  constructor(device, filters = [ADB_DEFAULT_DEVICE_FILTER], usb) {
    __publicField(this, "_filters");
    __publicField(this, "_usb");
    __publicField(this, "_device");
    this._device = device;
    this._filters = filters;
    this._usb = usb;
  }
  get device() {
    return this._device;
  }
  get serial() {
    return this._device.serialNumber;
  }
  get name() {
    return this._device.productName;
  }
  /**
   * Claim the device and create a pair of `AdbPacket` streams to the ADB interface.
   * @returns The pair of `AdbPacket` streams.
   */
  async connect() {
    var _a2;
    if (!this._device.opened) {
      await this._device.open();
    }
    const { configuration, interface_, alternate } = findUsbAlternateInterface(this._device, this._filters);
    if (((_a2 = this._device.configuration) == null ? void 0 : _a2.configurationValue) !== configuration.configurationValue) {
      await this._device.selectConfiguration(configuration.configurationValue);
    }
    if (!interface_.claimed) {
      await this._device.claimInterface(interface_.interfaceNumber);
    }
    if (interface_.alternate.alternateSetting !== alternate.alternateSetting) {
      await this._device.selectAlternateInterface(interface_.interfaceNumber, alternate.alternateSetting);
    }
    const { inEndpoint, outEndpoint } = findUsbEndpoints(alternate.endpoints);
    return new AdbWebUsbBackendStream(this._device, inEndpoint, outEndpoint, this._usb);
  }
};

// node_modules/@yume-chan/adb-backend-webusb/esm/manager.js
var _AdbWebUsbBackendManager = class _AdbWebUsbBackendManager {
  /**
   * Create a new instance of `AdbWebUsbBackendManager` using the specified WebUSB API implementation.
   * @param usb A WebUSB compatible interface.
   */
  constructor(usb) {
    __publicField(this, "_usb");
    this._usb = usb;
  }
  /**
   * Request access to a connected device.
   * This is a convince method for `usb.requestDevice()`.
   * @param filters
   * The filters to apply to the device list.
   *
   * It must have `classCode`, `subclassCode` and `protocolCode` fields for selecting the ADB interface,
   * but might also have `vendorId`, `productId` or `serialNumber` fields to limit the displayed device list.
   *
   * Defaults to {@link ADB_DEFAULT_DEVICE_FILTER}.
   * @param usbManager
   * A WebUSB compatible interface.
   * For example, `usb` NPM package for Node.js has a `webusb` object that can be used here.
   *
   * Defaults to `window.navigator.usb` (will throw an error if not exist).
   * @returns The `AdbWebUsbBackend` instance if the user selected a device,
   * or `undefined` if the user cancelled the device picker.
   */
  async requestDevice(filters = [ADB_DEFAULT_DEVICE_FILTER]) {
    try {
      const device = await this._usb.requestDevice({
        filters
      });
      return new AdbWebUsbBackend(device, filters, this._usb);
    } catch (e2) {
      if (typeof e2 === "object" && e2 !== null && "name" in e2 && e2.name === "NotFoundError") {
        return void 0;
      }
      throw e2;
    }
  }
  /**
   * Get all connected and authenticated devices.
   * This is a convince method for `usb.getDevices()`.
   * @param filters
   * The filters to apply to the device list.
   *
   * It must have `classCode`, `subclassCode` and `protocolCode` fields for selecting the ADB interface,
   * but might also have `vendorId`, `productId` or `serialNumber` fields to limit the displayed device list.
   *
   * Defaults to {@link ADB_DEFAULT_DEVICE_FILTER}.
   * @param usbManager
   * A WebUSB compatible interface.
   * For example, `usb` NPM package for Node.js has a `webusb` object that can be used here.
   *
   * Defaults to `window.navigator.usb` (will throw an error if not exist).
   * @returns An array of `AdbWebUsbBackend` instances for all connected and authenticated devices.
   */
  async getDevices(filters = [ADB_DEFAULT_DEVICE_FILTER]) {
    const devices = await this._usb.getDevices();
    return devices.map((device) => new AdbWebUsbBackend(device, filters, this._usb));
  }
};
/**
 * Gets the instance of AdbWebUsbBackendManager using browser WebUSB implementation.
 *
 * May be `undefined` if the browser does not support WebUSB.
 */
__publicField(_AdbWebUsbBackendManager, "BROWSER", typeof window !== "undefined" && !!window.navigator.usb ? new _AdbWebUsbBackendManager(window.navigator.usb) : void 0);
var AdbWebUsbBackendManager = _AdbWebUsbBackendManager;

// node_modules/@yume-chan/adb-backend-webusb/esm/watcher.js
var AdbWebUsbBackendWatcher = class {
  constructor(callback, usb) {
    __publicField(this, "_callback");
    __publicField(this, "_usb");
    __publicField(this, "handleConnect", (e2) => {
      this._callback(e2.device.serialNumber);
    });
    __publicField(this, "handleDisconnect", () => {
      this._callback();
    });
    this._callback = callback;
    this._usb = usb;
    this._usb.addEventListener("connect", this.handleConnect);
    this._usb.addEventListener("disconnect", this.handleDisconnect);
  }
  dispose() {
    this._usb.removeEventListener("connect", this.handleConnect);
    this._usb.removeEventListener("disconnect", this.handleDisconnect);
  }
};
export {
  ADB_DEFAULT_DEVICE_FILTER,
  AdbWebUsbBackend,
  AdbWebUsbBackendManager,
  AdbWebUsbBackendStream,
  AdbWebUsbBackendWatcher
};
/*! Bundled license information:

web-streams-polyfill/dist/ponyfill.mjs:
  (**
   * @license
   * web-streams-polyfill v4.2.0
   * Copyright 2025 Mattias Buelens, Diwank Singh Tomer and other contributors.
   * This code is released under the MIT license.
   * SPDX-License-Identifier: MIT
   *)
*/
//# sourceMappingURL=@yume-chan_adb-backend-webusb.js.map
