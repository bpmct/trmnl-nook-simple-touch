{
  "version": 3,
  "sources": ["../../@yume-chan/async/src/promise-resolver.ts", "../../@yume-chan/async/src/async-operation-manager.ts", "../../@yume-chan/async/src/delay.ts", "../../@yume-chan/async/src/maybe-promise.ts", "../../@yume-chan/struct/src/bipedal.ts", "../../@yume-chan/struct/src/field/serialize.ts", "../../@yume-chan/struct/src/field/factory.ts", "../../@yume-chan/struct/src/buffer.ts", "../../@yume-chan/struct/src/readable.ts", "../../@yume-chan/struct/src/struct.ts", "../../@yume-chan/struct/src/extend.ts", "../../@yume-chan/no-data-view/src/int16.ts", "../../@yume-chan/no-data-view/src/int32.ts", "../../@yume-chan/no-data-view/src/int64.ts", "../../@yume-chan/no-data-view/src/int8.ts", "../../@yume-chan/no-data-view/src/uint16.ts", "../../@yume-chan/no-data-view/src/uint32.ts", "../../@yume-chan/no-data-view/src/uint64.ts", "../../@yume-chan/struct/src/number.ts", "../../@yume-chan/struct/src/utils.ts", "../../@yume-chan/struct/src/string.ts", "../../@yume-chan/stream-extra/src/stream.ts", "../../@yume-chan/stream-extra/src/push-readable.ts", "../../@yume-chan/stream-extra/src/try-close.ts", "../../@yume-chan/stream-extra/src/buffered.ts", "../../@yume-chan/stream-extra/src/buffered-transform.ts", "../../@yume-chan/stream-extra/src/concat.ts", "../../@yume-chan/stream-extra/src/consumable/readable.ts", "../../@yume-chan/stream-extra/src/consumable/wrap-byte-readable.ts", "../../@yume-chan/stream-extra/src/consumable/wrap-writable.ts", "../../@yume-chan/stream-extra/src/consumable/writable.ts", "../../@yume-chan/stream-extra/src/task.ts", "../../@yume-chan/stream-extra/src/consumable.ts", "../../@yume-chan/stream-extra/src/maybe-consumable/index.ts", "../../@yume-chan/stream-extra/src/maybe-consumable/utils.ts", "../../@yume-chan/stream-extra/src/maybe-consumable/wrap-writable.ts", "../../@yume-chan/stream-extra/src/maybe-consumable/writable.ts", "../../@yume-chan/stream-extra/src/distribution.ts", "../../@yume-chan/stream-extra/src/encoding.ts", "../../@yume-chan/stream-extra/src/struct-deserialize.ts", "../../@yume-chan/event/src/disposable.ts", "../../@yume-chan/event/src/event-emitter.ts", "../../@yume-chan/event/src/sticky-event-emitter.ts", "../../@yume-chan/adb/src/commands/base.ts", "../../@yume-chan/adb/src/commands/framebuffer.ts", "../../@yume-chan/adb/src/commands/power.ts", "../../@yume-chan/adb/src/utils/array-buffer.ts", "../../@yume-chan/adb/src/utils/auto-reset-event.ts", "../../@yume-chan/adb/src/utils/base64.ts", "../../@yume-chan/adb/src/utils/hex.ts", "../../@yume-chan/adb/src/utils/no-op.ts", "../../@yume-chan/adb/src/utils/ref.ts", "../../@yume-chan/adb/src/utils/sequence-equal.ts", "../../@yume-chan/adb/src/commands/reverse.ts", "../../@yume-chan/adb/src/commands/subprocess/none/process.ts", "../../@yume-chan/adb/src/commands/subprocess/none/pty.ts", "../../@yume-chan/adb/src/commands/subprocess/utils.ts", "../../@yume-chan/adb/src/commands/subprocess/none/spawner.ts", "../../@yume-chan/adb/src/commands/subprocess/none/service.ts", "../../@yume-chan/adb/src/features.ts", "../../@yume-chan/adb/src/commands/subprocess/shell/shared.ts", "../../@yume-chan/adb/src/commands/subprocess/shell/process.ts", "../../@yume-chan/adb/src/commands/subprocess/shell/pty.ts", "../../@yume-chan/adb/src/commands/subprocess/shell/spawner.ts", "../../@yume-chan/adb/src/commands/subprocess/shell/service.ts", "../../@yume-chan/adb/src/commands/subprocess/service.ts", "../../@yume-chan/adb/src/commands/sync/response.ts", "../../@yume-chan/adb/src/commands/sync/request.ts", "../../@yume-chan/adb/src/commands/sync/stat.ts", "../../@yume-chan/adb/src/commands/sync/list.ts", "../../@yume-chan/adb/src/commands/sync/pull.ts", "../../@yume-chan/adb/src/commands/sync/push.ts", "../../@yume-chan/adb/src/commands/sync/socket.ts", "../../@yume-chan/adb/src/commands/sync/sync.ts", "../../@yume-chan/adb/src/commands/tcpip.ts", "../../@yume-chan/adb/src/adb.ts", "../../@yume-chan/adb/src/banner.ts", "../../@yume-chan/adb/src/daemon/crypto.ts", "../../@yume-chan/adb/src/daemon/packet.ts", "../../@yume-chan/adb/src/daemon/auth.ts", "../../@yume-chan/adb/src/daemon/socket.ts", "../../@yume-chan/adb/src/daemon/dispatcher.ts", "../../@yume-chan/adb/src/daemon/transport.ts", "../../@yume-chan/adb/src/server/commands/m-dns.ts", "../../@yume-chan/adb/src/server/stream.ts", "../../@yume-chan/adb/src/server/commands/wireless.ts", "../../@yume-chan/adb/src/server/observer.ts", "../../@yume-chan/adb/src/server/transport.ts", "../../@yume-chan/adb/src/server/client.ts"],
  "sourcesContent": ["export type PromiseResolverState = 'running' | 'resolved' | 'rejected';\n\nexport class PromiseResolver<T> {\n    #promise: Promise<T>;\n    public get promise(): Promise<T> { return this.#promise; }\n\n    #resolve!: (value: T | PromiseLike<T>) => void;\n    #reject!: (reason?: any) => void;\n\n    #state: PromiseResolverState = 'running';\n    public get state(): PromiseResolverState { return this.#state; }\n\n    public constructor() {\n        this.#promise = new Promise<T>((resolve, reject) => {\n            this.#resolve = resolve;\n            this.#reject = reject;\n        });\n    }\n\n    public resolve = (value: T | PromiseLike<T>): void => {\n        this.#resolve(value);\n        this.#state = 'resolved';\n    };\n\n    public reject = (reason?: any): void => {\n        this.#reject(reason);\n        this.#state = 'rejected';\n    };\n}\n", "import { PromiseResolver } from \"./promise-resolver.js\";\n\nexport class AsyncOperationManager {\n    private nextId: number;\n\n    private pendingResolvers: Map<number, PromiseResolver<any>> = new Map();\n\n    public constructor(startId: number = 0) {\n        this.nextId = startId;\n    }\n\n    public add<T>(): [id: number, promise: Promise<T>] {\n        const id = this.nextId++;\n        const resolver = new PromiseResolver<T>();\n        this.pendingResolvers.set(id, resolver);\n        return [id, resolver.promise];\n    }\n\n    private getResolver(id: number): PromiseResolver<unknown> | null {\n        if (!this.pendingResolvers.has(id)) {\n            return null;\n        }\n\n        const resolver = this.pendingResolvers.get(id)!;\n        this.pendingResolvers.delete(id);\n        return resolver;\n    }\n\n    public resolve<T>(id: number, result: T): boolean {\n        const resolver = this.getResolver(id);\n        if (resolver !== null) {\n            resolver.resolve(result);\n            return true;\n        }\n        return false;\n    }\n\n    public reject(id: number, reason: Error): boolean {\n        const resolver = this.getResolver(id);\n        if (resolver !== null) {\n            resolver.reject(reason);\n            return true;\n        }\n        return false;\n    }\n}\n", "export function delay(time: number): Promise<void> {\n    return new Promise<void>(resolve => {\n        // Don't call `resolve` with any value.\n        (globalThis as any).setTimeout(() => resolve(), time);\n    });\n}\n", "export type MaybePromise<T> = T | Promise<T>;\n\nexport type MaybePromiseLike<T> = T | PromiseLike<T>;\n\nexport function isPromiseLike<T>(value: unknown): value is PromiseLike<T> {\n    return typeof value === \"object\" && value !== null && \"then\" in value;\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { isPromiseLike } from \"@yume-chan/async\";\n\nfunction advance<T>(\n    iterator: Iterator<unknown, T, unknown>,\n    next: unknown,\n): MaybePromiseLike<T> {\n    while (true) {\n        const { done, value } = iterator.next(next);\n        if (done) {\n            return value;\n        }\n        if (isPromiseLike(value)) {\n            return value.then(\n                (value) => advance(iterator, { resolved: value }),\n                (error: unknown) => advance(iterator, { error }),\n            );\n        }\n        next = value;\n    }\n}\n\nexport type BipedalGenerator<This, T, A extends unknown[]> = (\n    this: This,\n    then: <U>(value: MaybePromiseLike<U>) => Iterable<unknown, U, unknown>,\n    ...args: A\n) => Generator<unknown, T, unknown>;\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function bipedal<This, T, A extends unknown[]>(\n    fn: BipedalGenerator<This, T, A>,\n    bindThis?: This,\n): { (this: This, ...args: A): MaybePromiseLike<T> } {\n    function result(this: This, ...args: A): MaybePromiseLike<T> {\n        const iterator = fn.call(\n            this,\n            function* <U>(\n                value: MaybePromiseLike<U>,\n            ): Generator<\n                PromiseLike<U>,\n                U,\n                { resolved: U } | { error: unknown }\n            > {\n                if (isPromiseLike(value)) {\n                    const result = yield value;\n                    if (\"resolved\" in result) {\n                        return result.resolved;\n                    } else {\n                        throw result.error;\n                    }\n                }\n\n                return value;\n            },\n            ...args,\n        ) as never;\n        return advance(iterator, undefined);\n    }\n\n    if (bindThis) {\n        return result.bind(bindThis);\n    } else {\n        return result;\n    }\n}\n", "import type {\n    FieldByobSerializeContext,\n    FieldDefaultSerializeContext,\n    FieldSerializer,\n} from \"./types.js\";\n\nexport type DefaultFieldSerializer<T> = (\n    source: T,\n    context: FieldDefaultSerializeContext,\n) => Uint8Array;\n\n/* Adapt default field serializer to universal field serializer */\nexport function defaultFieldSerializer<T>(\n    serializer: DefaultFieldSerializer<T>,\n): FieldSerializer<T>[\"serialize\"] {\n    return (\n        source,\n        context: FieldDefaultSerializeContext | FieldByobSerializeContext,\n    ): never => {\n        if (\"buffer\" in context) {\n            const buffer = serializer(source, context);\n            context.buffer.set(buffer, context.index);\n            return buffer.length as never;\n        } else {\n            return serializer(source, context) as never;\n        }\n    };\n}\n\nexport type ByobFieldSerializer<T> = (\n    source: T,\n    context: FieldByobSerializeContext & { index: number },\n) => void;\n\n/* Adapt byob field serializer to universal field serializer */\nexport function byobFieldSerializer<T>(\n    size: number,\n    serializer: ByobFieldSerializer<T>,\n): FieldSerializer<T>[\"serialize\"] {\n    return (\n        source,\n        context: FieldDefaultSerializeContext | FieldByobSerializeContext,\n    ): never => {\n        if (\"buffer\" in context) {\n            context.index ??= 0;\n            serializer(source, context as never);\n            return size as never;\n        } else {\n            const buffer = new Uint8Array(size);\n            serializer(source, {\n                buffer,\n                index: 0,\n                littleEndian: context.littleEndian,\n            });\n            return buffer as never;\n        }\n    };\n}\n", "import type { BipedalGenerator } from \"../bipedal.js\";\nimport { bipedal } from \"../bipedal.js\";\nimport type { AsyncExactReadable } from \"../readable.js\";\n\nimport type {\n    ByobFieldSerializer,\n    DefaultFieldSerializer,\n} from \"./serialize.js\";\nimport { byobFieldSerializer, defaultFieldSerializer } from \"./serialize.js\";\nimport type { Field, FieldDeserializeContext, FieldOptions } from \"./types.js\";\n\nexport type BipedalFieldDeserializer<T, D> = BipedalGenerator<\n    undefined,\n    T,\n    [reader: AsyncExactReadable, context: FieldDeserializeContext<D>]\n>;\n\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction _field<T, OmitInit extends string, D, Raw = T>(\n    size: number,\n    type: \"default\",\n    serialize: DefaultFieldSerializer<Raw>,\n    deserialize: BipedalFieldDeserializer<T, D>,\n    options?: FieldOptions<T, OmitInit, D, Raw>,\n): Field<T, OmitInit, D, Raw>;\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction _field<T, OmitInit extends string, D, Raw = T>(\n    size: number,\n    type: \"byob\",\n    serialize: ByobFieldSerializer<Raw>,\n    deserialize: BipedalFieldDeserializer<T, D>,\n    options?: FieldOptions<T, OmitInit, D, Raw>,\n): Field<T, OmitInit, D, Raw>;\n/* #__NO_SIDE_EFFECTS__ */\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction _field<T, OmitInit extends string, D, Raw = T>(\n    size: number,\n    type: \"default\" | \"byob\",\n    serialize: DefaultFieldSerializer<Raw> | ByobFieldSerializer<Raw>,\n    deserialize: BipedalFieldDeserializer<T, D>,\n    options?: FieldOptions<T, OmitInit, D, Raw>,\n): Field<T, OmitInit, D, Raw> {\n    const field: Field<T, OmitInit, D, Raw> = {\n        size,\n        type: type,\n        serialize:\n            type === \"default\"\n                ? defaultFieldSerializer(\n                      serialize as DefaultFieldSerializer<Raw>,\n                  )\n                : byobFieldSerializer(\n                      size,\n                      serialize as ByobFieldSerializer<Raw>,\n                  ),\n        deserialize: bipedal(deserialize) as never,\n        omitInit: options?.omitInit,\n    };\n    if (options?.init) {\n        field.init = options.init;\n    }\n    return field;\n}\n\nexport const field = _field;\n", "import type {\n    BipedalFieldDeserializer,\n    ByobFieldSerializer,\n    Field,\n} from \"./field/index.js\";\nimport { field } from \"./field/index.js\";\n\nexport const EmptyUint8Array = new Uint8Array(0);\n\nfunction copyMaybeDifferentLength(\n    dest: Uint8Array,\n    source: Uint8Array,\n    index: number,\n    length: number,\n) {\n    if (source.length < length) {\n        dest.set(source, index);\n        // Clear trailing bytes\n        dest.fill(0, index + source.length, index + length);\n    } else if (source.length === length) {\n        dest.set(source, index);\n    } else {\n        dest.set(source.subarray(0, length), index);\n    }\n}\n\nexport interface Converter<From, To> {\n    convert: (value: From) => To;\n    back: (value: To) => From;\n}\n\nexport interface BufferLengthConverter<K, KT> extends Converter<KT, number> {\n    field: K;\n}\n\n/**\n * Create a fixed-length `Uint8Array` field.\n *\n * @param length Length of the field\n */\nexport function buffer(\n    length: number,\n): Field<Uint8Array, never, never, Uint8Array>;\n/**\n * Create a custom-typed field, backed by a fixed-length `Uint8Array`.\n *\n * @param length Length of the field\n * @param converter A value converter to convert between `Uint8Array` and the target type\n */\nexport function buffer<U>(\n    length: number,\n    converter: Converter<Uint8Array, U>,\n): Field<U, never, never, Uint8Array>;\n\n/**\n * Create a variable-length `Uint8Array` field.\n * The length is determined by another number-typed field.\n *\n * @param lengthField Name of the length field. Must be declared before this field\n */\nexport function buffer<K extends string>(\n    lengthField: K,\n): Field<Uint8Array, K, Record<K, number>, Uint8Array>;\n/**\n * Create a custom-typed field, backed by a variable-length `Uint8Array`.\n * The length is determined by another number-typed field.\n *\n * @param lengthField Name of the length field. Must be declared before this field\n * @param converter A value converter to convert between `Uint8Array` and the target type\n */\nexport function buffer<K extends string, U>(\n    lengthField: K,\n    converter: Converter<Uint8Array, U>,\n): Field<U, K, Record<K, number>, Uint8Array>;\n\n/**\n * Create a variable-length `Uint8Array` field.\n * The length is determined by converting another field to `number`.\n *\n * @param length\n * Name of the length field,\n * and a converter to convert between source type and `number`.\n * Must be declared before this field\n */\nexport function buffer<K extends string, KT>(\n    length: BufferLengthConverter<K, KT>,\n): Field<Uint8Array, K, Record<K, KT>, Uint8Array>;\n/**\n * Create a custom-typed field, backed by a variable-length `Uint8Array`.\n * The length is determined by converting another field to `number`.\n *\n * @param length\n * Name of the length field,\n * and a converter to convert between source type and `number`.\n * Must be declared before this field\n * @param converter\n * A value converter to convert between `Uint8Array` and the target type\n */\nexport function buffer<K extends string, KT, U>(\n    length: BufferLengthConverter<K, KT>,\n    converter: Converter<Uint8Array, U>,\n): Field<U, K, Record<K, KT>, Uint8Array>;\n\n/**\n * Create a length field, and a variable-length `Uint8Array` field.\n * This is a shortcut when the length field is directly before the data field.\n *\n * @param length The length field declaration\n */\nexport function buffer<LengthOmitInit extends string, LengthDependencies>(\n    length: Field<number, LengthOmitInit, LengthDependencies, number>,\n): Field<Uint8Array, LengthOmitInit, LengthDependencies, Uint8Array>;\n/**\n * Create a length field, and a custom-typed field, backed by a variable-length `Uint8Array`.\n * This is a shortcut when the length field is directly before the data field.\n *\n * @param length The length field declaration\n * @param converter A value converter to convert between `Uint8Array` and the target type\n */\nexport function buffer<LengthOmitInit extends string, LengthDependencies, U>(\n    length: Field<number, LengthOmitInit, LengthDependencies, number>,\n    converter: Converter<Uint8Array, U>,\n): Field<U, LengthOmitInit, LengthDependencies, Uint8Array>;\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function buffer(\n    lengthOrField:\n        | string\n        | number\n        | Field<number, string, unknown, number>\n        | BufferLengthConverter<string, unknown>,\n    converter?: Converter<Uint8Array, unknown>,\n): Field<unknown, string, Record<string, unknown>, Uint8Array> {\n    // Fixed length\n    if (typeof lengthOrField === \"number\") {\n        let serialize: ByobFieldSerializer<Uint8Array>;\n        let deserialize: BipedalFieldDeserializer<\n            unknown,\n            Record<string, unknown>\n        >;\n        let init: ((value: unknown) => Uint8Array) | undefined;\n\n        if (lengthOrField === 0) {\n            serialize = () => {};\n\n            if (converter) {\n                // eslint-disable-next-line require-yield\n                deserialize = function* () {\n                    return converter.convert(EmptyUint8Array);\n                };\n            } else {\n                // eslint-disable-next-line require-yield\n                deserialize = function* () {\n                    return EmptyUint8Array;\n                };\n            }\n        } else {\n            serialize = (value, { buffer, index }) =>\n                copyMaybeDifferentLength(buffer, value, index, lengthOrField);\n\n            if (converter) {\n                deserialize = function* (then, reader) {\n                    const array = reader.readExactly(lengthOrField);\n                    return converter.convert(yield* then(array));\n                };\n                init = (value) => converter.back(value);\n            } else {\n                // eslint-disable-next-line require-yield\n                deserialize = function* (_then, reader) {\n                    const array = reader.readExactly(lengthOrField);\n                    return array;\n                };\n            }\n        }\n\n        return field(lengthOrField, \"byob\", serialize, deserialize, { init });\n    }\n\n    // Declare length field\n    // Some field types are `function`s\n    if (\n        (typeof lengthOrField === \"object\" ||\n            typeof lengthOrField === \"function\") &&\n        \"serialize\" in lengthOrField\n    ) {\n        let deserialize: BipedalFieldDeserializer<\n            unknown,\n            Record<string, unknown>\n        >;\n        let init: ((value: unknown) => Uint8Array) | undefined;\n\n        if (converter) {\n            deserialize = function* (then, reader, context) {\n                const length = yield* then(\n                    lengthOrField.deserialize(reader, context),\n                );\n                const array =\n                    length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n                return converter.convert(yield* then(array));\n            };\n            init = (value) => converter.back(value);\n        } else {\n            deserialize = function* (then, reader, context) {\n                const length = yield* then(\n                    lengthOrField.deserialize(reader, context),\n                );\n                const array =\n                    length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n                return array;\n            };\n        }\n\n        return field(\n            lengthOrField.size,\n            \"default\",\n            (value, { littleEndian }) => {\n                if (lengthOrField.type === \"default\") {\n                    const lengthBuffer = lengthOrField.serialize(value.length, {\n                        littleEndian,\n                    });\n\n                    if (value.length === 0) {\n                        return lengthBuffer;\n                    }\n\n                    const result = new Uint8Array(\n                        lengthBuffer.length + value.length,\n                    );\n                    result.set(lengthBuffer, 0);\n                    result.set(value, lengthBuffer.length);\n                    return result;\n                } else {\n                    const result = new Uint8Array(\n                        lengthOrField.size + value.length,\n                    );\n                    lengthOrField.serialize(value.length, {\n                        buffer: result,\n                        index: 0,\n                        littleEndian,\n                    });\n                    result.set(value, lengthOrField.size);\n                    return result;\n                }\n            },\n            deserialize,\n            { init },\n        );\n    }\n\n    // Reference existing length field\n    if (typeof lengthOrField === \"string\") {\n        let deserialize: BipedalFieldDeserializer<\n            unknown,\n            Record<string, unknown>\n        >;\n        let init: (\n            value: unknown,\n            dependencies: Record<string, unknown>,\n        ) => Uint8Array;\n\n        if (converter) {\n            deserialize = function* (then, reader, { dependencies }) {\n                const length = dependencies[lengthOrField] as number;\n                const array =\n                    length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n                return converter.convert(yield* then(array));\n            };\n            init = (value, dependencies) => {\n                const array = converter.back(value);\n                dependencies[lengthOrField] = array.length;\n                return array;\n            };\n        } else {\n            // eslint-disable-next-line require-yield\n            deserialize = function* (_then, reader, { dependencies }) {\n                const length = dependencies[lengthOrField] as number;\n                const array =\n                    length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n                return array;\n            };\n            init = (value, dependencies) => {\n                const array = value as Uint8Array;\n                dependencies[lengthOrField] = array.length;\n                return array;\n            };\n        }\n\n        return field(0, \"default\", (source) => source, deserialize, { init });\n    }\n\n    let deserialize: BipedalFieldDeserializer<unknown, Record<string, unknown>>;\n    let init: (\n        value: unknown,\n        dependencies: Record<string, unknown>,\n    ) => Uint8Array;\n\n    // Reference existing length field + length converter\n    if (converter) {\n        deserialize = function* (then, reader, { dependencies }) {\n            const rawLength = dependencies[lengthOrField.field];\n            const length = lengthOrField.convert(rawLength);\n            const array =\n                length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n            return converter.convert(yield* then(array));\n        };\n        init = (value, dependencies) => {\n            const array = converter.back(value);\n            dependencies[lengthOrField.field] = lengthOrField.back(\n                array.length,\n            );\n            return array;\n        };\n    } else {\n        // eslint-disable-next-line require-yield\n        deserialize = function* (_then, reader, { dependencies }) {\n            const rawLength = dependencies[lengthOrField.field];\n            const length = lengthOrField.convert(rawLength);\n            const array =\n                length !== 0 ? reader.readExactly(length) : EmptyUint8Array;\n            return array;\n        };\n        init = (value, dependencies) => {\n            const array = value as Uint8Array;\n            dependencies[lengthOrField.field] = lengthOrField.back(\n                array.length,\n            );\n            return array;\n        };\n    }\n\n    return field(0, \"default\", (source) => source, deserialize, { init });\n}\n", "// TODO: allow over reading (returning a `Uint8Array`, an `offset` and a `length`) to avoid copying\n\nimport type { MaybePromiseLike } from \"@yume-chan/async\";\n\nexport class ExactReadableEndedError extends Error {\n    constructor() {\n        super(\"ExactReadable ended\");\n    }\n}\n\nexport interface ExactReadable {\n    readonly position: number;\n\n    /**\n     * Read data from the underlying data source.\n     *\n     * The stream must return exactly `length` bytes or data. If that's not possible\n     * (due to end of file or other error condition), it must throw an {@link ExactReadableEndedError}.\n     */\n    readExactly(length: number): Uint8Array;\n}\n\nexport class Uint8ArrayExactReadable implements ExactReadable {\n    #data: Uint8Array;\n    #position: number;\n\n    get position() {\n        return this.#position;\n    }\n\n    constructor(data: Uint8Array) {\n        this.#data = data;\n        this.#position = 0;\n    }\n\n    readExactly(length: number): Uint8Array {\n        if (this.#position + length > this.#data.length) {\n            throw new ExactReadableEndedError();\n        }\n\n        const result = this.#data.subarray(\n            this.#position,\n            this.#position + length,\n        );\n\n        this.#position += length;\n        return result;\n    }\n}\n\nexport interface AsyncExactReadable {\n    readonly position: number;\n\n    /**\n     * Read data from the underlying data source.\n     *\n     * The stream must return exactly `length` bytes or data. If that's not possible\n     * (due to end of file or other error condition), it must throw an {@link ExactReadableEndedError}.\n     */\n    readExactly(length: number): MaybePromiseLike<Uint8Array>;\n}\n", "import { bipedal } from \"./bipedal.js\";\nimport type {\n    Field,\n    FieldByobSerializeContext,\n    FieldDefaultSerializeContext,\n    FieldDeserializeContext,\n    FieldDeserializer,\n} from \"./field/index.js\";\nimport type { AsyncExactReadable } from \"./readable.js\";\nimport { ExactReadableEndedError } from \"./readable.js\";\nimport type {\n    StructDeserializer,\n    StructLike,\n    StructSerializeContext,\n    StructSerializer,\n} from \"./types.js\";\n\nexport type StructField =\n    | Field<unknown, string, unknown, unknown>\n    | (StructSerializer<unknown> & StructDeserializer<unknown>);\n\nexport type StructFields = Record<string, StructField>;\n\nexport type FieldsValue<T extends StructFields> = {\n    [K in keyof T]: T[K] extends FieldDeserializer<infer U, unknown>\n        ? U\n        : never;\n};\n\nexport type FieldOmitInit<T extends StructField> =\n    T extends Field<unknown, infer U, unknown, unknown>\n        ? string extends U\n            ? never\n            : U\n        : never;\n\nexport type FieldsOmitInits<T extends StructFields> = {\n    [K in keyof T]: FieldOmitInit<T[K]>;\n}[keyof T];\n\nexport type FieldsInit<T extends StructFields> = Omit<\n    FieldsValue<T>,\n    FieldsOmitInits<T>\n>;\n\nexport class StructDeserializeError extends Error {\n    constructor(message: string) {\n        super(message);\n    }\n}\n\nexport class StructNotEnoughDataError extends StructDeserializeError {\n    constructor() {\n        super(\n            \"The underlying readable was ended before the struct was fully deserialized\",\n        );\n    }\n}\n\nexport class StructEmptyError extends StructDeserializeError {\n    constructor() {\n        super(\"The underlying readable doesn't contain any more struct\");\n    }\n}\n\nexport type ExtraToIntersection<\n    Extra extends Record<PropertyKey, unknown> | undefined,\n> = Extra extends undefined ? unknown : Extra;\n\nexport interface Struct<\n    Fields extends StructFields,\n    Extra extends Record<PropertyKey, unknown> | undefined = undefined,\n    PostDeserialize = FieldsValue<Fields> & Extra,\n> extends StructSerializer<FieldsInit<Fields>>,\n        StructDeserializer<PostDeserialize> {\n    littleEndian: boolean;\n    fields: Fields;\n    extra: Extra;\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function struct<\n    Fields extends Record<\n        string,\n        | Field<unknown, string, Partial<FieldsValue<Fields>>, unknown>\n        | StructLike<unknown>\n    >,\n    Extra extends Record<PropertyKey, unknown> | undefined = undefined,\n    PostDeserialize = FieldsValue<Fields> & ExtraToIntersection<Extra>,\n>(\n    fields: Fields,\n    options: {\n        littleEndian: boolean;\n        extra?: (Extra & ThisType<FieldsValue<Fields>>) | undefined;\n        postDeserialize?:\n            | ((\n                  this: FieldsValue<Fields> & ExtraToIntersection<Extra>,\n                  value: FieldsValue<Fields> & ExtraToIntersection<Extra>,\n              ) => PostDeserialize)\n            | undefined;\n    },\n): Struct<Fields, Extra, PostDeserialize> {\n    const fieldList = Object.entries(fields);\n\n    let size = 0;\n    let byob = true;\n    for (const [, field] of fieldList) {\n        size += field.size;\n        if (byob && field.type !== \"byob\") {\n            byob = false;\n        }\n    }\n\n    const littleEndian = options.littleEndian;\n    const extra = options.extra\n        ? Object.getOwnPropertyDescriptors(options.extra)\n        : undefined;\n\n    return {\n        littleEndian,\n        fields,\n        extra: options.extra,\n\n        type: byob ? \"byob\" : \"default\",\n        size,\n        serialize(\n            source: FieldsInit<Fields>,\n            bufferOrContext?: Uint8Array | StructSerializeContext,\n        ): Uint8Array | number {\n            const temp: Record<string, unknown> = { ...source };\n\n            for (const [key, field] of fieldList) {\n                if (key in temp && \"init\" in field) {\n                    const result = field.init?.(temp[key], temp as never);\n                    temp[key] = result;\n                }\n            }\n\n            const sizes = new Array<number>(fieldList.length);\n            const buffers = new Array<Uint8Array | undefined>(fieldList.length);\n            {\n                const context: FieldDefaultSerializeContext = { littleEndian };\n                for (const [index, [key, field]] of fieldList.entries()) {\n                    if (field.type === \"byob\") {\n                        sizes[index] = field.size;\n                    } else {\n                        buffers[index] = field.serialize(temp[key], context);\n                        sizes[index] = buffers[index].length;\n                    }\n                }\n            }\n\n            const size = sizes.reduce((sum, size) => sum + size, 0);\n\n            let externalBuffer: boolean;\n            let buffer: Uint8Array;\n            let index: number;\n            if (bufferOrContext instanceof Uint8Array) {\n                if (bufferOrContext.length < size) {\n                    throw new Error(\"Buffer too small\");\n                }\n                externalBuffer = true;\n                buffer = bufferOrContext;\n                index = 0;\n            } else if (\n                typeof bufferOrContext === \"object\" &&\n                \"buffer\" in bufferOrContext\n            ) {\n                externalBuffer = true;\n                buffer = bufferOrContext.buffer;\n                index = bufferOrContext.index ?? 0;\n                if (buffer.length - index < size) {\n                    throw new Error(\"Buffer too small\");\n                }\n            } else {\n                externalBuffer = false;\n                buffer = new Uint8Array(size);\n                index = 0;\n            }\n\n            const context = {\n                buffer,\n                index,\n                littleEndian,\n            } satisfies FieldByobSerializeContext;\n            for (const [index, [key, field]] of fieldList.entries()) {\n                if (buffers[index]) {\n                    buffer.set(buffers[index], context.index);\n                } else {\n                    field.serialize(temp[key], context);\n                }\n                context.index += sizes[index]!;\n            }\n\n            if (externalBuffer) {\n                return size;\n            } else {\n                return buffer;\n            }\n        },\n        deserialize: bipedal(function* (\n            this: Struct<Fields, Extra, PostDeserialize>,\n            then,\n            reader: AsyncExactReadable,\n        ) {\n            const startPosition = reader.position;\n\n            const result = {} as Record<string, unknown>;\n            const context: FieldDeserializeContext<\n                Partial<FieldsValue<Fields>>\n            > = {\n                dependencies: result as never,\n                littleEndian: littleEndian,\n            };\n\n            try {\n                for (const [key, field] of fieldList) {\n                    result[key] = yield* then(\n                        field.deserialize(reader, context),\n                    );\n                }\n            } catch (e) {\n                if (!(e instanceof ExactReadableEndedError)) {\n                    throw e;\n                }\n\n                if (reader.position === startPosition) {\n                    throw new StructEmptyError();\n                } else {\n                    throw new StructNotEnoughDataError();\n                }\n            }\n\n            if (extra) {\n                Object.defineProperties(result, extra);\n            }\n\n            if (options.postDeserialize) {\n                return options.postDeserialize.call(\n                    result as never,\n                    result as never,\n                );\n            } else {\n                return result;\n            }\n        }),\n    } as never;\n}\n", "import type {\n    ExtraToIntersection,\n    FieldsValue,\n    Struct,\n    StructFields,\n} from \"./struct.js\";\nimport { struct } from \"./struct.js\";\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function extend<\n    Base extends Struct<\n        StructFields,\n        Record<PropertyKey, unknown> | undefined,\n        unknown\n    >,\n    Fields extends StructFields,\n    PostDeserialize = FieldsValue<Base[\"fields\"] & Fields> &\n        ExtraToIntersection<Base[\"extra\"]>,\n>(\n    base: Base,\n    fields: Fields,\n    options?: {\n        littleEndian?: boolean | undefined;\n        postDeserialize?: (\n            this: FieldsValue<Base[\"fields\"] & Fields> &\n                ExtraToIntersection<Base[\"extra\"]>,\n            value: FieldsValue<Base[\"fields\"] & Fields> &\n                ExtraToIntersection<Base[\"extra\"]>,\n        ) => PostDeserialize;\n    },\n): Struct<Base[\"fields\"] & Fields, Base[\"extra\"], PostDeserialize> {\n    return struct(Object.assign({}, base.fields, fields), {\n        littleEndian: options?.littleEndian ?? base.littleEndian,\n        extra: base.extra as never,\n        postDeserialize: options?.postDeserialize,\n    }) as never;\n}\n", "/* #__NO_SIDE_EFFECTS__ */\nexport function getInt16LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n): number {\n    return ((buffer[offset]! | (buffer[offset + 1]! << 8)) << 16) >> 16;\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getInt16BigEndian(buffer: Uint8Array, offset: number): number {\n    return (((buffer[offset]! << 8) | buffer[offset + 1]!) << 16) >> 16;\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getInt16(\n    buffer: Uint8Array,\n    offset: number,\n    littleEndian: boolean,\n) {\n    return littleEndian\n        ? ((buffer[offset]! | (buffer[offset + 1]! << 8)) << 16) >> 16\n        : (((buffer[offset]! << 8) | buffer[offset + 1]!) << 16) >> 16;\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function setInt16LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n): void {\n    buffer[offset] = value;\n    buffer[offset + 1] = value >> 8;\n}\n\nexport function setInt16BigEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n): void {\n    buffer[offset] = value >> 8;\n    buffer[offset + 1] = value;\n}\n\nexport function setInt16(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n    littleEndian: boolean,\n): void {\n    if (littleEndian) {\n        buffer[offset] = value;\n        buffer[offset + 1] = value >> 8;\n    } else {\n        buffer[offset] = value >> 8;\n        buffer[offset + 1] = value;\n    }\n}\n", "/* #__NO_SIDE_EFFECTS__ */\nexport function getInt32LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n): number {\n    return (\n        buffer[offset]! |\n        (buffer[offset + 1]! << 8) |\n        (buffer[offset + 2]! << 16) |\n        (buffer[offset + 3]! << 24)\n    );\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getInt32BigEndian(buffer: Uint8Array, offset: number): number {\n    return (\n        (buffer[offset]! << 24) |\n        (buffer[offset + 1]! << 16) |\n        (buffer[offset + 2]! << 8) |\n        buffer[offset + 3]!\n    );\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getInt32(\n    buffer: Uint8Array,\n    offset: number,\n    littleEndian: boolean,\n) {\n    return littleEndian\n        ? buffer[offset]! |\n              (buffer[offset + 1]! << 8) |\n              (buffer[offset + 2]! << 16) |\n              (buffer[offset + 3]! << 24)\n        : (buffer[offset]! << 24) |\n              (buffer[offset + 1]! << 16) |\n              (buffer[offset + 2]! << 8) |\n              buffer[offset + 3]!;\n}\n\nexport function setInt32LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n) {\n    buffer[offset] = value;\n    buffer[offset + 1] = value >> 8;\n    buffer[offset + 2] = value >> 16;\n    buffer[offset + 3] = value >> 24;\n}\n\nexport function setInt32BigEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n) {\n    buffer[offset] = value >> 24;\n    buffer[offset + 1] = value >> 16;\n    buffer[offset + 2] = value >> 8;\n    buffer[offset + 3] = value;\n}\n\nexport function setInt32(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n    littleEndian: boolean,\n) {\n    if (littleEndian) {\n        buffer[offset] = value;\n        buffer[offset + 1] = value >> 8;\n        buffer[offset + 2] = value >> 16;\n        buffer[offset + 3] = value >> 24;\n    } else {\n        buffer[offset] = value >> 24;\n        buffer[offset + 1] = value >> 16;\n        buffer[offset + 2] = value >> 8;\n        buffer[offset + 3] = value;\n    }\n}\n", "/* #__NO_SIDE_EFFECTS__ */\nexport function getInt64LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n): bigint {\n    return (\n        BigInt(buffer[offset]!) |\n        (BigInt(buffer[offset + 1]!) << 8n) |\n        (BigInt(buffer[offset + 2]!) << 16n) |\n        (BigInt(buffer[offset + 3]!) << 24n) |\n        (BigInt(buffer[offset + 4]!) << 32n) |\n        (BigInt(buffer[offset + 5]!) << 40n) |\n        (BigInt(buffer[offset + 6]!) << 48n) |\n        (BigInt(buffer[offset + 7]! << 24) << 32n)\n    );\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getInt64BigEndian(buffer: Uint8Array, offset: number): bigint {\n    return (\n        (BigInt(buffer[offset]! << 24) << 32n) |\n        (BigInt(buffer[offset + 1]!) << 48n) |\n        (BigInt(buffer[offset + 2]!) << 40n) |\n        (BigInt(buffer[offset + 3]!) << 32n) |\n        (BigInt(buffer[offset + 4]!) << 24n) |\n        (BigInt(buffer[offset + 5]!) << 16n) |\n        (BigInt(buffer[offset + 6]!) << 8n) |\n        BigInt(buffer[offset + 7]!)\n    );\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getInt64(\n    buffer: Uint8Array,\n    offset: number,\n    littleEndian: boolean,\n): bigint {\n    return littleEndian\n        ? BigInt(buffer[offset]!) |\n              (BigInt(buffer[offset + 1]!) << 8n) |\n              (BigInt(buffer[offset + 2]!) << 16n) |\n              (BigInt(buffer[offset + 3]!) << 24n) |\n              (BigInt(buffer[offset + 4]!) << 32n) |\n              (BigInt(buffer[offset + 5]!) << 40n) |\n              (BigInt(buffer[offset + 6]!) << 48n) |\n              (BigInt(buffer[offset + 7]! << 24) << 32n)\n        : (BigInt(buffer[offset]! << 24) << 32n) |\n              (BigInt(buffer[offset + 1]!) << 48n) |\n              (BigInt(buffer[offset + 2]!) << 40n) |\n              (BigInt(buffer[offset + 3]!) << 32n) |\n              (BigInt(buffer[offset + 4]!) << 24n) |\n              (BigInt(buffer[offset + 5]!) << 16n) |\n              (BigInt(buffer[offset + 6]!) << 8n) |\n              BigInt(buffer[offset + 7]!);\n}\n\nexport function setInt64LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: bigint,\n): void {\n    buffer[offset] = Number(value & 0xffn);\n    buffer[offset + 1] = Number((value >> 8n) & 0xffn);\n    buffer[offset + 2] = Number((value >> 16n) & 0xffn);\n    buffer[offset + 3] = Number((value >> 24n) & 0xffn);\n    buffer[offset + 4] = Number((value >> 32n) & 0xffn);\n    buffer[offset + 5] = Number((value >> 40n) & 0xffn);\n    buffer[offset + 6] = Number((value >> 48n) & 0xffn);\n    buffer[offset + 7] = Number((value >> 56n) & 0xffn);\n}\n\nexport function setInt64BigEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: bigint,\n): void {\n    buffer[offset] = Number((value >> 56n) & 0xffn);\n    buffer[offset + 1] = Number((value >> 48n) & 0xffn);\n    buffer[offset + 2] = Number((value >> 40n) & 0xffn);\n    buffer[offset + 3] = Number((value >> 32n) & 0xffn);\n    buffer[offset + 4] = Number((value >> 24n) & 0xffn);\n    buffer[offset + 5] = Number((value >> 16n) & 0xffn);\n    buffer[offset + 6] = Number((value >> 8n) & 0xffn);\n    buffer[offset + 7] = Number(value & 0xffn);\n}\n\nexport function setInt64(\n    buffer: Uint8Array,\n    offset: number,\n    value: bigint,\n    littleEndian: boolean,\n): void {\n    if (littleEndian) {\n        buffer[offset] = Number(value & 0xffn);\n        buffer[offset + 1] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 7] = Number((value >> 56n) & 0xffn);\n    } else {\n        buffer[offset] = Number((value >> 56n) & 0xffn);\n        buffer[offset + 1] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 7] = Number(value & 0xffn);\n    }\n}\n", "/* #__NO_SIDE_EFFECTS__ */\nexport function getInt8(buffer: Uint8Array, offset: number): number {\n    return (buffer[offset]! << 24) >> 24;\n}\n", "/* #__NO_SIDE_EFFECTS__ */\nexport function getUint16LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n): number {\n    return buffer[offset]! | (buffer[offset + 1]! << 8);\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getUint16BigEndian(buffer: Uint8Array, offset: number): number {\n    return (buffer[offset]! << 8) | buffer[offset + 1]!;\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getUint16(\n    buffer: Uint8Array,\n    offset: number,\n    littleEndian: boolean,\n) {\n    return littleEndian\n        ? buffer[offset]! | (buffer[offset + 1]! << 8)\n        : buffer[offset + 1]! | (buffer[offset]! << 8);\n}\n\nexport function setUint16LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n): void {\n    buffer[offset] = value;\n    buffer[offset + 1] = value >> 8;\n}\n\nexport function setUint16BigEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n): void {\n    buffer[offset] = value >> 8;\n    buffer[offset + 1] = value;\n}\n\nexport function setUint16(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n    littleEndian: boolean,\n): void {\n    if (littleEndian) {\n        buffer[offset] = value;\n        buffer[offset + 1] = value >> 8;\n    } else {\n        buffer[offset] = value >> 8;\n        buffer[offset + 1] = value;\n    }\n}\n", "/* #__NO_SIDE_EFFECTS__ */\nexport function getUint32LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n): number {\n    return (\n        (buffer[offset]! |\n            (buffer[offset + 1]! << 8) |\n            (buffer[offset + 2]! << 16) |\n            (buffer[offset + 3]! << 24)) >>>\n        0\n    );\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getUint32BigEndian(buffer: Uint8Array, offset: number): number {\n    return (\n        ((buffer[offset]! << 24) |\n            (buffer[offset + 1]! << 16) |\n            (buffer[offset + 2]! << 8) |\n            buffer[offset + 3]!) >>>\n        0\n    );\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function getUint32(\n    buffer: Uint8Array,\n    offset: number,\n    littleEndian: boolean,\n) {\n    return littleEndian\n        ? (buffer[offset]! |\n              (buffer[offset + 1]! << 8) |\n              (buffer[offset + 2]! << 16) |\n              (buffer[offset + 3]! << 24)) >>>\n              0\n        : ((buffer[offset]! << 24) |\n              (buffer[offset + 1]! << 16) |\n              (buffer[offset + 2]! << 8) |\n              buffer[offset + 3]!) >>>\n              0;\n}\n\nexport function setUint32LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n): void {\n    buffer[offset] = value;\n    buffer[offset + 1] = value >> 8;\n    buffer[offset + 2] = value >> 16;\n    buffer[offset + 3] = value >> 24;\n}\n\nexport function setUint32BigEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n): void {\n    buffer[offset] = value >> 24;\n    buffer[offset + 1] = value >> 16;\n    buffer[offset + 2] = value >> 8;\n    buffer[offset + 3] = value;\n}\n\nexport function setUint32(\n    buffer: Uint8Array,\n    offset: number,\n    value: number,\n    littleEndian: boolean,\n): void {\n    if (littleEndian) {\n        buffer[offset] = value;\n        buffer[offset + 1] = value >> 8;\n        buffer[offset + 2] = value >> 16;\n        buffer[offset + 3] = value >> 24;\n    } else {\n        buffer[offset] = value >> 24;\n        buffer[offset + 1] = value >> 16;\n        buffer[offset + 2] = value >> 8;\n        buffer[offset + 3] = value;\n    }\n}\n", "export function getUint64LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n): bigint {\n    return (\n        BigInt(buffer[offset]!) |\n        (BigInt(buffer[offset + 1]!) << 8n) |\n        (BigInt(buffer[offset + 2]!) << 16n) |\n        (BigInt(buffer[offset + 3]!) << 24n) |\n        (BigInt(buffer[offset + 4]!) << 32n) |\n        (BigInt(buffer[offset + 5]!) << 40n) |\n        (BigInt(buffer[offset + 6]!) << 48n) |\n        (BigInt(buffer[offset + 7]!) << 56n)\n    );\n}\n\nexport function getUint64BigEndian(buffer: Uint8Array, offset: number): bigint {\n    return (\n        (BigInt(buffer[offset]!) << 56n) |\n        (BigInt(buffer[offset + 1]!) << 48n) |\n        (BigInt(buffer[offset + 2]!) << 40n) |\n        (BigInt(buffer[offset + 3]!) << 32n) |\n        (BigInt(buffer[offset + 4]!) << 24n) |\n        (BigInt(buffer[offset + 5]!) << 16n) |\n        (BigInt(buffer[offset + 6]!) << 8n) |\n        BigInt(buffer[offset + 7]!)\n    );\n}\n\nexport function getUint64(\n    buffer: Uint8Array,\n    offset: number,\n    littleEndian: boolean,\n): bigint {\n    return littleEndian\n        ? BigInt(buffer[offset]!) |\n              (BigInt(buffer[offset + 1]!) << 8n) |\n              (BigInt(buffer[offset + 2]!) << 16n) |\n              (BigInt(buffer[offset + 3]!) << 24n) |\n              (BigInt(buffer[offset + 4]!) << 32n) |\n              (BigInt(buffer[offset + 5]!) << 40n) |\n              (BigInt(buffer[offset + 6]!) << 48n) |\n              (BigInt(buffer[offset + 7]!) << 56n)\n        : (BigInt(buffer[offset]!) << 56n) |\n              (BigInt(buffer[offset + 1]!) << 48n) |\n              (BigInt(buffer[offset + 2]!) << 40n) |\n              (BigInt(buffer[offset + 3]!) << 32n) |\n              (BigInt(buffer[offset + 4]!) << 24n) |\n              (BigInt(buffer[offset + 5]!) << 16n) |\n              (BigInt(buffer[offset + 6]!) << 8n) |\n              BigInt(buffer[offset + 7]!);\n}\n\nexport function setUint64LittleEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: bigint,\n): void {\n    buffer[offset] = Number(value & 0xffn);\n    buffer[offset + 1] = Number((value >> 8n) & 0xffn);\n    buffer[offset + 2] = Number((value >> 16n) & 0xffn);\n    buffer[offset + 3] = Number((value >> 24n) & 0xffn);\n    buffer[offset + 4] = Number((value >> 32n) & 0xffn);\n    buffer[offset + 5] = Number((value >> 40n) & 0xffn);\n    buffer[offset + 6] = Number((value >> 48n) & 0xffn);\n    buffer[offset + 7] = Number((value >> 56n) & 0xffn);\n}\n\nexport function setUint64BigEndian(\n    buffer: Uint8Array,\n    offset: number,\n    value: bigint,\n): void {\n    buffer[offset] = Number((value >> 56n) & 0xffn);\n    buffer[offset + 1] = Number((value >> 48n) & 0xffn);\n    buffer[offset + 2] = Number((value >> 40n) & 0xffn);\n    buffer[offset + 3] = Number((value >> 32n) & 0xffn);\n    buffer[offset + 4] = Number((value >> 24n) & 0xffn);\n    buffer[offset + 5] = Number((value >> 16n) & 0xffn);\n    buffer[offset + 6] = Number((value >> 8n) & 0xffn);\n    buffer[offset + 7] = Number(value & 0xffn);\n}\n\nexport function setUint64(\n    buffer: Uint8Array,\n    offset: number,\n    value: bigint,\n    littleEndian: boolean,\n): void {\n    if (littleEndian) {\n        buffer[offset] = Number(value & 0xffn);\n        buffer[offset + 1] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 7] = Number((value >> 56n) & 0xffn);\n    } else {\n        buffer[offset] = Number((value >> 56n) & 0xffn);\n        buffer[offset + 1] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 7] = Number(value & 0xffn);\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport {\n    getInt16,\n    getInt32,\n    getInt64,\n    getInt8,\n    getUint16,\n    getUint32,\n    getUint64,\n    setInt16,\n    setInt32,\n    setInt64,\n    setUint16,\n    setUint32,\n    setUint64,\n} from \"@yume-chan/no-data-view\";\n\nimport type {\n    Field,\n    FieldByobSerializeContext,\n    FieldDeserializeContext,\n} from \"./field/index.js\";\nimport { field } from \"./field/index.js\";\nimport type { AsyncExactReadable } from \"./readable.js\";\n\nexport interface NumberField<T> extends Field<T, never, never, T> {\n    <const U>(infer?: U): Field<U, never, never, T>;\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nfunction number<T>(\n    size: number,\n    serialize: (\n        source: T,\n        context: FieldByobSerializeContext & { index: number },\n    ) => void,\n    deserialize: (\n        then: <U>(value: MaybePromiseLike<U>) => Iterable<unknown, U, unknown>,\n        reader: AsyncExactReadable,\n        context: FieldDeserializeContext<never>,\n    ) => Generator<unknown, T, unknown>,\n) {\n    const fn: NumberField<T> = (() => fn) as never;\n    Object.assign(fn, field(size, \"byob\", serialize, deserialize));\n    return fn;\n}\n\nexport const u8: NumberField<number> = number(\n    1,\n    (value, { buffer, index }) => {\n        buffer[index] = value;\n    },\n    function* (then, reader) {\n        const data = yield* then(reader.readExactly(1));\n        return data[0]!;\n    },\n);\n\nexport const s8: NumberField<number> = number(\n    1,\n    (value, { buffer, index }) => {\n        buffer[index] = value;\n    },\n    function* (then, reader) {\n        const data = yield* then(reader.readExactly(1));\n        return getInt8(data, 0);\n    },\n);\n\nexport const u16: NumberField<number> = number(\n    2,\n    (value, { buffer, index, littleEndian }) => {\n        setUint16(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(2));\n        return getUint16(data, 0, littleEndian);\n    },\n);\n\nexport const s16: NumberField<number> = number(\n    2,\n    (value, { buffer, index, littleEndian }) => {\n        setInt16(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(2));\n        return getInt16(data, 0, littleEndian);\n    },\n);\n\nexport const u32: NumberField<number> = number(\n    4,\n    (value, { buffer, index, littleEndian }) => {\n        setUint32(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(4));\n        return getUint32(data, 0, littleEndian);\n    },\n);\n\nexport const s32: NumberField<number> = number(\n    4,\n    (value, { buffer, index, littleEndian }) => {\n        setInt32(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(4));\n        return getInt32(data, 0, littleEndian);\n    },\n);\n\nexport const u64: NumberField<bigint> = number(\n    8,\n    (value, { buffer, index, littleEndian }) => {\n        setUint64(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(8));\n        return getUint64(data, 0, littleEndian);\n    },\n);\n\nexport const s64: NumberField<bigint> = number(\n    8,\n    (value, { buffer, index, littleEndian }) => {\n        setInt64(buffer, index, value, littleEndian);\n    },\n    function* (then, reader, { littleEndian }) {\n        const data = yield* then(reader.readExactly(8));\n        return getInt64(data, 0, littleEndian);\n    },\n);\n", "// This library can't use `@types/node` or `lib: dom`\n// because they will pollute the global scope\n// So `TextEncoder` and `TextDecoder` types are not available\n\n// Node.js 8.3 ships `TextEncoder` and `TextDecoder` in `util` module.\n// But using top level await to load them requires Node.js 14.1.\n// So there is no point to do that. Let's just assume they exist in global.\n\ninterface TextEncoder {\n    encode(input: string): Uint8Array;\n}\n\ninterface TextDecoder {\n    decode(\n        buffer?: ArrayBufferView | ArrayBuffer,\n        options?: { stream?: boolean },\n    ): string;\n}\n\ninterface GlobalExtension {\n    TextEncoder: new () => TextEncoder;\n    TextDecoder: new () => TextDecoder;\n}\n\nexport const { TextEncoder, TextDecoder } =\n    globalThis as unknown as GlobalExtension;\n\nconst SharedEncoder = /* #__PURE__ */ new TextEncoder();\nconst SharedDecoder = /* #__PURE__ */ new TextDecoder();\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function encodeUtf8(input: string): Uint8Array {\n    return SharedEncoder.encode(input);\n}\n\n/* #__NO_SIDE_EFFECTS__ */\nexport function decodeUtf8(buffer: ArrayBufferView | ArrayBuffer): string {\n    // `TextDecoder` has internal states in stream mode,\n    // but this method is not for stream mode, so the instance can be reused\n    return SharedDecoder.decode(buffer);\n}\n", "import type { BufferLengthConverter } from \"./buffer.js\";\nimport { buffer } from \"./buffer.js\";\nimport type { Field } from \"./field/index.js\";\nimport { decodeUtf8, encodeUtf8 } from \"./utils.js\";\n\nexport interface String {\n    (length: number): Field<string, never, never> & {\n        as: <T>(infer: T) => Field<T, never, never>;\n    };\n\n    <K extends string>(\n        lengthField: K,\n    ): Field<string, K, Record<K, number>> & {\n        as: <T>(infer: T) => Field<T, K, Record<K, number>>;\n    };\n\n    <const K extends string, KT>(\n        length: BufferLengthConverter<K, KT>,\n    ): Field<string, K, Record<K, KT>> & {\n        as: <T>(infer: T) => Field<T, K, Record<K, KT>>;\n    };\n\n    <KOmitInit extends string, KS>(\n        length: Field<number, KOmitInit, KS>,\n    ): Field<string, KOmitInit, KS>;\n}\n\n// Prettier will move the annotation and make it invalid\n// prettier-ignore\nexport const string: String = (/* #__NO_SIDE_EFFECTS__ */ (\n    lengthOrField: string | number | BufferLengthConverter<string, unknown>,\n): Field<string, string, Record<string, unknown>> & {\n    as: <T>(infer: T) => Field<T, string, Record<string, unknown>>;\n} => {\n    const field = buffer(lengthOrField as never, {\n        convert: decodeUtf8,\n        back: encodeUtf8,\n    });\n    (field as never as { as: unknown }).as = () => field;\n    return field as never;\n}) as never;\n", "import type {\n    AbortSignal,\n    ReadableStreamIteratorOptions,\n    ReadableStream as ReadableStreamType,\n    TransformStream as TransformStreamType,\n    WritableStream as WritableStreamType,\n} from \"./types.js\";\n\nexport * from \"./types.js\";\nexport { ReadableStream };\n\n/** A controller object that allows you to abort one or more DOM requests as and when desired. */\nexport interface AbortController {\n    /**\n     * Returns the AbortSignal object associated with this object.\n     */\n    readonly signal: AbortSignal;\n\n    /**\n     * Invoking this method will set this object's AbortSignal's aborted flag and signal to any observers that the associated activity is to be aborted.\n     */\n    abort(reason?: unknown): void;\n}\n\ninterface AbortControllerConstructor {\n    prototype: AbortController;\n    new (): AbortController;\n}\n\ninterface GlobalExtension {\n    AbortController: AbortControllerConstructor;\n    ReadableStream: typeof ReadableStreamType;\n    WritableStream: typeof WritableStreamType;\n    TransformStream: typeof TransformStreamType;\n}\n\nexport const { AbortController } = globalThis as unknown as GlobalExtension;\n\nexport type ReadableStream<T> = ReadableStreamType<T>;\nexport type WritableStream<T> = WritableStreamType<T>;\nexport type TransformStream<I, O> = TransformStreamType<I, O>;\n\nconst ReadableStream = /* #__PURE__ */ (() => {\n    const { ReadableStream } = globalThis as unknown as GlobalExtension;\n\n    if (!ReadableStream.from) {\n        ReadableStream.from = function (iterable) {\n            const iterator =\n                Symbol.asyncIterator in iterable\n                    ? iterable[Symbol.asyncIterator]()\n                    : iterable[Symbol.iterator]();\n\n            return new ReadableStream({\n                async pull(controller) {\n                    const result = await iterator.next();\n                    if (result.done) {\n                        controller.close();\n                        return;\n                    }\n                    controller.enqueue(result.value);\n                },\n                async cancel(reason) {\n                    await iterator.return?.(reason);\n                },\n            });\n        };\n    }\n\n    if (\n        !ReadableStream.prototype[Symbol.asyncIterator] ||\n        !ReadableStream.prototype.values\n    ) {\n        ReadableStream.prototype.values = async function* <R>(\n            this: ReadableStream<R>,\n            options?: ReadableStreamIteratorOptions,\n        ) {\n            const reader = this.getReader();\n            try {\n                while (true) {\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        return;\n                    }\n                    yield value;\n                }\n            } finally {\n                // Calling `iterator.return` will enter this `finally` block.\n                // We don't need to care about the parameter to `iterator.return`,\n                // it will be returned as the final `result.value` automatically.\n                if (!options?.preventCancel) {\n                    await reader.cancel();\n                }\n                reader.releaseLock();\n            }\n        };\n\n        ReadableStream.prototype[Symbol.asyncIterator] =\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            ReadableStream.prototype.values;\n    }\n\n    return ReadableStream;\n})();\n\nexport const { WritableStream, TransformStream } =\n    globalThis as unknown as GlobalExtension;\n", "import { PromiseResolver } from \"@yume-chan/async\";\n\nimport type { AbortSignal, QueuingStrategy } from \"./stream.js\";\nimport { AbortController, ReadableStream } from \"./stream.js\";\n\nexport interface PushReadableStreamController<T> {\n    abortSignal: AbortSignal;\n\n    enqueue(chunk: T): Promise<void>;\n\n    close(): void;\n\n    error(e?: unknown): void;\n}\n\nexport type PushReadableStreamSource<T> = (\n    controller: PushReadableStreamController<T>,\n) => void | Promise<void>;\n\nexport type PushReadableLogger<T> = (\n    event:\n        | {\n              source: \"producer\";\n              operation: \"enqueue\";\n              value: T;\n              phase: \"start\" | \"waiting\" | \"ignored\" | \"complete\";\n          }\n        | {\n              source: \"producer\";\n              operation: \"close\" | \"error\";\n              explicit: boolean;\n              phase: \"start\" | \"ignored\" | \"complete\";\n          }\n        | {\n              source: \"consumer\";\n              operation: \"pull\" | \"cancel\";\n              phase: \"start\" | \"complete\";\n          },\n) => void;\n\nexport class PushReadableStream<T> extends ReadableStream<T> {\n    /**\n     * Create a new `PushReadableStream` from a source.\n     *\n     * @param source If `source` returns a `Promise`, the stream will be closed\n     * when the `Promise` is resolved, and be errored when the `Promise` is rejected.\n     * @param strategy\n     */\n    constructor(\n        source: PushReadableStreamSource<T>,\n        strategy?: QueuingStrategy<T>,\n        logger?: PushReadableLogger<T>,\n    ) {\n        let waterMarkLow: PromiseResolver<void> | undefined;\n        let zeroHighWaterMarkAllowEnqueue = false;\n        const abortController = new AbortController();\n\n        super(\n            {\n                start: (controller) => {\n                    const result = source({\n                        abortSignal: abortController.signal,\n                        enqueue: async (chunk) => {\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"enqueue\",\n                                value: chunk,\n                                phase: \"start\",\n                            });\n\n                            if (abortController.signal.aborted) {\n                                // In original `ReadableStream`, calling `enqueue` or `close`\n                                // on an cancelled stream will throw an error,\n                                //\n                                // But in `PushReadableStream`, `enqueue` is an async function,\n                                // the producer can't just check `abortSignal.aborted`\n                                // before calling `enqueue`, as it might change when waiting\n                                // for the backpressure to be reduced.\n                                //\n                                // So IMO it's better to handle this for the producer\n                                // by simply ignoring the `enqueue` call.\n                                //\n                                // Note that we check `abortSignal.aborted` instead of `stopped`,\n                                // as it's not allowed for the producer to call `enqueue` after\n                                // they called `close` or `error`.\n                                //\n                                // Obviously, the producer should listen to the `abortSignal` and\n                                // stop producing, but most pushing data sources don't support that.\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"enqueue\",\n                                    value: chunk,\n                                    phase: \"ignored\",\n                                });\n                                return;\n                            }\n\n                            if (controller.desiredSize === null) {\n                                // `desiredSize` being `null` means the stream is in error state,\n                                // `controller.enqueue` will throw an error for us.\n                                controller.enqueue(chunk);\n                                // istanbul ignore next\n                                return;\n                            }\n\n                            if (zeroHighWaterMarkAllowEnqueue) {\n                                // When `highWaterMark` is set to `0`,\n                                // `controller.desiredSize` will always be `0`,\n                                // even if the consumer has called `reader.read()`.\n                                // (in this case, each `reader.read()`/`pull`\n                                // should allow one `enqueue` of any size)\n                                //\n                                // If the consumer has already called `reader.read()`,\n                                // before the producer tries to `enqueue`,\n                                // `controller.desiredSize` is `0` and normal `waterMarkLow` signal\n                                // will never trigger,\n                                // (because `ReadableStream` prevents reentrance of `pull`)\n                                // The stream will stuck.\n                                //\n                                // So we need a special signal for this case.\n                                zeroHighWaterMarkAllowEnqueue = false;\n                                controller.enqueue(chunk);\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"enqueue\",\n                                    value: chunk,\n                                    phase: \"complete\",\n                                });\n                                return;\n                            }\n\n                            if (controller.desiredSize <= 0) {\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"enqueue\",\n                                    value: chunk,\n                                    phase: \"waiting\",\n                                });\n\n                                waterMarkLow = new PromiseResolver<void>();\n                                await waterMarkLow.promise;\n\n                                // Recheck consumer cancellation after async operations.\n                                if (abortController.signal.aborted) {\n                                    logger?.({\n                                        source: \"producer\",\n                                        operation: \"enqueue\",\n                                        value: chunk,\n                                        phase: \"ignored\",\n                                    });\n                                    return;\n                                }\n                            }\n\n                            controller.enqueue(chunk);\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"enqueue\",\n                                value: chunk,\n                                phase: \"complete\",\n                            });\n                        },\n                        close() {\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"close\",\n                                explicit: true,\n                                phase: \"start\",\n                            });\n\n                            // Since `enqueue` on an cancelled stream won't throw an error,\n                            // so does `close`.\n                            if (abortController.signal.aborted) {\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"close\",\n                                    explicit: true,\n                                    phase: \"ignored\",\n                                });\n                                return;\n                            }\n\n                            controller.close();\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"close\",\n                                explicit: true,\n                                phase: \"complete\",\n                            });\n                        },\n                        error(e) {\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"error\",\n                                explicit: true,\n                                phase: \"start\",\n                            });\n\n                            // Calling `error` on an already closed or errored stream is a no-op.\n                            controller.error(e);\n\n                            logger?.({\n                                source: \"producer\",\n                                operation: \"error\",\n                                explicit: true,\n                                phase: \"complete\",\n                            });\n                        },\n                    });\n\n                    if (result && \"then\" in result) {\n                        // If `source` returns a `Promise`,\n                        // close the stream when the `Promise` is resolved,\n                        // and error the stream when the `Promise` is rejected.\n                        // The producer can return a never-settling `Promise`\n                        // to disable this behavior.\n                        result.then(\n                            () => {\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"close\",\n                                    explicit: false,\n                                    phase: \"start\",\n                                });\n\n                                try {\n                                    controller.close();\n\n                                    logger?.({\n                                        source: \"producer\",\n                                        operation: \"close\",\n                                        explicit: false,\n                                        phase: \"complete\",\n                                    });\n                                } catch {\n                                    logger?.({\n                                        source: \"producer\",\n                                        operation: \"close\",\n                                        explicit: false,\n                                        phase: \"ignored\",\n                                    });\n\n                                    // The stream is already closed by the producer,\n                                    // Or cancelled by the consumer.\n                                }\n                            },\n                            (e) => {\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"error\",\n                                    explicit: false,\n                                    phase: \"start\",\n                                });\n\n                                controller.error(e);\n\n                                logger?.({\n                                    source: \"producer\",\n                                    operation: \"error\",\n                                    explicit: false,\n                                    phase: \"complete\",\n                                });\n                            },\n                        );\n                    }\n                },\n                pull: () => {\n                    logger?.({\n                        source: \"consumer\",\n                        operation: \"pull\",\n                        phase: \"start\",\n                    });\n\n                    if (waterMarkLow) {\n                        waterMarkLow.resolve();\n                    } else if (strategy?.highWaterMark === 0) {\n                        zeroHighWaterMarkAllowEnqueue = true;\n                    }\n\n                    logger?.({\n                        source: \"consumer\",\n                        operation: \"pull\",\n                        phase: \"complete\",\n                    });\n                },\n                cancel: (reason) => {\n                    logger?.({\n                        source: \"consumer\",\n                        operation: \"cancel\",\n                        phase: \"start\",\n                    });\n\n                    abortController.abort(reason);\n                    // Resolve it on cancellation. `pull` will check `abortSignal.aborted` again.\n                    waterMarkLow?.resolve();\n\n                    logger?.({\n                        source: \"consumer\",\n                        operation: \"cancel\",\n                        phase: \"complete\",\n                    });\n                },\n            },\n            strategy,\n        );\n    }\n}\n", "import type { BufferedReadableStream } from \"./buffered.js\";\nimport type { PushReadableStreamController } from \"./push-readable.js\";\nimport type {\n    ReadableStream,\n    ReadableStreamDefaultController,\n    ReadableStreamDefaultReader,\n    WritableStreamDefaultWriter,\n} from \"./stream.js\";\n\nexport function tryClose(\n    controller: PushReadableStreamController<unknown>,\n): boolean;\nexport function tryClose(\n    controller: ReadableStreamDefaultController<unknown>,\n): boolean;\nexport function tryClose(writer: WritableStreamDefaultWriter<never>): boolean;\nexport function tryClose(controller: { close(): void }) {\n    try {\n        controller.close();\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nexport async function tryCancel(\n    stream: ReadableStream<unknown>,\n): Promise<boolean>;\nexport async function tryCancel(\n    stream: BufferedReadableStream,\n): Promise<boolean>;\nexport async function tryCancel(\n    reader: ReadableStreamDefaultReader<unknown>,\n): Promise<boolean>;\nexport async function tryCancel(stream: {\n    cancel(): Promise<void>;\n}): Promise<boolean> {\n    try {\n        await stream.cancel();\n        return true;\n    } catch {\n        return false;\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport type { AsyncExactReadable } from \"@yume-chan/struct\";\nimport { bipedal, ExactReadableEndedError } from \"@yume-chan/struct\";\n\nimport { PushReadableStream } from \"./push-readable.js\";\nimport type { ReadableStream, ReadableStreamDefaultReader } from \"./stream.js\";\nimport { tryCancel } from \"./try-close.js\";\n\nexport class BufferedReadableStream implements AsyncExactReadable {\n    #buffered: Uint8Array | undefined;\n    // PERF: `subarray` is slow\n    // don't use it until absolutely necessary\n    #bufferedOffset = 0;\n    #bufferedLength = 0;\n\n    #position = 0;\n    get position() {\n        return this.#position;\n    }\n\n    protected readonly stream: ReadableStream<Uint8Array>;\n    protected readonly reader: ReadableStreamDefaultReader<Uint8Array>;\n\n    constructor(stream: ReadableStream<Uint8Array>) {\n        this.stream = stream;\n        this.reader = stream.getReader();\n    }\n\n    #readBuffered(length: number) {\n        if (!this.#buffered) {\n            return undefined;\n        }\n\n        const value = this.#buffered.subarray(\n            this.#bufferedOffset,\n            this.#bufferedOffset + length,\n        );\n\n        // PERF: Synchronous path for reading from internal buffer\n        if (this.#bufferedLength > length) {\n            this.#position += length;\n            this.#bufferedOffset += length;\n            this.#bufferedLength -= length;\n            return value;\n        }\n\n        this.#position += this.#bufferedLength;\n        this.#buffered = undefined;\n        this.#bufferedOffset = 0;\n        this.#bufferedLength = 0;\n        return value;\n    }\n\n    async #readSource(length: number): Promise<Uint8Array> {\n        const { done, value } = await this.reader.read();\n        if (done) {\n            throw new ExactReadableEndedError();\n        }\n\n        if (value.length > length) {\n            this.#buffered = value;\n            this.#bufferedOffset = length;\n            this.#bufferedLength = value.length - length;\n            this.#position += length;\n            return value.subarray(0, length);\n        }\n\n        this.#position += value.length;\n        return value;\n    }\n\n    iterateExactly(\n        length: number,\n    ): Iterator<MaybePromiseLike<Uint8Array>, void, void> {\n        let state = this.#buffered ? 0 : 1;\n        return {\n            next: () => {\n                switch (state) {\n                    case 0: {\n                        const value = this.#readBuffered(length)!;\n                        if (value.length === length) {\n                            state = 2;\n                        } else {\n                            length -= value.length;\n                            state = 1;\n                        }\n                        return { done: false, value };\n                    }\n                    case 1:\n                        state = 3;\n                        return {\n                            done: false,\n                            value: this.#readSource(length).then((value) => {\n                                if (value.length === length) {\n                                    state = 2;\n                                } else {\n                                    length -= value.length;\n                                    state = 1;\n                                }\n                                return value;\n                            }),\n                        };\n                    case 2:\n                        return { done: true, value: undefined };\n                    case 3:\n                        throw new Error(\n                            \"Can't call `next` before previous Promise resolves\",\n                        );\n                    default:\n                        throw new Error(\"unreachable\");\n                }\n            },\n        };\n    }\n\n    readExactly = bipedal(function* (\n        this: BufferedReadableStream,\n        then,\n        length: number,\n    ) {\n        let result: Uint8Array | undefined;\n        let index = 0;\n\n        const initial = this.#readBuffered(length);\n        if (initial) {\n            if (initial.length === length) {\n                return initial;\n            }\n\n            result = new Uint8Array(length);\n            result.set(initial, index);\n            index += initial.length;\n            length -= initial.length;\n        } else {\n            result = new Uint8Array(length);\n        }\n\n        while (length > 0) {\n            const value = yield* then(this.#readSource(length));\n            result.set(value, index);\n            index += value.length;\n            length -= value.length;\n        }\n\n        return result;\n    });\n\n    /**\n     * Return a readable stream with unconsumed data (if any) and\n     * all data from the wrapped stream.\n     * @returns A `ReadableStream`\n     */\n    release(): ReadableStream<Uint8Array> {\n        if (this.#bufferedLength > 0) {\n            return new PushReadableStream<Uint8Array>(async (controller) => {\n                // Put the remaining data back to the stream\n                const buffered = this.#buffered!.subarray(this.#bufferedOffset);\n                await controller.enqueue(buffered);\n\n                controller.abortSignal.addEventListener(\"abort\", () => {\n                    void tryCancel(this.reader);\n                });\n\n                // Manually pipe the stream\n                while (true) {\n                    const { done, value } = await this.reader.read();\n                    if (done) {\n                        return;\n                    }\n\n                    await controller.enqueue(value);\n                }\n            });\n        } else {\n            // Simply release the reader and return the stream\n            this.reader.releaseLock();\n            return this.stream;\n        }\n    }\n\n    async cancel(reason?: unknown) {\n        await this.reader.cancel(reason);\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { StructEmptyError } from \"@yume-chan/struct\";\n\nimport { BufferedReadableStream } from \"./buffered.js\";\nimport type { PushReadableStreamController } from \"./push-readable.js\";\nimport { PushReadableStream } from \"./push-readable.js\";\nimport type {\n    ReadableWritablePair,\n    WritableStreamDefaultController,\n} from \"./stream.js\";\nimport { ReadableStream, WritableStream } from \"./stream.js\";\n\n// TODO: BufferedTransformStream: find better implementation\nexport class BufferedTransformStream<T>\n    implements ReadableWritablePair<T, Uint8Array>\n{\n    #readable: ReadableStream<T>;\n    get readable() {\n        return this.#readable;\n    }\n\n    #writable: WritableStream<Uint8Array>;\n    get writable() {\n        return this.#writable;\n    }\n\n    constructor(\n        transform: (stream: BufferedReadableStream) => MaybePromiseLike<T>,\n    ) {\n        // Convert incoming chunks to a `BufferedReadableStream`\n        let bufferedStreamController!: PushReadableStreamController<Uint8Array>;\n\n        let writableStreamController!: WritableStreamDefaultController;\n\n        const buffered = new BufferedReadableStream(\n            new PushReadableStream<Uint8Array>((controller) => {\n                bufferedStreamController = controller;\n            }),\n        );\n\n        this.#readable = new ReadableStream<T>({\n            async pull(controller) {\n                try {\n                    const value = await transform(buffered);\n                    controller.enqueue(value);\n                } catch (e) {\n                    // Treat `StructEmptyError` as a normal end.\n                    // If the `transform` method doesn't have enough data to return a value,\n                    // it should throw another error to indicate that.\n                    if (e instanceof StructEmptyError) {\n                        controller.close();\n                        return;\n                    }\n                    throw e;\n                }\n            },\n            cancel: (reason) => {\n                // If a `ReadableStream` is piping into `#writable`,\n                // This will cancel the `ReadableStream` immediately.\n                // If upstream is writing using `#writable`'s writer, this will\n                // throw errors for any future writes\n                return writableStreamController.error(reason);\n            },\n        });\n\n        this.#writable = new WritableStream({\n            start(controller) {\n                writableStreamController = controller;\n            },\n            async write(chunk) {\n                await bufferedStreamController.enqueue(chunk);\n            },\n            abort() {\n                bufferedStreamController.close();\n            },\n            close() {\n                bufferedStreamController.close();\n            },\n        });\n    }\n}\n", "import { PromiseResolver } from \"@yume-chan/async\";\nimport { EmptyUint8Array } from \"@yume-chan/struct\";\n\nimport type { ReadableStreamDefaultController } from \"./stream.js\";\nimport { ReadableStream, WritableStream } from \"./stream.js\";\n\nexport interface ConcatStringReadableStream\n    extends ReadableStream<string>,\n        Promise<string> {}\n\n// `TransformStream` only calls its `source.flush` method when its `readable` is being read.\n// If the user want to use the `Promise` interface, the `flush` method will never be called,\n// so the `PromiseResolver` will never be resolved.\n// Thus we need to implement our own `TransformStream` using a `WritableStream` and a `ReadableStream`.\n\n/**\n * A `TransformStream` that concatenates strings.\n *\n * Its `readable` is also a `Promise<string>`, so it's possible to `await` it to get the result.\n *\n * ```ts\n * const result: string = await readable.pipeThrough(new ConcatStringStream());\n * ```\n */\nexport class ConcatStringStream {\n    // PERF: rope (concat strings) is faster than `[].join('')`\n    #result = \"\";\n\n    #resolver = new PromiseResolver<string>();\n\n    #writable = new WritableStream<string>({\n        write: (chunk) => {\n            this.#result += chunk;\n        },\n        close: () => {\n            this.#resolver.resolve(this.#result);\n            this.#readableController.enqueue(this.#result);\n            this.#readableController.close();\n        },\n        abort: (reason) => {\n            this.#resolver.reject(reason);\n            this.#readableController.error(reason);\n        },\n    });\n    get writable(): WritableStream<string> {\n        return this.#writable;\n    }\n\n    #readableController!: ReadableStreamDefaultController<string>;\n    #readable = new ReadableStream<string>({\n        start: (controller) => {\n            this.#readableController = controller;\n        },\n    }) as ConcatStringReadableStream;\n    get readable(): ConcatStringReadableStream {\n        return this.#readable;\n    }\n\n    constructor() {\n        void Object.defineProperties(this.#readable, {\n            then: {\n                get: () =>\n                    this.#resolver.promise.then.bind(this.#resolver.promise),\n            },\n            catch: {\n                get: () =>\n                    this.#resolver.promise.catch.bind(this.#resolver.promise),\n            },\n            finally: {\n                get: () =>\n                    this.#resolver.promise.finally.bind(this.#resolver.promise),\n            },\n        });\n    }\n}\n\nexport interface ConcatBufferReadableStream\n    extends ReadableStream<Uint8Array>,\n        Promise<Uint8Array> {}\n\n/**\n * A `TransformStream` that concatenates `Uint8Array`s.\n *\n * If you want to decode the result as string,\n * prefer `.pipeThrough(new TextDecoderStream()).pipeThrough(new ConcatStringStream())`,\n * than `.pipeThough(new ConcatBufferStream()).pipeThrough(new TextDecoderStream())`,\n * because of JavaScript engine optimizations,\n * concatenating strings is faster than concatenating `Uint8Array`s.\n */\nexport class ConcatBufferStream {\n    #segments: Uint8Array[] = [];\n\n    #resolver = new PromiseResolver<Uint8Array>();\n\n    #writable = new WritableStream<Uint8Array>({\n        write: (chunk) => {\n            this.#segments.push(chunk);\n        },\n        close: () => {\n            let result: Uint8Array;\n            let offset = 0;\n            switch (this.#segments.length) {\n                case 0:\n                    result = EmptyUint8Array;\n                    break;\n                case 1:\n                    result = this.#segments[0]!;\n                    break;\n                default:\n                    result = new Uint8Array(\n                        this.#segments.reduce(\n                            (prev, item) => prev + item.length,\n                            0,\n                        ),\n                    );\n                    for (const segment of this.#segments) {\n                        result.set(segment, offset);\n                        offset += segment.length;\n                    }\n                    break;\n            }\n\n            this.#resolver.resolve(result);\n            this.#readableController.enqueue(result);\n            this.#readableController.close();\n        },\n        abort: (reason) => {\n            this.#resolver.reject(reason);\n            this.#readableController.error(reason);\n        },\n    });\n    get writable(): WritableStream<Uint8Array> {\n        return this.#writable;\n    }\n\n    #readableController!: ReadableStreamDefaultController<Uint8Array>;\n    #readable = new ReadableStream<Uint8Array>({\n        start: (controller) => {\n            this.#readableController = controller;\n        },\n    }) as ConcatBufferReadableStream;\n    get readable(): ConcatBufferReadableStream {\n        return this.#readable;\n    }\n\n    constructor() {\n        void Object.defineProperties(this.#readable, {\n            then: {\n                get: () =>\n                    this.#resolver.promise.then.bind(this.#resolver.promise),\n            },\n            catch: {\n                get: () =>\n                    this.#resolver.promise.catch.bind(this.#resolver.promise),\n            },\n            finally: {\n                get: () =>\n                    this.#resolver.promise.finally.bind(this.#resolver.promise),\n            },\n        });\n    }\n}\n", "import { Consumable } from \"../consumable.js\";\nimport type { QueuingStrategy } from \"../stream.js\";\nimport { ReadableStream } from \"../stream.js\";\n\nexport interface ConsumableReadableStreamController<T> {\n    enqueue(chunk: T): Promise<void>;\n    close(): void;\n    error(reason: unknown): void;\n}\n\nexport interface ConsumableReadableStreamSource<T> {\n    start?(\n        controller: ConsumableReadableStreamController<T>,\n    ): void | PromiseLike<void>;\n    pull?(\n        controller: ConsumableReadableStreamController<T>,\n    ): void | PromiseLike<void>;\n    cancel?(reason: unknown): void | PromiseLike<void>;\n}\n\nexport class ConsumableReadableStream<T> extends ReadableStream<Consumable<T>> {\n    static async enqueue<T>(\n        controller: { enqueue: (chunk: Consumable<T>) => void },\n        chunk: T,\n    ) {\n        const output = new Consumable(chunk);\n        controller.enqueue(output);\n        await output.consumed;\n    }\n\n    constructor(\n        source: ConsumableReadableStreamSource<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        let wrappedController!: ConsumableReadableStreamController<T>;\n\n        let wrappedStrategy: QueuingStrategy<Consumable<T>> | undefined;\n        if (strategy) {\n            wrappedStrategy = {};\n            if (\"highWaterMark\" in strategy) {\n                wrappedStrategy.highWaterMark = strategy.highWaterMark;\n            }\n            if (\"size\" in strategy) {\n                wrappedStrategy.size = (chunk) => {\n                    return strategy.size!(chunk.value);\n                };\n            }\n        }\n\n        super(\n            {\n                start(controller) {\n                    wrappedController = {\n                        enqueue(chunk) {\n                            return ConsumableReadableStream.enqueue(\n                                controller,\n                                chunk,\n                            );\n                        },\n                        close() {\n                            controller.close();\n                        },\n                        error(reason) {\n                            controller.error(reason);\n                        },\n                    };\n\n                    return source.start?.(wrappedController);\n                },\n                pull() {\n                    return source.pull?.(wrappedController);\n                },\n                cancel(reason) {\n                    return source.cancel?.(reason);\n                },\n            },\n            wrappedStrategy,\n        );\n    }\n}\n", "import type { Consumable } from \"../consumable.js\";\nimport { ReadableStream } from \"../stream.js\";\n\nimport { ConsumableReadableStream } from \"./readable.js\";\n\nexport class ConsumableWrapByteReadableStream extends ReadableStream<\n    Consumable<Uint8Array>\n> {\n    constructor(\n        stream: ReadableStream<Uint8Array>,\n        chunkSize: number,\n        min?: number,\n    ) {\n        const reader = stream.getReader({ mode: \"byob\" });\n        let array = new Uint8Array(chunkSize);\n        super({\n            async pull(controller) {\n                const { done, value } = await reader.read(array, { min });\n                if (done) {\n                    controller.close();\n                    return;\n                }\n\n                await ConsumableReadableStream.enqueue(controller, value);\n\n                array = new Uint8Array(value.buffer);\n            },\n            cancel(reason) {\n                return reader.cancel(reason);\n            },\n        });\n    }\n}\n", "import type { Consumable } from \"../consumable.js\";\nimport { WritableStream } from \"../stream.js\";\n\nexport class ConsumableWrapWritableStream<in T> extends WritableStream<\n    Consumable<T>\n> {\n    constructor(stream: WritableStream<T>) {\n        const writer = stream.getWriter();\n        super({\n            write(chunk) {\n                return chunk.tryConsume((chunk) => writer.write(chunk));\n            },\n            abort(reason) {\n                return writer.abort(reason);\n            },\n            close() {\n                return writer.close();\n            },\n        });\n    }\n}\n", "import { Consumable } from \"../consumable.js\";\nimport type {\n    QueuingStrategy,\n    WritableStreamDefaultController,\n    WritableStreamDefaultWriter,\n} from \"../stream.js\";\nimport { WritableStream } from \"../stream.js\";\n\nexport interface ConsumableWritableStreamSink<in T> {\n    start?(\n        controller: WritableStreamDefaultController,\n    ): void | PromiseLike<void>;\n    write?(\n        chunk: T,\n        controller: WritableStreamDefaultController,\n    ): void | PromiseLike<void>;\n    abort?(reason: unknown): void | PromiseLike<void>;\n    close?(): void | PromiseLike<void>;\n}\n\nexport class ConsumableWritableStream<in T> extends WritableStream<\n    Consumable<T>\n> {\n    static async write<T>(\n        writer: WritableStreamDefaultWriter<Consumable<T>>,\n        value: T,\n    ) {\n        const consumable = new Consumable(value);\n        await writer.write(consumable);\n        await consumable.consumed;\n    }\n\n    constructor(\n        sink: ConsumableWritableStreamSink<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        let wrappedStrategy: QueuingStrategy<Consumable<T>> | undefined;\n        if (strategy) {\n            wrappedStrategy = {};\n            if (\"highWaterMark\" in strategy) {\n                wrappedStrategy.highWaterMark = strategy.highWaterMark;\n            }\n            if (\"size\" in strategy) {\n                wrappedStrategy.size = (chunk) => {\n                    return strategy.size!(\n                        chunk instanceof Consumable ? chunk.value : chunk,\n                    );\n                };\n            }\n        }\n\n        super(\n            {\n                start(controller) {\n                    return sink.start?.(controller);\n                },\n                write(chunk, controller) {\n                    return chunk.tryConsume((chunk) =>\n                        sink.write?.(chunk, controller),\n                    );\n                },\n                abort(reason) {\n                    return sink.abort?.(reason);\n                },\n                close() {\n                    return sink.close?.();\n                },\n            },\n            wrappedStrategy,\n        );\n    }\n}\n", "export interface Task {\n    run<T>(callback: () => T): T;\n}\n\ninterface Console {\n    createTask(name: string): Task;\n}\n\ninterface GlobalExtension {\n    console?: Console;\n}\n\n// `createTask` allows browser DevTools to track the call stack across async boundaries.\nconst { console } = globalThis as unknown as GlobalExtension;\nexport const createTask: (name: string) => Task = /* #__PURE__ */ (() =>\n    console?.createTask?.bind(console) ??\n    (() => ({\n        run(callback) {\n            return callback();\n        },\n    })))();\n", "import { PromiseResolver, isPromiseLike } from \"@yume-chan/async\";\n\nimport type {\n    ConsumableReadableStreamController,\n    ConsumableReadableStreamSource,\n    ConsumableWritableStreamSink,\n} from \"./consumable/index.js\";\nimport {\n    ConsumableReadableStream,\n    ConsumableWrapByteReadableStream,\n    ConsumableWrapWritableStream,\n    ConsumableWritableStream,\n} from \"./consumable/index.js\";\nimport type { Task } from \"./task.js\";\nimport { createTask } from \"./task.js\";\n\nexport class Consumable<T> {\n    static readonly WritableStream = ConsumableWritableStream;\n    static readonly WrapWritableStream = ConsumableWrapWritableStream;\n    static readonly ReadableStream = ConsumableReadableStream;\n    static readonly WrapByteReadableStream = ConsumableWrapByteReadableStream;\n\n    readonly #task: Task;\n    readonly #resolver: PromiseResolver<void>;\n\n    readonly value: T;\n    readonly consumed: Promise<void>;\n\n    constructor(value: T) {\n        this.#task = createTask(\"Consumable\");\n        this.value = value;\n        this.#resolver = new PromiseResolver<void>();\n        this.consumed = this.#resolver.promise;\n    }\n\n    consume() {\n        this.#resolver.resolve();\n    }\n\n    error(error: unknown) {\n        this.#resolver.reject(error);\n    }\n\n    tryConsume<U>(callback: (value: T) => U) {\n        try {\n            let result = this.#task.run(() => callback(this.value));\n            if (isPromiseLike(result)) {\n                result = result.then(\n                    (value) => {\n                        this.#resolver.resolve();\n                        return value;\n                    },\n                    (e) => {\n                        this.#resolver.reject(e);\n                        throw e;\n                    },\n                ) as U;\n            } else {\n                this.#resolver.resolve();\n            }\n            return result;\n        } catch (e) {\n            this.#resolver.reject(e);\n            throw e;\n        }\n    }\n}\n\nexport namespace Consumable {\n    export type WritableStreamSink<T> = ConsumableWritableStreamSink<T>;\n    export type WritableStream<in T> = typeof ConsumableWritableStream<T>;\n\n    export type WrapWritableStream<in T> =\n        typeof ConsumableWrapWritableStream<T>;\n\n    export type ReadableStreamController<T> =\n        ConsumableReadableStreamController<T>;\n    export type ReadableStreamSource<T> = ConsumableReadableStreamSource<T>;\n    export type ReadableStream<T> = typeof ConsumableReadableStream<T>;\n\n    export type WrapByteReadableStream =\n        typeof ConsumableWrapByteReadableStream;\n}\n", "export * from \"./utils.js\";\nexport { MaybeConsumableWrapWritableStream as WrapWritableStream } from \"./wrap-writable.js\";\nexport { MaybeConsumableWritableStream as WritableStream } from \"./writable.js\";\nexport type { MaybeConsumableWritableStreamSink as WritableStreamSink } from \"./writable.js\";\n", "import { Consumable } from \"../consumable.js\";\nimport type { MaybeConsumable } from \"../maybe-consumable.js\";\n\nexport function getValue<T>(value: MaybeConsumable<T>): T {\n    return value instanceof Consumable ? value.value : value;\n}\n\nexport function tryConsume<T, R>(\n    value: T,\n    callback: (value: T extends Consumable<infer U> ? U : T) => R,\n): R {\n    if (value instanceof Consumable) {\n        return value.tryConsume(callback);\n    } else {\n        return callback(value as never);\n    }\n}\n", "import type { MaybeConsumable } from \"../maybe-consumable.js\";\nimport { WritableStream } from \"../stream.js\";\n\nimport { tryConsume } from \"./utils.js\";\n\nexport class MaybeConsumableWrapWritableStream<T> extends WritableStream<\n    MaybeConsumable<T>\n> {\n    constructor(stream: WritableStream<T>) {\n        const writer = stream.getWriter();\n        super({\n            write(chunk) {\n                return tryConsume(chunk, (chunk) => writer.write(chunk as T));\n            },\n            abort(reason) {\n                return writer.abort(reason);\n            },\n            close() {\n                return writer.close();\n            },\n        });\n    }\n}\n", "import { Consumable } from \"../consumable.js\";\nimport type { MaybeConsumable } from \"../maybe-consumable.js\";\nimport type {\n    QueuingStrategy,\n    WritableStreamDefaultController,\n} from \"../stream.js\";\nimport { WritableStream } from \"../stream.js\";\n\nimport { tryConsume } from \"./utils.js\";\n\nexport interface MaybeConsumableWritableStreamSink<in T> {\n    start?(\n        controller: WritableStreamDefaultController,\n    ): void | PromiseLike<void>;\n    write?(\n        chunk: T,\n        controller: WritableStreamDefaultController,\n    ): void | PromiseLike<void>;\n    abort?(reason: unknown): void | PromiseLike<void>;\n    close?(): void | PromiseLike<void>;\n}\n\nexport class MaybeConsumableWritableStream<in T> extends WritableStream<\n    MaybeConsumable<T>\n> {\n    constructor(\n        sink: MaybeConsumableWritableStreamSink<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        let wrappedStrategy: QueuingStrategy<MaybeConsumable<T>> | undefined;\n        if (strategy) {\n            wrappedStrategy = {};\n            if (\"highWaterMark\" in strategy) {\n                wrappedStrategy.highWaterMark = strategy.highWaterMark;\n            }\n            if (\"size\" in strategy) {\n                wrappedStrategy.size = (chunk) => {\n                    return strategy.size!(\n                        chunk instanceof Consumable ? chunk.value : chunk,\n                    );\n                };\n            }\n        }\n\n        super(\n            {\n                start(controller) {\n                    return sink.start?.(controller);\n                },\n                write(chunk, controller) {\n                    return tryConsume(chunk, (chunk) =>\n                        sink.write?.(chunk as T, controller),\n                    );\n                },\n                abort(reason) {\n                    return sink.abort?.(reason);\n                },\n                close() {\n                    return sink.close?.();\n                },\n            },\n            wrappedStrategy,\n        );\n    }\n}\n", "import { Consumable } from \"./consumable.js\";\nimport { MaybeConsumable } from \"./maybe-consumable.js\";\nimport { TransformStream } from \"./stream.js\";\n\n/**\n * Splits or combines buffers to specified size.\n */\nexport class BufferCombiner {\n    #capacity: number;\n    readonly #buffer: Uint8Array;\n    #offset: number;\n    #available: number;\n\n    constructor(size: number) {\n        this.#capacity = size;\n        this.#buffer = new Uint8Array(size);\n        this.#offset = 0;\n        this.#available = size;\n    }\n\n    /**\n     * Pushes data to the combiner.\n     * @param data The input data to be split or combined.\n     * @returns\n     * A generator that yields buffers of specified size.\n     * It may yield the same buffer multiple times, consume the data before calling `next`.\n     */\n    *push(data: Uint8Array): Generator<Uint8Array, void, void> {\n        let offset = 0;\n        let available = data.length;\n\n        if (this.#offset !== 0) {\n            if (available >= this.#available) {\n                this.#buffer.set(\n                    data.subarray(0, this.#available),\n                    this.#offset,\n                );\n                offset += this.#available;\n                available -= this.#available;\n\n                yield this.#buffer;\n                this.#offset = 0;\n                this.#available = this.#capacity;\n\n                if (available === 0) {\n                    return;\n                }\n            } else {\n                this.#buffer.set(data, this.#offset);\n                this.#offset += available;\n                this.#available -= available;\n                return;\n            }\n        }\n\n        while (available >= this.#capacity) {\n            const end = offset + this.#capacity;\n            yield data.subarray(offset, end);\n            offset = end;\n            available -= this.#capacity;\n        }\n\n        if (available > 0) {\n            this.#buffer.set(data.subarray(offset), this.#offset);\n            this.#offset += available;\n            this.#available -= available;\n        }\n    }\n\n    flush(): Uint8Array | undefined {\n        if (this.#offset === 0) {\n            return undefined;\n        }\n\n        const output = this.#buffer.subarray(0, this.#offset);\n        this.#offset = 0;\n        this.#available = this.#capacity;\n        return output;\n    }\n}\n\nexport class DistributionStream extends TransformStream<\n    MaybeConsumable<Uint8Array>,\n    MaybeConsumable<Uint8Array>\n> {\n    constructor(size: number, combine = false) {\n        const combiner = combine ? new BufferCombiner(size) : undefined;\n        super({\n            async transform(chunk, controller) {\n                await MaybeConsumable.tryConsume(chunk, async (chunk) => {\n                    if (combiner) {\n                        for (const buffer of combiner.push(chunk)) {\n                            await Consumable.ReadableStream.enqueue(\n                                controller,\n                                buffer,\n                            );\n                        }\n                    } else {\n                        let offset = 0;\n                        let available = chunk.length;\n                        while (available > 0) {\n                            const end = offset + size;\n                            await Consumable.ReadableStream.enqueue(\n                                controller,\n                                chunk.subarray(offset, end),\n                            );\n                            offset = end;\n                            available -= size;\n                        }\n                    }\n                });\n            },\n            flush(controller) {\n                if (combiner) {\n                    const data = combiner.flush();\n                    if (data) {\n                        controller.enqueue(data);\n                    }\n                }\n            },\n        });\n    }\n}\n", "import type { TransformStream } from \"./stream.js\";\n\nexport interface TextDecoderOptions {\n    fatal?: boolean;\n    ignoreBOM?: boolean;\n}\n\ndeclare class TextDecoderStreamType extends TransformStream<\n    ArrayBufferView | ArrayBuffer,\n    string\n> {\n    constructor(label?: string, options?: TextDecoderOptions);\n\n    readonly encoding: string;\n    readonly fatal: boolean;\n    readonly ignoreBOM: boolean;\n}\n\ndeclare class TextEncoderStreamType extends TransformStream<\n    string,\n    Uint8Array\n> {\n    constructor();\n\n    readonly encoding: string;\n}\n\ninterface GlobalExtension {\n    TextDecoderStream: typeof TextDecoderStreamType;\n    TextEncoderStream: typeof TextEncoderStreamType;\n}\n\nconst Global = globalThis as unknown as GlobalExtension;\n\nexport const TextDecoderStream = Global.TextDecoderStream;\nexport type TextDecoderStream = TextDecoderStreamType;\n\nexport const TextEncoderStream = Global.TextEncoderStream;\nexport type TextEncoderStream = TextEncoderStreamType;\n", "import type { StructDeserializer } from \"@yume-chan/struct\";\n\nimport { BufferedTransformStream } from \"./buffered-transform.js\";\n\nexport class StructDeserializeStream<T> extends BufferedTransformStream<T> {\n    constructor(struct: StructDeserializer<T>) {\n        super((stream) => {\n            return struct.deserialize(stream) as never;\n        });\n    }\n}\n", "export interface Disposable {\n    dispose(): void;\n}\n\nexport class AutoDisposable implements Disposable {\n    #disposables: Disposable[] = [];\n\n    constructor() {\n        this.dispose = this.dispose.bind(this);\n    }\n\n    protected addDisposable<T extends Disposable>(disposable: T): T {\n        this.#disposables.push(disposable);\n        return disposable;\n    }\n\n    dispose() {\n        for (const disposable of this.#disposables) {\n            disposable.dispose();\n        }\n\n        this.#disposables = [];\n    }\n}\n\nexport class DisposableList extends AutoDisposable {\n    add<T extends Disposable>(disposable: T): T {\n        return this.addDisposable(disposable);\n    }\n}\n", "import type { Disposable } from \"./disposable.js\";\nimport type { Event, EventListener, RemoveEventListener } from \"./event.js\";\n\nexport interface EventListenerInfo<TEvent, TResult = unknown> {\n    listener: EventListener<TEvent, unknown, unknown[], TResult>;\n\n    thisArg: unknown;\n\n    args: unknown[];\n}\n\nexport class EventEmitter<TEvent, TResult = unknown> implements Disposable {\n    protected readonly listeners: EventListenerInfo<TEvent, TResult>[] = [];\n\n    constructor() {\n        this.event = this.event.bind(this);\n    }\n\n    protected addEventListener(\n        info: EventListenerInfo<TEvent, TResult>,\n    ): RemoveEventListener {\n        this.listeners.push(info);\n\n        const remove: RemoveEventListener = () => {\n            const index = this.listeners.indexOf(info);\n            if (index !== -1) {\n                this.listeners.splice(index, 1);\n            }\n        };\n        remove.dispose = remove;\n        return remove;\n    }\n\n    event: Event<TEvent, TResult> = <TThis, TArgs extends unknown[]>(\n        listener: EventListener<TEvent, TThis, TArgs, TResult>,\n        thisArg?: TThis,\n        ...args: TArgs\n    ) => {\n        const info: EventListenerInfo<TEvent, TResult> = {\n            listener: listener as EventListener<\n                TEvent,\n                unknown,\n                unknown[],\n                TResult\n            >,\n            thisArg,\n            args,\n        };\n        return this.addEventListener(info);\n    };\n\n    fire(e: TEvent) {\n        for (const info of this.listeners.slice()) {\n            info.listener.call(info.thisArg, e, ...info.args);\n        }\n    }\n\n    dispose() {\n        this.listeners.length = 0;\n    }\n}\n", "import type { EventListenerInfo } from \"./event-emitter.js\";\nimport { EventEmitter } from \"./event-emitter.js\";\nimport type { RemoveEventListener } from \"./event.js\";\n\nconst Undefined = Symbol(\"undefined\");\n\nexport class StickyEventEmitter<TEvent, TResult = unknown> extends EventEmitter<\n    TEvent,\n    TResult\n> {\n    #value: TEvent | typeof Undefined = Undefined;\n\n    protected override addEventListener(\n        info: EventListenerInfo<TEvent, TResult>,\n    ): RemoveEventListener {\n        if (this.#value !== Undefined) {\n            info.listener.call(info.thisArg, this.#value, ...info.args);\n        }\n        return super.addEventListener(info);\n    }\n\n    override fire(e: TEvent): void {\n        this.#value = e;\n        super.fire(e);\n    }\n}\n", "import { AutoDisposable } from \"@yume-chan/event\";\n\nimport type { Adb } from \"../adb.js\";\n\nexport class AdbServiceBase extends AutoDisposable {\n    readonly #adb: Adb;\n    get adb() {\n        return this.#adb;\n    }\n\n    constructor(adb: Adb) {\n        super();\n        this.#adb = adb;\n    }\n}\n", "import { BufferedReadableStream } from \"@yume-chan/stream-extra\";\nimport type { StructValue } from \"@yume-chan/struct\";\nimport { buffer, struct, StructEmptyError, u32 } from \"@yume-chan/struct\";\n\nimport type { Adb } from \"../adb.js\";\n\nconst Version = struct({ version: u32 }, { littleEndian: true });\n\nexport const AdbFrameBufferV1 = struct(\n    {\n        bpp: u32,\n        size: u32,\n        width: u32,\n        height: u32,\n        red_offset: u32,\n        red_length: u32,\n        blue_offset: u32,\n        blue_length: u32,\n        green_offset: u32,\n        green_length: u32,\n        alpha_offset: u32,\n        alpha_length: u32,\n        data: buffer(\"size\"),\n    },\n    { littleEndian: true },\n);\n\nexport type AdbFrameBufferV1 = StructValue<typeof AdbFrameBufferV1>;\n\nexport const AdbFrameBufferV2 = struct(\n    {\n        bpp: u32,\n        colorSpace: u32,\n        size: u32,\n        width: u32,\n        height: u32,\n        red_offset: u32,\n        red_length: u32,\n        blue_offset: u32,\n        blue_length: u32,\n        green_offset: u32,\n        green_length: u32,\n        alpha_offset: u32,\n        alpha_length: u32,\n        data: buffer(\"size\"),\n    },\n    { littleEndian: true },\n);\n\nexport type AdbFrameBufferV2 = StructValue<typeof AdbFrameBufferV2>;\n\n/**\n * ADB uses 8 int32 fields to describe bit depths\n *\n * The only combination I have seen is RGBA8888, which is\n *\n *   red_offset:   0\n *   red_length:   8\n *   blue_offset:  16\n *   blue_length:  8\n *   green_offset: 8\n *   green_length: 8\n *   alpha_offset: 24\n *   alpha_length: 8\n *\n * But it doesn't mean that other combinations are not possible.\n */\nexport type AdbFrameBuffer = AdbFrameBufferV1 | AdbFrameBufferV2;\n\nexport abstract class AdbFrameBufferError extends Error {\n    constructor(message: string, options?: ErrorOptions) {\n        super(message, options);\n    }\n}\n\nexport class AdbFrameBufferUnsupportedVersionError extends AdbFrameBufferError {\n    constructor(version: number) {\n        super(`Unsupported FrameBuffer version ${version}`);\n    }\n}\n\nexport class AdbFrameBufferForbiddenError extends AdbFrameBufferError {\n    constructor() {\n        super(\"FrameBuffer is disabled by current app\");\n    }\n}\n\nexport async function framebuffer(adb: Adb): Promise<AdbFrameBuffer> {\n    const socket = await adb.createSocket(\"framebuffer:\");\n    const stream = new BufferedReadableStream(socket.readable);\n\n    let version: number;\n    try {\n        ({ version } = await Version.deserialize(stream));\n    } catch (e) {\n        if (e instanceof StructEmptyError) {\n            throw new AdbFrameBufferForbiddenError();\n        }\n        throw e;\n    }\n\n    switch (version) {\n        case 1:\n            // TODO: AdbFrameBuffer: does all v1 responses uses the same color space? Add it so the command returns same format for all versions.\n            return await AdbFrameBufferV1.deserialize(stream);\n        case 2:\n            return await AdbFrameBufferV2.deserialize(stream);\n        default:\n            throw new AdbFrameBufferUnsupportedVersionError(version);\n    }\n}\n", "// cspell: ignore bootloader\n// cspell: ignore fastboot\n// cspell: ignore keyevent\n// cspell: ignore longpress\n\nimport { AdbServiceBase } from \"./base.js\";\n\nexport class AdbPower extends AdbServiceBase {\n    reboot(mode = \"\") {\n        return this.adb.createSocketAndWait(`reboot:${mode}`);\n    }\n\n    bootloader() {\n        return this.reboot(\"bootloader\");\n    }\n\n    fastboot() {\n        return this.reboot(\"fastboot\");\n    }\n\n    recovery() {\n        return this.reboot(\"recovery\");\n    }\n\n    sideload() {\n        return this.reboot(\"sideload\");\n    }\n\n    /**\n     * Reboot to Qualcomm Emergency Download (EDL) Mode.\n     *\n     * Only works on some Qualcomm devices.\n     */\n    qualcommEdlMode() {\n        return this.reboot(\"edl\");\n    }\n\n    powerOff(): Promise<string> {\n        return this.adb.subprocess.noneProtocol.spawnWaitText([\"reboot\", \"-p\"]);\n    }\n\n    powerButton(longPress = false): Promise<string> {\n        const args = [\"input\", \"keyevent\"];\n        if (longPress) {\n            args.push(\"--longpress\");\n        }\n        args.push(\"POWER\");\n\n        return this.adb.subprocess.noneProtocol.spawnWaitText(args);\n    }\n\n    /**\n     * Reboot to Samsung Odin download mode.\n     *\n     * Only works on Samsung devices.\n     */\n    samsungOdin() {\n        return this.reboot(\"download\");\n    }\n}\n", "export function toLocalUint8Array(value: Uint8Array): Uint8Array<ArrayBuffer> {\n    if (value.buffer instanceof ArrayBuffer) {\n        return value as Uint8Array<ArrayBuffer>;\n    }\n\n    const copy = new Uint8Array(value.length);\n    copy.set(value);\n    return copy;\n}\n", "import { PromiseResolver } from \"@yume-chan/async\";\nimport type { Disposable } from \"@yume-chan/event\";\n\nexport class AutoResetEvent implements Disposable {\n    #set: boolean;\n    readonly #queue: PromiseResolver<void>[] = [];\n\n    constructor(initialSet = false) {\n        this.#set = initialSet;\n    }\n\n    wait(): Promise<void> {\n        if (!this.#set) {\n            this.#set = true;\n\n            if (this.#queue.length === 0) {\n                return Promise.resolve();\n            }\n        }\n\n        const resolver = new PromiseResolver<void>();\n        this.#queue.push(resolver);\n        return resolver.promise;\n    }\n\n    notifyOne() {\n        if (this.#queue.length !== 0) {\n            this.#queue.pop()!.resolve();\n        } else {\n            this.#set = false;\n        }\n    }\n\n    dispose() {\n        for (const item of this.#queue) {\n            item.reject(new Error(\"The AutoResetEvent has been disposed\"));\n        }\n        this.#queue.length = 0;\n    }\n}\n", "const [charToIndex, indexToChar, paddingChar] = /* #__PURE__ */ (() => {\n    // Array is faster than object literal or `Map`\n    const charToIndex: number[] = [];\n    const indexToChar: number[] = [];\n    const paddingChar = \"=\".charCodeAt(0);\n\n    function addRange(start: string, end: string) {\n        const charCodeStart = start.charCodeAt(0);\n        const charCodeEnd = end.charCodeAt(0);\n\n        for (\n            let charCode = charCodeStart;\n            charCode <= charCodeEnd;\n            charCode += 1\n        ) {\n            charToIndex[charCode] = indexToChar.length;\n            indexToChar.push(charCode);\n        }\n    }\n\n    addRange(\"A\", \"Z\");\n    addRange(\"a\", \"z\");\n    addRange(\"0\", \"9\");\n    addRange(\"+\", \"+\");\n    addRange(\"/\", \"/\");\n\n    return [charToIndex, indexToChar, paddingChar];\n})();\n\n/**\n * Calculate the required length of the output buffer for the given input length.\n *\n * @param inputLength Length of the input in bytes\n * @returns Length of the output in bytes\n */\nexport function calculateBase64EncodedLength(\n    inputLength: number,\n): [outputLength: number, paddingLength: number] {\n    const remainder = inputLength % 3;\n    const paddingLength = remainder !== 0 ? 3 - remainder : 0;\n    return [((inputLength + paddingLength) / 3) * 4, paddingLength];\n}\n\n/**\n * Encode the given input buffer into base64.\n *\n * @param input The input buffer\n * @returns The encoded output buffer\n */\nexport function encodeBase64(input: Uint8Array): Uint8Array<ArrayBuffer>;\n/**\n * Encode the given input into base64 and write it to the output buffer.\n *\n * The output buffer must be at least as long as the value returned by `calculateBase64EncodedLength`.\n * It can points to the same buffer as the input, as long as `output.offset <= input.offset - input.length / 3`,\n * or `output.offset >= input.offset - 1`\n *\n * @param input The input buffer\n * @param output The output buffer\n * @returns The number of bytes written to the output buffer\n */\nexport function encodeBase64(input: Uint8Array, output: Uint8Array): number;\nexport function encodeBase64(\n    input: Uint8Array,\n    output?: Uint8Array,\n): Uint8Array | number {\n    const [outputLength, paddingLength] = calculateBase64EncodedLength(\n        input.length,\n    );\n\n    if (!output) {\n        output = new Uint8Array(outputLength);\n        encodeForward(input, output, paddingLength);\n        return output;\n    } else {\n        if (output.length < outputLength) {\n            throw new TypeError(\"output buffer is too small\");\n        }\n\n        output = output.subarray(0, outputLength);\n\n        // When input and output are on same ArrayBuffer,\n        // we check if it's possible to encode in-place.\n        if (input.buffer !== output.buffer) {\n            encodeForward(input, output, paddingLength);\n        } else if (\n            output.byteOffset + output.length - (paddingLength + 1) <=\n            input.byteOffset + input.length\n        ) {\n            // Output ends before input ends.\n            // Can encode forwards, because writing output won't catch up with reading input.\n\n            // The output end is subtracted by `(paddingLength + 1)` because\n            // depending on padding length, it's possible to write 1-3 extra bytes after input ends.\n            //\n            // The following diagrams show how the last read from input and the last write to output\n            // are not conflicting.\n            //\n            // spell: disable\n            //\n            // `paddingLength === 2` can write 3 extra bytes:\n            //\n            //   input:  | aaaaaabb |          |          |          |\n            //   output: |  aaaaaa  |  bb0000  |    =     |    =     |\n            //\n            // `paddingLength === 1` can write 2 extra bytes:\n            //\n            //   input:  | aaaaaabb | bbbbcccc |          |          |\n            //   output: |  aaaaaa  |  bbbbbb  |  cccc00  |    =     |\n            //\n            // `paddingLength === 0` can write 1 extra byte:\n            //\n            //   input:  | aaaaaabb | bbbbcccc | ccdddddd |          |\n            //   output: |  aaaaaa  |  bbbbbb  |  cccccc  |  dddddd  |\n            //\n            // spell: enable\n\n            encodeForward(input, output, paddingLength);\n        } else if (output.byteOffset >= input.byteOffset - 1) {\n            // Output starts after input starts\n            // So in backwards, writing output won't catch up with reading input.\n\n            // The input start is subtracted by `1`, Because as the first 3 bytes becomes 4 bytes,\n            // it's possible to write 1 extra byte before input starts.\n            // spell: disable-next-line\n            //   input:  |          | aaaaaabb | bbbbcccc | ccdddddd |\n            //   output: |  aaaaaa  |  bbbbbb  |  cccccc  |  dddddd  |\n\n            // Must encode backwards.\n            encodeBackward(input, output, paddingLength);\n        } else {\n            // Input is in the middle of output,\n            // It's not possible to read either the first or the last three bytes\n            // before they are overwritten by the output.\n            throw new TypeError(\"input and output cannot overlap\");\n        }\n\n        return outputLength;\n    }\n}\n\nfunction encodeForward(\n    input: Uint8Array,\n    output: Uint8Array,\n    paddingLength: number,\n) {\n    let inputIndex = 0;\n    let outputIndex = 0;\n\n    while (inputIndex < input.length - 2) {\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex += 1;\n\n        /* cspell: disable-next-line */\n        // bbbbcccc\n        const y = input[inputIndex]!;\n        inputIndex += 1;\n\n        /* cspell: disable-next-line */\n        // ccdddddd\n        const z = input[inputIndex]!;\n        inputIndex += 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[((x & 0b11) << 4) | (y >> 4)]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[((y & 0b1111) << 2) | (z >> 6)]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[z & 0b111111]!;\n        outputIndex += 1;\n    }\n\n    if (paddingLength === 2) {\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex += 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[(x & 0b11) << 4]!;\n        outputIndex += 1;\n\n        output[outputIndex] = paddingChar;\n        outputIndex += 1;\n\n        output[outputIndex] = paddingChar;\n    } else if (paddingLength === 1) {\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex += 1;\n\n        /* cspell: disable-next-line */\n        // bbbbcccc\n        const y = input[inputIndex]!;\n        inputIndex += 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[((x & 0b11) << 4) | (y >> 4)]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[(y & 0b1111) << 2]!;\n        outputIndex += 1;\n\n        output[outputIndex] = paddingChar;\n    }\n}\n\nfunction encodeBackward(\n    input: Uint8Array,\n    output: Uint8Array,\n    paddingLength: number,\n) {\n    let inputIndex = input.length - 1;\n    let outputIndex = output.length - 1;\n\n    if (paddingLength === 2) {\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex -= 1;\n\n        output[outputIndex] = paddingChar;\n        outputIndex -= 1;\n\n        output[outputIndex] = paddingChar;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[(x & 0b11) << 4]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex -= 1;\n    } else if (paddingLength === 1) {\n        /* cspell: disable-next-line */\n        // bbbbcccc\n        const y = input[inputIndex]!;\n        inputIndex -= 1;\n\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex -= 1;\n\n        output[outputIndex] = paddingChar;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[(y & 0b1111) << 2]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[((x & 0b11) << 4) | (y >> 4)]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex -= 1;\n    }\n\n    while (inputIndex >= 0) {\n        /* cspell: disable-next-line */\n        // ccdddddd\n        const z = input[inputIndex]!;\n        inputIndex -= 1;\n\n        /* cspell: disable-next-line */\n        // bbbbcccc\n        const y = input[inputIndex]!;\n        inputIndex -= 1;\n\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex -= 1;\n\n        output[outputIndex] = indexToChar[z & 0b111111]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[((y & 0b1111) << 2) | (z >> 6)]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[((x & 0b11) << 4) | (y >> 4)]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex -= 1;\n    }\n}\n\nexport function decodeBase64(input: string): Uint8Array<ArrayBuffer> {\n    let padding: number;\n    if (input[input.length - 2] === \"=\") {\n        padding = 2;\n    } else if (input[input.length - 1] === \"=\") {\n        padding = 1;\n    } else {\n        padding = 0;\n    }\n\n    const result = new Uint8Array((input.length / 4) * 3 - padding);\n    let sIndex = 0;\n    let dIndex = 0;\n\n    while (sIndex < input.length - (padding !== 0 ? 4 : 0)) {\n        const a = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const b = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const c = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const d = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        result[dIndex] = (a << 2) | ((b & 0b11_0000) >> 4);\n        dIndex += 1;\n\n        result[dIndex] = ((b & 0b1111) << 4) | ((c & 0b11_1100) >> 2);\n        dIndex += 1;\n\n        result[dIndex] = ((c & 0b11) << 6) | d;\n        dIndex += 1;\n    }\n\n    if (padding === 1) {\n        const a = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const b = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const c = charToIndex[input.charCodeAt(sIndex)]!;\n\n        result[dIndex] = (a << 2) | ((b & 0b11_0000) >> 4);\n        dIndex += 1;\n\n        result[dIndex] = ((b & 0b1111) << 4) | ((c & 0b11_1100) >> 2);\n    } else if (padding === 2) {\n        const a = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const b = charToIndex[input.charCodeAt(sIndex)]!;\n\n        result[dIndex] = (a << 2) | ((b & 0b11_0000) >> 4);\n    }\n\n    return result;\n}\n", "function hexCharToNumber(char: number) {\n    if (char < 48) {\n        throw new TypeError(`Invalid hex char ${char}`);\n    }\n    if (char < 58) {\n        // 0-9\n        return char - 48;\n    }\n\n    if (char < 65) {\n        throw new TypeError(`Invalid hex char ${char}`);\n    }\n    if (char < 71) {\n        // A-F\n        return char - 55;\n    }\n\n    if (char < 97) {\n        throw new TypeError(`Invalid hex char ${char}`);\n    }\n    if (char < 103) {\n        // a-f\n        return char - 87;\n    }\n\n    throw new TypeError(`Invalid hex char ${char}`);\n}\n\n// It's 22x faster than converting `data` to string then `Number.parseInt`\n// https://jsbench.me/dglha94ozl/1\nexport function hexToNumber(data: Uint8Array): number {\n    let result = 0;\n    for (let i = 0; i < data.length; i += 1) {\n        result = (result << 4) | hexCharToNumber(data[i]!);\n    }\n    return result;\n}\n\nexport function write4HexDigits(\n    buffer: Uint8Array,\n    index: number,\n    value: number,\n) {\n    const start = index;\n    index += 3;\n    while (index >= start && value > 0) {\n        const digit = value & 0xf;\n        value >>= 4;\n        if (digit < 10) {\n            buffer[index] = digit + 48; // '0'\n        } else {\n            buffer[index] = digit + 87; // 'a' - 10\n        }\n        index -= 1;\n    }\n    while (index >= start) {\n        buffer[index] = 48; // '0'\n        index -= 1;\n    }\n}\n", "/* #__NO_SIDE_EFFECTS__ */\nexport const NOOP = () => {\n    // no-op\n};\n\n/**\n * When used in `Promise#catch`, means the promise should never throw errors.\n * An explicit way to suppress ESLint floating promise warnings.\n */\nexport function unreachable(...args: unknown[]): never {\n    // Trigger runtime's unhandled rejection event.\n    throw new Error(\"Unreachable. Arguments:\\n\" + args.join(\"\\n\"));\n}\n", "interface GlobalExtension {\n    setInterval: (callback: () => void, delay: number) => number;\n    clearInterval: (id: number) => void;\n}\n\nconst { setInterval, clearInterval } = globalThis as unknown as GlobalExtension;\n\n/**\n * An object to keep current Node.js process alive even when no code is running.\n *\n * Does nothing in Web environments.\n *\n * Note that it does't have reference counting. Calling `unref` will\n * remove the ref no matter how many times `ref` has been previously called, and vice versa.\n * This is the same as how Node.js works.\n */\nexport class Ref {\n    #intervalId: number | undefined;\n\n    constructor(options?: { unref?: boolean | undefined }) {\n        if (!options?.unref) {\n            this.ref();\n        }\n    }\n\n    ref() {\n        // `setInterval` can keep current Node.js alive, the delay value doesn't matter\n        this.#intervalId = setInterval(() => {}, 60 * 1000);\n    }\n\n    unref() {\n        if (this.#intervalId) {\n            clearInterval(this.#intervalId);\n            this.#intervalId = undefined;\n        }\n    }\n}\n", "export function sequenceEqual(a: Uint8Array, b: Uint8Array): boolean {\n    if (a.length !== b.length) {\n        return false;\n    }\n\n    for (let i = 0; i < a.length; i += 1) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n", "// cspell: ignore killforward\n\nimport { BufferedReadableStream } from \"@yume-chan/stream-extra\";\nimport {\n    encodeUtf8,\n    ExactReadableEndedError,\n    extend,\n    string,\n    struct,\n} from \"@yume-chan/struct\";\n\nimport type { AdbIncomingSocketHandler } from \"../adb.js\";\nimport { hexToNumber, sequenceEqual } from \"../utils/index.js\";\n\nimport { AdbServiceBase } from \"./base.js\";\n\nexport interface AdbForwardListener {\n    deviceSerial: string;\n\n    localName: string;\n\n    remoteName: string;\n}\n\nconst AdbReverseStringResponse = struct(\n    {\n        length: string(4),\n        content: string({\n            field: \"length\",\n            convert(value: string) {\n                return Number.parseInt(value, 16);\n            },\n            back(value) {\n                return value.toString(16).padStart(4, \"0\");\n            },\n        }),\n    },\n    { littleEndian: true },\n);\n\nexport class AdbReverseError extends Error {\n    constructor(message: string) {\n        super(message);\n    }\n}\n\nexport class AdbReverseNotSupportedError extends AdbReverseError {\n    constructor() {\n        super(\n            \"ADB reverse tunnel is not supported on this device when connected wirelessly.\",\n        );\n    }\n}\n\nexport const AdbReverseErrorResponse = extend(\n    AdbReverseStringResponse,\n    {},\n    {\n        postDeserialize(value) {\n            // https://issuetracker.google.com/issues/37066218\n            // ADB on Android <9 can't create reverse tunnels when connected wirelessly (ADB over Wi-Fi),\n            // and returns this confusing \"more than one device/emulator\" error.\n            if (value.content === \"more than one device/emulator\") {\n                throw new AdbReverseNotSupportedError();\n            } else {\n                throw new AdbReverseError(value.content);\n            }\n        },\n    },\n);\n\n// Like `hexToNumber`, it's much faster than first converting `buffer` to a string\nfunction decimalToNumber(buffer: Uint8Array) {\n    let value = 0;\n    for (const byte of buffer) {\n        // Like `parseInt`, return when it encounters a non-digit character\n        if (byte < 48 || byte > 57) {\n            return value;\n        }\n        value = value * 10 + byte - 48;\n    }\n    return value;\n}\n\nconst OKAY = encodeUtf8(\"OKAY\");\n\nexport class AdbReverseService extends AdbServiceBase {\n    readonly #deviceAddressToLocalAddress = new Map<string, string>();\n\n    protected async createBufferedStream(service: string) {\n        const socket = await this.adb.createSocket(service);\n        return new BufferedReadableStream(socket.readable);\n    }\n\n    protected async sendRequest(service: string) {\n        const stream = await this.createBufferedStream(service);\n\n        const response = await stream.readExactly(4);\n        if (!sequenceEqual(response, OKAY)) {\n            await AdbReverseErrorResponse.deserialize(stream);\n        }\n\n        return stream;\n    }\n\n    /**\n     * Get a list of all reverse port forwarding on the device.\n     */\n    async list(): Promise<AdbForwardListener[]> {\n        const stream = await this.createBufferedStream(\"reverse:list-forward\");\n\n        const response = await AdbReverseStringResponse.deserialize(stream);\n        return response.content\n            .split(\"\\n\")\n            .filter((line) => !!line)\n            .map((line) => {\n                const [deviceSerial, localName, remoteName] = line.split(\n                    \" \",\n                ) as [string, string, string];\n                return { deviceSerial, localName, remoteName };\n            });\n\n        // No need to close the stream, device will close it\n    }\n\n    /**\n     * Add a reverse port forwarding for a program that already listens on a port.\n     */\n    async addExternal(deviceAddress: string, localAddress: string) {\n        const stream = await this.sendRequest(\n            `reverse:forward:${deviceAddress};${localAddress}`,\n        );\n\n        // `tcp:0` tells the device to pick an available port.\n        // On Android >=8, device will respond with the selected port for all `tcp:` requests.\n        if (deviceAddress.startsWith(\"tcp:\")) {\n            const position = stream.position;\n            try {\n                const length = hexToNumber(await stream.readExactly(4));\n                const port = decimalToNumber(await stream.readExactly(length));\n                deviceAddress = `tcp:${port}`;\n            } catch (e) {\n                if (\n                    e instanceof ExactReadableEndedError &&\n                    stream.position === position\n                ) {\n                    // Android <8 doesn't have this response.\n                    // (the stream is closed now)\n                    // Can be safely ignored.\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        return deviceAddress;\n    }\n\n    /**\n     * Add a reverse port forwarding.\n     */\n    async add(\n        deviceAddress: string,\n        handler: AdbIncomingSocketHandler,\n        localAddress?: string,\n    ): Promise<string> {\n        localAddress = await this.adb.transport.addReverseTunnel(\n            handler,\n            localAddress,\n        );\n\n        try {\n            deviceAddress = await this.addExternal(deviceAddress, localAddress);\n            this.#deviceAddressToLocalAddress.set(deviceAddress, localAddress);\n            return deviceAddress;\n        } catch (e) {\n            await this.adb.transport.removeReverseTunnel(localAddress);\n            throw e;\n        }\n    }\n\n    /**\n     * Remove a reverse port forwarding.\n     */\n    async remove(deviceAddress: string): Promise<void> {\n        const localAddress =\n            this.#deviceAddressToLocalAddress.get(deviceAddress);\n        if (localAddress) {\n            await this.adb.transport.removeReverseTunnel(localAddress);\n        }\n\n        await this.sendRequest(`reverse:killforward:${deviceAddress}`);\n\n        // No need to close the stream, device will close it\n    }\n\n    /**\n     * Remove all reverse port forwarding, including the ones added by other programs.\n     */\n    async removeAll(): Promise<void> {\n        await this.adb.transport.clearReverseTunnels();\n        this.#deviceAddressToLocalAddress.clear();\n\n        await this.sendRequest(`reverse:killforward-all`);\n\n        // No need to close the stream, device will close it\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { PromiseResolver } from \"@yume-chan/async\";\nimport type {\n    AbortSignal,\n    MaybeConsumable,\n    ReadableStream,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\n\nimport type { AdbSocket } from \"../../../adb.js\";\n\nimport type { AdbNoneProtocolProcess } from \"./spawner.js\";\n\nexport class AdbNoneProtocolProcessImpl implements AdbNoneProtocolProcess {\n    readonly #socket: AdbSocket;\n\n    get stdin(): WritableStream<MaybeConsumable<Uint8Array>> {\n        return this.#socket.writable;\n    }\n\n    get output(): ReadableStream<Uint8Array> {\n        return this.#socket.readable;\n    }\n\n    readonly #exited: Promise<undefined>;\n    get exited(): Promise<undefined> {\n        return this.#exited;\n    }\n\n    constructor(socket: AdbSocket, signal?: AbortSignal) {\n        this.#socket = socket;\n\n        if (signal) {\n            // `signal` won't affect `this.output`\n            // So remaining data can still be read\n            // (call `controller.error` will discard all pending data)\n\n            const exited = new PromiseResolver<undefined>();\n            this.#socket.closed.then(\n                () => exited.resolve(undefined),\n                (e) => exited.reject(e),\n            );\n            signal.addEventListener(\"abort\", () => {\n                exited.reject(signal.reason);\n                this.#socket.close();\n            });\n            this.#exited = exited.promise;\n        } else {\n            this.#exited = this.#socket.closed;\n        }\n    }\n\n    kill(): MaybePromiseLike<void> {\n        return this.#socket.close();\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport type {\n    ReadableStream,\n    WritableStream,\n    WritableStreamDefaultWriter,\n} from \"@yume-chan/stream-extra\";\nimport { MaybeConsumable } from \"@yume-chan/stream-extra\";\n\nimport type { AdbSocket } from \"../../../adb.js\";\nimport type { AdbPtyProcess } from \"../pty.js\";\n\nexport class AdbNoneProtocolPtyProcess implements AdbPtyProcess<undefined> {\n    readonly #socket: AdbSocket;\n    readonly #writer: WritableStreamDefaultWriter<MaybeConsumable<Uint8Array>>;\n\n    readonly #input: MaybeConsumable.WritableStream<Uint8Array>;\n    get input(): WritableStream<MaybeConsumable<Uint8Array>> {\n        return this.#input;\n    }\n\n    get output(): ReadableStream<Uint8Array> {\n        return this.#socket.readable;\n    }\n\n    get exited(): Promise<undefined> {\n        return this.#socket.closed;\n    }\n\n    constructor(socket: AdbSocket) {\n        this.#socket = socket;\n\n        this.#writer = this.#socket.writable.getWriter();\n        this.#input = new MaybeConsumable.WritableStream<Uint8Array>({\n            write: (chunk) => this.#writer.write(chunk),\n        });\n    }\n\n    sigint() {\n        return this.#writer.write(new Uint8Array([0x03]));\n    }\n\n    kill(): MaybePromiseLike<void> {\n        return this.#socket.close();\n    }\n}\n", "export function escapeArg(s: string) {\n    let result = \"\";\n    result += `'`;\n\n    let base = 0;\n    while (true) {\n        const found = s.indexOf(`'`, base);\n        if (found === -1) {\n            result += s.substring(base);\n            break;\n        }\n        result += s.substring(base, found);\n        // a'b becomes a'\\'b (the backslash is not a escape character)\n        result += String.raw`'\\''`;\n        base = found + 1;\n    }\n\n    result += `'`;\n    return result;\n}\n\nexport function splitCommand(command: string): string[] {\n    const result: string[] = [];\n    let quote: string | undefined;\n    let isEscaped = false;\n    let start = 0;\n\n    for (let i = 0, len = command.length; i < len; i += 1) {\n        if (isEscaped) {\n            isEscaped = false;\n            continue;\n        }\n\n        const char = command.charAt(i);\n        switch (char) {\n            case \" \":\n                if (!quote && i !== start) {\n                    result.push(command.substring(start, i));\n                    start = i + 1;\n                }\n                break;\n            case \"'\":\n            case '\"':\n                if (!quote) {\n                    quote = char;\n                } else if (char === quote) {\n                    quote = undefined;\n                }\n                break;\n            case \"\\\\\":\n                isEscaped = true;\n                break;\n        }\n    }\n\n    if (start < command.length) {\n        result.push(command.substring(start));\n    }\n\n    return result;\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport type {\n    AbortSignal,\n    MaybeConsumable,\n    ReadableStream,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport {\n    ConcatBufferStream,\n    ConcatStringStream,\n    TextDecoderStream,\n} from \"@yume-chan/stream-extra\";\n\nimport { splitCommand } from \"../utils.js\";\n\nexport interface AdbNoneProtocolProcess {\n    get stdin(): WritableStream<MaybeConsumable<Uint8Array>>;\n\n    /**\n     * Mix of stdout and stderr\n     */\n    get output(): ReadableStream<Uint8Array>;\n\n    get exited(): Promise<void>;\n\n    kill(): MaybePromiseLike<void>;\n}\n\nexport class AdbNoneProtocolSpawner {\n    readonly #spawn: (\n        command: readonly string[],\n        signal: AbortSignal | undefined,\n    ) => Promise<AdbNoneProtocolProcess>;\n\n    constructor(\n        spawn: (\n            command: readonly string[],\n            signal: AbortSignal | undefined,\n        ) => Promise<AdbNoneProtocolProcess>,\n    ) {\n        this.#spawn = spawn;\n    }\n\n    spawn(\n        command: string | readonly string[],\n        signal?: AbortSignal,\n    ): Promise<AdbNoneProtocolProcess> {\n        signal?.throwIfAborted();\n\n        if (typeof command === \"string\") {\n            command = splitCommand(command);\n        }\n\n        return this.#spawn(command, signal);\n    }\n\n    async spawnWait(command: string | readonly string[]): Promise<Uint8Array> {\n        const process = await this.spawn(command);\n        return await process.output.pipeThrough(new ConcatBufferStream());\n    }\n\n    async spawnWaitText(command: string | readonly string[]): Promise<string> {\n        const process = await this.spawn(command);\n        return await process.output\n            .pipeThrough(new TextDecoderStream())\n            .pipeThrough(new ConcatStringStream());\n    }\n}\n", "import type { Adb } from \"../../../adb.js\";\n\nimport { AdbNoneProtocolProcessImpl } from \"./process.js\";\nimport { AdbNoneProtocolPtyProcess } from \"./pty.js\";\nimport { AdbNoneProtocolSpawner } from \"./spawner.js\";\n\nexport class AdbNoneProtocolSubprocessService extends AdbNoneProtocolSpawner {\n    readonly #adb: Adb;\n    get adb(): Adb {\n        return this.#adb;\n    }\n\n    constructor(adb: Adb) {\n        super(async (command, signal) => {\n            // `shell,raw:${command}` also triggers raw mode,\n            // But is not supported on Android version <7.\n            const socket = await this.#adb.createSocket(\n                `exec:${command.join(\" \")}`,\n            );\n\n            if (signal?.aborted) {\n                await socket.close();\n                throw signal.reason;\n            }\n\n            return new AdbNoneProtocolProcessImpl(socket, signal);\n        });\n        this.#adb = adb;\n    }\n\n    async pty(\n        command?: string | readonly string[],\n    ): Promise<AdbNoneProtocolPtyProcess> {\n        if (command === undefined) {\n            command = \"\";\n        } else if (Array.isArray(command)) {\n            command = command.join(\" \");\n        }\n\n        return new AdbNoneProtocolPtyProcess(\n            // https://github.com/microsoft/typescript/issues/17002\n            await this.#adb.createSocket(`shell:${command as string}`),\n        );\n    }\n}\n", "// The order follows\n// https://cs.android.com/android/platform/superproject/+/master:packages/modules/adb/transport.cpp;l=77;drc=6d14d35d0241f6fee145f8e54ffd77252e8d29fd\nexport const AdbFeature = {\n    ShellV2: \"shell_v2\",\n    Cmd: \"cmd\",\n    StatV2: \"stat_v2\",\n    ListV2: \"ls_v2\",\n    FixedPushMkdir: \"fixed_push_mkdir\",\n    Abb: \"abb\",\n    AbbExec: \"abb_exec\",\n    SendReceiveV2: \"sendrecv_v2\",\n    DelayedAck: \"delayed_ack\",\n} as const;\n\nexport type AdbFeature = (typeof AdbFeature)[keyof typeof AdbFeature];\n", "import type { StructValue } from \"@yume-chan/struct\";\nimport { buffer, struct, u32, u8 } from \"@yume-chan/struct\";\n\nexport const AdbShellProtocolId = {\n    Stdin: 0,\n    Stdout: 1,\n    Stderr: 2,\n    Exit: 3,\n    CloseStdin: 4,\n    WindowSizeChange: 5,\n} as const;\n\nexport type AdbShellProtocolId =\n    (typeof AdbShellProtocolId)[keyof typeof AdbShellProtocolId];\n\n// This packet format is used in both directions.\nexport const AdbShellProtocolPacket = struct(\n    {\n        id: u8<AdbShellProtocolId>(),\n        data: buffer(u32),\n    },\n    { littleEndian: true },\n);\n\nexport type AdbShellProtocolPacket = StructValue<typeof AdbShellProtocolPacket>;\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { PromiseResolver } from \"@yume-chan/async\";\nimport type {\n    AbortSignal,\n    PushReadableStreamController,\n    ReadableStream,\n    WritableStreamDefaultWriter,\n} from \"@yume-chan/stream-extra\";\nimport {\n    MaybeConsumable,\n    PushReadableStream,\n    StructDeserializeStream,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport { EmptyUint8Array } from \"@yume-chan/struct\";\n\nimport type { AdbSocket } from \"../../../adb.js\";\n\nimport { AdbShellProtocolId, AdbShellProtocolPacket } from \"./shared.js\";\nimport type { AdbShellProtocolProcess } from \"./spawner.js\";\n\nexport class AdbShellProtocolProcessImpl implements AdbShellProtocolProcess {\n    readonly #socket: AdbSocket;\n    readonly #writer: WritableStreamDefaultWriter<MaybeConsumable<Uint8Array>>;\n\n    readonly #stdin: WritableStream<MaybeConsumable<Uint8Array>>;\n    get stdin() {\n        return this.#stdin;\n    }\n\n    readonly #stdout: ReadableStream<Uint8Array>;\n    get stdout() {\n        return this.#stdout;\n    }\n\n    readonly #stderr: ReadableStream<Uint8Array>;\n    get stderr() {\n        return this.#stderr;\n    }\n\n    readonly #exited: Promise<number>;\n    get exited() {\n        return this.#exited;\n    }\n\n    constructor(socket: AdbSocket, signal?: AbortSignal) {\n        this.#socket = socket;\n\n        let stdoutController!: PushReadableStreamController<Uint8Array>;\n        let stderrController!: PushReadableStreamController<Uint8Array>;\n        this.#stdout = new PushReadableStream<Uint8Array>((controller) => {\n            stdoutController = controller;\n        });\n        this.#stderr = new PushReadableStream<Uint8Array>((controller) => {\n            stderrController = controller;\n        });\n\n        const exited = new PromiseResolver<number>();\n        this.#exited = exited.promise;\n\n        socket.readable\n            .pipeThrough(new StructDeserializeStream(AdbShellProtocolPacket))\n            .pipeTo(\n                new WritableStream<AdbShellProtocolPacket>({\n                    write: async (chunk) => {\n                        switch (chunk.id) {\n                            case AdbShellProtocolId.Exit:\n                                exited.resolve(chunk.data[0]!);\n                                break;\n                            case AdbShellProtocolId.Stdout:\n                                await stdoutController.enqueue(chunk.data);\n                                break;\n                            case AdbShellProtocolId.Stderr:\n                                await stderrController.enqueue(chunk.data);\n                                break;\n                            default:\n                                // Ignore unknown messages like Google ADB does\n                                // https://cs.android.com/android/platform/superproject/main/+/main:packages/modules/adb/daemon/shell_service.cpp;l=684;drc=61197364367c9e404c7da6900658f1b16c42d0da\n                                break;\n                        }\n                    },\n                }),\n            )\n            .then(\n                () => {\n                    stdoutController.close();\n                    stderrController.close();\n                    // If `exited` has already settled, this will be a no-op\n                    exited.reject(\n                        new Error(\"Socket ended without exit message\"),\n                    );\n                },\n                (e) => {\n                    stdoutController.error(e);\n                    stderrController.error(e);\n                    // If `exited` has already settled, this will be a no-op\n                    exited.reject(e);\n                },\n            );\n\n        if (signal) {\n            // `signal` won't affect `this.stdout` and `this.stderr`\n            // So remaining data can still be read\n            // (call `controller.error` will discard all pending data)\n\n            signal.addEventListener(\"abort\", () => {\n                exited.reject(signal.reason);\n                this.#socket.close();\n            });\n        }\n\n        this.#writer = this.#socket.writable.getWriter();\n        this.#stdin = new MaybeConsumable.WritableStream<Uint8Array>({\n            write: async (chunk) => {\n                await this.#writer.write(\n                    AdbShellProtocolPacket.serialize({\n                        id: AdbShellProtocolId.Stdin,\n                        data: chunk,\n                    }),\n                );\n            },\n            close: () =>\n                // Only shell protocol + raw mode supports closing stdin\n                this.#writer.write(\n                    AdbShellProtocolPacket.serialize({\n                        id: AdbShellProtocolId.CloseStdin,\n                        data: EmptyUint8Array,\n                    }),\n                ),\n        });\n    }\n\n    kill(): MaybePromiseLike<void> {\n        return this.#socket.close();\n    }\n}\n", "import { PromiseResolver } from \"@yume-chan/async\";\nimport type {\n    PushReadableStreamController,\n    ReadableStream,\n    WritableStreamDefaultWriter,\n} from \"@yume-chan/stream-extra\";\nimport {\n    MaybeConsumable,\n    PushReadableStream,\n    StructDeserializeStream,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport { encodeUtf8 } from \"@yume-chan/struct\";\n\nimport type { AdbSocket } from \"../../../adb.js\";\nimport type { AdbPtyProcess } from \"../pty.js\";\n\nimport { AdbShellProtocolId, AdbShellProtocolPacket } from \"./shared.js\";\n\nexport class AdbShellProtocolPtyProcess implements AdbPtyProcess<number> {\n    readonly #socket: AdbSocket;\n    readonly #writer: WritableStreamDefaultWriter<MaybeConsumable<Uint8Array>>;\n\n    readonly #input: WritableStream<MaybeConsumable<Uint8Array>>;\n    get input() {\n        return this.#input;\n    }\n\n    readonly #stdout: ReadableStream<Uint8Array>;\n    get output() {\n        return this.#stdout;\n    }\n\n    readonly #exited = new PromiseResolver<number>();\n    get exited() {\n        return this.#exited.promise;\n    }\n\n    constructor(socket: AdbSocket) {\n        this.#socket = socket;\n\n        let stdoutController!: PushReadableStreamController<Uint8Array>;\n        this.#stdout = new PushReadableStream<Uint8Array>((controller) => {\n            stdoutController = controller;\n        });\n\n        socket.readable\n            .pipeThrough(new StructDeserializeStream(AdbShellProtocolPacket))\n            .pipeTo(\n                new WritableStream<AdbShellProtocolPacket>({\n                    write: async (chunk) => {\n                        switch (chunk.id) {\n                            case AdbShellProtocolId.Exit:\n                                this.#exited.resolve(chunk.data[0]!);\n                                break;\n                            case AdbShellProtocolId.Stdout:\n                                await stdoutController.enqueue(chunk.data);\n                                break;\n                        }\n                    },\n                }),\n            )\n            .then(\n                () => {\n                    stdoutController.close();\n                    // If `#exit` has already resolved, this will be a no-op\n                    this.#exited.reject(\n                        new Error(\"Socket ended without exit message\"),\n                    );\n                },\n                (e) => {\n                    stdoutController.error(e);\n                    // If `#exit` has already resolved, this will be a no-op\n                    this.#exited.reject(e);\n                },\n            );\n\n        this.#writer = this.#socket.writable.getWriter();\n        this.#input = new MaybeConsumable.WritableStream<Uint8Array>({\n            write: (chunk) => this.#writeStdin(chunk),\n        });\n    }\n\n    #writeStdin(chunk: Uint8Array) {\n        return this.#writer.write(\n            AdbShellProtocolPacket.serialize({\n                id: AdbShellProtocolId.Stdin,\n                data: chunk,\n            }),\n        );\n    }\n\n    async resize(rows: number, cols: number) {\n        await this.#writer.write(\n            AdbShellProtocolPacket.serialize({\n                id: AdbShellProtocolId.WindowSizeChange,\n                // The \"correct\" format is `${rows}x${cols},${x_pixels}x${y_pixels}`\n                // However, according to https://linux.die.net/man/4/tty_ioctl\n                // `x_pixels` and `y_pixels` are unused, so always sending `0` should be fine.\n                data: encodeUtf8(`${rows}x${cols},0x0\\0`),\n            }),\n        );\n    }\n\n    sigint() {\n        return this.#writeStdin(new Uint8Array([0x03]));\n    }\n\n    kill() {\n        return this.#socket.close();\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport type {\n    AbortSignal,\n    MaybeConsumable,\n    ReadableStream,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport {\n    ConcatBufferStream,\n    ConcatStringStream,\n    TextDecoderStream,\n} from \"@yume-chan/stream-extra\";\n\nimport { splitCommand } from \"../utils.js\";\n\nexport interface AdbShellProtocolProcess {\n    get stdin(): WritableStream<MaybeConsumable<Uint8Array>>;\n\n    get stdout(): ReadableStream<Uint8Array>;\n    get stderr(): ReadableStream<Uint8Array>;\n\n    get exited(): Promise<number>;\n\n    kill(): MaybePromiseLike<void>;\n}\n\nexport class AdbShellProtocolSpawner {\n    readonly #spawn: (\n        command: readonly string[],\n        signal: AbortSignal | undefined,\n    ) => Promise<AdbShellProtocolProcess>;\n\n    constructor(\n        spawn: (\n            command: readonly string[],\n            signal: AbortSignal | undefined,\n        ) => Promise<AdbShellProtocolProcess>,\n    ) {\n        this.#spawn = spawn;\n    }\n\n    spawn(\n        command: string | readonly string[],\n        signal?: AbortSignal,\n    ): Promise<AdbShellProtocolProcess> {\n        signal?.throwIfAborted();\n\n        if (typeof command === \"string\") {\n            command = splitCommand(command);\n        }\n\n        return this.#spawn(command, signal);\n    }\n\n    async spawnWait(\n        command: string | readonly string[],\n    ): Promise<AdbShellProtocolSpawner.WaitResult<Uint8Array>> {\n        const process = await this.spawn(command);\n        const [stdout, stderr, exitCode] = await Promise.all([\n            process.stdout.pipeThrough(new ConcatBufferStream()),\n            process.stderr.pipeThrough(new ConcatBufferStream()),\n            process.exited,\n        ]);\n        return { stdout, stderr, exitCode };\n    }\n\n    async spawnWaitText(\n        command: string | readonly string[],\n    ): Promise<AdbShellProtocolSpawner.WaitResult<string>> {\n        const process = await this.spawn(command);\n        const [stdout, stderr, exitCode] = await Promise.all([\n            process.stdout\n                .pipeThrough(new TextDecoderStream())\n                .pipeThrough(new ConcatStringStream()),\n            process.stderr\n                .pipeThrough(new TextDecoderStream())\n                .pipeThrough(new ConcatStringStream()),\n            process.exited,\n        ]);\n        return { stdout, stderr, exitCode };\n    }\n}\n\nexport namespace AdbShellProtocolSpawner {\n    export interface WaitResult<T> {\n        stdout: T;\n        stderr: T;\n        exitCode: number;\n    }\n}\n", "import type { Adb } from \"../../../adb.js\";\nimport { AdbFeature } from \"../../../features.js\";\n\nimport { AdbShellProtocolProcessImpl } from \"./process.js\";\nimport { AdbShellProtocolPtyProcess } from \"./pty.js\";\nimport { AdbShellProtocolSpawner } from \"./spawner.js\";\n\nexport class AdbShellProtocolSubprocessService extends AdbShellProtocolSpawner {\n    readonly #adb: Adb;\n    get adb() {\n        return this.#adb;\n    }\n\n    get isSupported() {\n        return this.#adb.canUseFeature(AdbFeature.ShellV2);\n    }\n\n    constructor(adb: Adb) {\n        super(async (command, signal) => {\n            const socket = await this.#adb.createSocket(\n                `shell,v2,raw:${command.join(\" \")}`,\n            );\n\n            if (signal?.aborted) {\n                await socket.close();\n                throw signal.reason;\n            }\n\n            return new AdbShellProtocolProcessImpl(socket, signal);\n        });\n        this.#adb = adb;\n    }\n\n    async pty(options?: {\n        command?: string | readonly string[] | undefined;\n        terminalType?: string;\n    }): Promise<AdbShellProtocolPtyProcess> {\n        let service = \"shell,v2,pty\";\n\n        if (options?.terminalType) {\n            service += `,TERM=` + options.terminalType;\n        }\n\n        service += \":\";\n\n        if (options) {\n            if (typeof options.command === \"string\") {\n                service += options.command;\n            } else if (Array.isArray(options.command)) {\n                service += options.command.join(\" \");\n            }\n        }\n\n        return new AdbShellProtocolPtyProcess(\n            await this.#adb.createSocket(service),\n        );\n    }\n}\n", "import type { Adb } from \"../../adb.js\";\nimport { AdbFeature } from \"../../features.js\";\n\nimport { AdbNoneProtocolSubprocessService } from \"./none/index.js\";\nimport { AdbShellProtocolSubprocessService } from \"./shell/index.js\";\n\nexport class AdbSubprocessService {\n    readonly #adb: Adb;\n    get adb() {\n        return this.#adb;\n    }\n\n    readonly #noneProtocol: AdbNoneProtocolSubprocessService;\n    get noneProtocol(): AdbNoneProtocolSubprocessService {\n        return this.#noneProtocol;\n    }\n\n    readonly #shellProtocol?: AdbShellProtocolSubprocessService;\n    get shellProtocol(): AdbShellProtocolSubprocessService | undefined {\n        return this.#shellProtocol;\n    }\n\n    constructor(adb: Adb) {\n        this.#adb = adb;\n\n        this.#noneProtocol = new AdbNoneProtocolSubprocessService(adb);\n\n        if (adb.canUseFeature(AdbFeature.ShellV2)) {\n            this.#shellProtocol = new AdbShellProtocolSubprocessService(adb);\n        }\n    }\n}\n", "import { getUint32LittleEndian } from \"@yume-chan/no-data-view\";\nimport type { AsyncExactReadable, StructDeserializer } from \"@yume-chan/struct\";\nimport { decodeUtf8, string, struct, u32 } from \"@yume-chan/struct\";\n\nimport { unreachable } from \"../../utils/no-op.js\";\n\nfunction encodeAsciiUnchecked(value: string): Uint8Array<ArrayBuffer> {\n    const result = new Uint8Array(value.length);\n    for (let i = 0; i < value.length; i += 1) {\n        result[i] = value.charCodeAt(i);\n    }\n    return result;\n}\n\n/**\n * Encode ID to numbers for faster comparison\n * @param value A 4-character string\n * @returns A 32-bit integer by encoding the string as little-endian\n *\n * #__NO_SIDE_EFFECTS__\n */\nexport function adbSyncEncodeId(value: string): number {\n    const buffer = encodeAsciiUnchecked(value);\n    return getUint32LittleEndian(buffer, 0);\n}\n\nexport const AdbSyncResponseId = {\n    Entry: adbSyncEncodeId(\"DENT\"),\n    Entry2: adbSyncEncodeId(\"DNT2\"),\n    Lstat: adbSyncEncodeId(\"STAT\"),\n    Stat: adbSyncEncodeId(\"STA2\"),\n    Lstat2: adbSyncEncodeId(\"LST2\"),\n    Done: adbSyncEncodeId(\"DONE\"),\n    Data: adbSyncEncodeId(\"DATA\"),\n    Ok: adbSyncEncodeId(\"OKAY\"),\n    Fail: adbSyncEncodeId(\"FAIL\"),\n};\n\nexport class AdbSyncError extends Error {}\n\nexport const AdbSyncFailResponse = struct(\n    { message: string(u32) },\n    {\n        littleEndian: true,\n        postDeserialize(value) {\n            throw new AdbSyncError(value.message);\n        },\n    },\n);\n\nexport async function adbSyncReadResponse<T>(\n    stream: AsyncExactReadable,\n    id: number | string,\n    type: StructDeserializer<T>,\n): Promise<T> {\n    if (typeof id === \"string\") {\n        id = adbSyncEncodeId(id);\n    }\n\n    const buffer = await stream.readExactly(4);\n    switch (getUint32LittleEndian(buffer, 0)) {\n        case AdbSyncResponseId.Fail:\n            await AdbSyncFailResponse.deserialize(stream);\n            throw new Error(\"Unreachable\");\n        case id:\n            return await type.deserialize(stream);\n        default:\n            throw new Error(\n                `Expected '${id}', but got '${decodeUtf8(buffer)}'`,\n            );\n    }\n}\n\nexport async function* adbSyncReadResponses<T>(\n    stream: AsyncExactReadable,\n    id: number | string,\n    type: StructDeserializer<T>,\n): AsyncGenerator<T, void, void> {\n    if (typeof id === \"string\") {\n        id = adbSyncEncodeId(id);\n    }\n\n    while (true) {\n        const buffer = await stream.readExactly(4);\n        switch (getUint32LittleEndian(buffer, 0)) {\n            case AdbSyncResponseId.Fail:\n                await AdbSyncFailResponse.deserialize(stream);\n                unreachable();\n            case AdbSyncResponseId.Done:\n                // `DONE` responses' size are always same as the request's normal response.\n                //\n                // For example, `DONE` responses for `LIST` requests are 16 bytes (same as `DENT` responses),\n                // but `DONE` responses for `STAT` requests are 12 bytes (same as `STAT` responses).\n                await stream.readExactly(type.size);\n                return;\n            case id:\n                yield await type.deserialize(stream);\n                break;\n            default:\n                throw new Error(\n                    `Expected '${id}' or '${AdbSyncResponseId.Done}', but got '${decodeUtf8(buffer)}'`,\n                );\n        }\n    }\n}\n", "import { encodeUtf8, struct, u32 } from \"@yume-chan/struct\";\n\nimport { adbSyncEncodeId } from \"./response.js\";\n\nexport const AdbSyncRequestId = {\n    List: adbSyncEncodeId(\"LIST\"),\n    ListV2: adbSyncEncodeId(\"LIS2\"),\n    Send: adbSyncEncodeId(\"SEND\"),\n    SendV2: adbSyncEncodeId(\"SND2\"),\n    Lstat: adbSyncEncodeId(\"STAT\"),\n    Stat: adbSyncEncodeId(\"STA2\"),\n    LstatV2: adbSyncEncodeId(\"LST2\"),\n    Data: adbSyncEncodeId(\"DATA\"),\n    Done: adbSyncEncodeId(\"DONE\"),\n    Receive: adbSyncEncodeId(\"RECV\"),\n} as const;\n\nexport const AdbSyncNumberRequest = struct(\n    { id: u32, arg: u32 },\n    { littleEndian: true },\n);\n\nexport interface AdbSyncWritable {\n    write(buffer: Uint8Array): Promise<void>;\n}\n\nexport async function adbSyncWriteRequest(\n    writable: AdbSyncWritable,\n    id: number | string,\n    value: number | string | Uint8Array,\n): Promise<void> {\n    if (typeof id === \"string\") {\n        id = adbSyncEncodeId(id);\n    }\n\n    if (typeof value === \"number\") {\n        await writable.write(\n            AdbSyncNumberRequest.serialize({ id, arg: value }),\n        );\n        return;\n    }\n\n    if (typeof value === \"string\") {\n        value = encodeUtf8(value);\n    }\n\n    // `writable` is buffered, it copies inputs to an internal buffer,\n    // so don't concatenate headers and data here, that will be an unnecessary copy.\n    await writable.write(\n        AdbSyncNumberRequest.serialize({ id, arg: value.length }),\n    );\n    await writable.write(value);\n}\n", "import type { StructValue } from \"@yume-chan/struct\";\nimport { struct, u32, u64 } from \"@yume-chan/struct\";\n\nimport { AdbSyncRequestId, adbSyncWriteRequest } from \"./request.js\";\nimport { AdbSyncResponseId, adbSyncReadResponse } from \"./response.js\";\nimport type { AdbSyncSocket } from \"./socket.js\";\n\n// https://github.com/python/cpython/blob/4e581d64b8aff3e2eda99b12f080c877bb78dfca/Lib/stat.py#L36\nexport const LinuxFileType = {\n    Directory: 0o04,\n    File: 0o10,\n    Link: 0o12,\n} as const;\n\nexport type LinuxFileType = (typeof LinuxFileType)[keyof typeof LinuxFileType];\n\nexport interface AdbSyncStat {\n    mode: number;\n    size: bigint;\n    mtime: bigint;\n    get type(): LinuxFileType;\n    get permission(): number;\n\n    uid?: number;\n    gid?: number;\n    atime?: bigint;\n    ctime?: bigint;\n}\n\nexport const AdbSyncLstatResponse = struct(\n    { mode: u32, size: u32, mtime: u32 },\n    {\n        littleEndian: true,\n        extra: {\n            get type(): LinuxFileType {\n                return (this.mode >> 12) as LinuxFileType;\n            },\n            get permission(): number {\n                return this.mode & 0b00001111_11111111;\n            },\n        },\n        postDeserialize(value) {\n            if (value.mode === 0 && value.size === 0 && value.mtime === 0) {\n                throw new Error(\"lstat error\");\n            }\n            return value;\n        },\n    },\n);\n\nexport type AdbSyncLstatResponse = StructValue<typeof AdbSyncLstatResponse>;\n\nexport const AdbSyncStatErrorCode = {\n    SUCCESS: 0,\n    EACCES: 13,\n    EEXIST: 17,\n    EFAULT: 14,\n    EFBIG: 27,\n    EINTR: 4,\n    EINVAL: 22,\n    EIO: 5,\n    EISDIR: 21,\n    ELOOP: 40,\n    EMFILE: 24,\n    ENAMETOOLONG: 36,\n    ENFILE: 23,\n    ENOENT: 2,\n    ENOMEM: 12,\n    ENOSPC: 28,\n    ENOTDIR: 20,\n    EOVERFLOW: 75,\n    EPERM: 1,\n    EROFS: 30,\n    ETXTBSY: 26,\n} as const;\n\nexport type AdbSyncStatErrorCode =\n    (typeof AdbSyncStatErrorCode)[keyof typeof AdbSyncStatErrorCode];\n\nconst AdbSyncStatErrorName = /* #__PURE__ */ (() =>\n    Object.fromEntries(\n        Object.entries(AdbSyncStatErrorCode).map(([key, value]) => [\n            value,\n            key,\n        ]),\n    ))();\n\nexport const AdbSyncStatResponse = struct(\n    {\n        error: u32<AdbSyncStatErrorCode>(),\n        dev: u64,\n        ino: u64,\n        mode: u32,\n        nlink: u32,\n        uid: u32,\n        gid: u32,\n        size: u64,\n        atime: u64,\n        mtime: u64,\n        ctime: u64,\n    },\n    {\n        littleEndian: true,\n        extra: {\n            get type(): LinuxFileType {\n                return (this.mode >> 12) as LinuxFileType;\n            },\n            get permission(): number {\n                return this.mode & 0b00001111_11111111;\n            },\n        },\n        postDeserialize(value) {\n            if (value.error) {\n                throw new Error(AdbSyncStatErrorName[value.error]);\n            }\n            return value;\n        },\n    },\n);\n\nexport type AdbSyncStatResponse = StructValue<typeof AdbSyncStatResponse>;\n\nexport async function adbSyncLstat(\n    socket: AdbSyncSocket,\n    path: string,\n    v2: boolean,\n): Promise<AdbSyncStat> {\n    const locked = await socket.lock();\n    try {\n        if (v2) {\n            await adbSyncWriteRequest(locked, AdbSyncRequestId.LstatV2, path);\n            return await adbSyncReadResponse(\n                locked,\n                AdbSyncResponseId.Lstat2,\n                AdbSyncStatResponse,\n            );\n        } else {\n            await adbSyncWriteRequest(locked, AdbSyncRequestId.Lstat, path);\n            const response = await adbSyncReadResponse(\n                locked,\n                AdbSyncResponseId.Lstat,\n                AdbSyncLstatResponse,\n            );\n            return {\n                mode: response.mode,\n                // Convert to `BigInt` to make it compatible with `AdbSyncStatResponse`\n                size: BigInt(response.size),\n                mtime: BigInt(response.mtime),\n                get type() {\n                    return response.type;\n                },\n                get permission() {\n                    return response.permission;\n                },\n            };\n        }\n    } finally {\n        locked.release();\n    }\n}\n\nexport async function adbSyncStat(\n    socket: AdbSyncSocket,\n    path: string,\n): Promise<AdbSyncStatResponse> {\n    const locked = await socket.lock();\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.Stat, path);\n        return await adbSyncReadResponse(\n            locked,\n            AdbSyncResponseId.Stat,\n            AdbSyncStatResponse,\n        );\n    } finally {\n        locked.release();\n    }\n}\n", "import type { StructValue } from \"@yume-chan/struct\";\nimport { extend, string, u32 } from \"@yume-chan/struct\";\n\nimport { AdbSyncRequestId, adbSyncWriteRequest } from \"./request.js\";\nimport { AdbSyncResponseId, adbSyncReadResponses } from \"./response.js\";\nimport type { AdbSyncSocket } from \"./socket.js\";\nimport type { AdbSyncStat } from \"./stat.js\";\nimport {\n    AdbSyncLstatResponse,\n    AdbSyncStatErrorCode,\n    AdbSyncStatResponse,\n} from \"./stat.js\";\n\nexport interface AdbSyncEntry extends AdbSyncStat {\n    name: string;\n}\n\nexport const AdbSyncEntryResponse = extend(AdbSyncLstatResponse, {\n    name: string(u32),\n});\n\nexport type AdbSyncEntryResponse = StructValue<typeof AdbSyncEntryResponse>;\n\nexport const AdbSyncEntry2Response = extend(AdbSyncStatResponse, {\n    name: string(u32),\n});\n\nexport type AdbSyncEntry2Response = StructValue<typeof AdbSyncEntry2Response>;\n\nexport async function* adbSyncOpenDirV2(\n    socket: AdbSyncSocket,\n    path: string,\n): AsyncGenerator<AdbSyncEntry2Response, void, void> {\n    const locked = await socket.lock();\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.ListV2, path);\n        for await (const item of adbSyncReadResponses(\n            locked,\n            AdbSyncResponseId.Entry2,\n            AdbSyncEntry2Response,\n        )) {\n            // `LST2` can return error codes for failed `lstat` calls.\n            // `LIST` just ignores them.\n            // But they only contain `name` so still pretty useless.\n            if (item.error !== AdbSyncStatErrorCode.SUCCESS) {\n                continue;\n            }\n            yield item;\n        }\n    } finally {\n        locked.release();\n    }\n}\n\nexport async function* adbSyncOpenDirV1(\n    socket: AdbSyncSocket,\n    path: string,\n): AsyncGenerator<AdbSyncEntryResponse, void, void> {\n    const locked = await socket.lock();\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.List, path);\n        for await (const item of adbSyncReadResponses(\n            locked,\n            AdbSyncResponseId.Entry,\n            AdbSyncEntryResponse,\n        )) {\n            yield item;\n        }\n    } finally {\n        locked.release();\n    }\n}\n\nexport async function* adbSyncOpenDir(\n    socket: AdbSyncSocket,\n    path: string,\n    v2: boolean,\n): AsyncGenerator<AdbSyncEntry, void, void> {\n    if (v2) {\n        yield* adbSyncOpenDirV2(socket, path);\n    } else {\n        for await (const item of adbSyncOpenDirV1(socket, path)) {\n            // Convert to same format as `AdbSyncEntry2Response` for easier consumption.\n            // However it will add some overhead.\n            yield {\n                mode: item.mode,\n                size: BigInt(item.size),\n                mtime: BigInt(item.mtime),\n                get type() {\n                    return item.type;\n                },\n                get permission() {\n                    return item.permission;\n                },\n                name: item.name,\n            };\n        }\n    }\n}\n", "import { ReadableStream } from \"@yume-chan/stream-extra\";\nimport type { StructValue } from \"@yume-chan/struct\";\nimport { buffer, struct, u32 } from \"@yume-chan/struct\";\n\nimport { AdbSyncRequestId, adbSyncWriteRequest } from \"./request.js\";\nimport { adbSyncReadResponses, AdbSyncResponseId } from \"./response.js\";\nimport type { AdbSyncSocket } from \"./socket.js\";\n\nexport const AdbSyncDataResponse = struct(\n    { data: buffer(u32) },\n    { littleEndian: true },\n);\n\nexport type AdbSyncDataResponse = StructValue<typeof AdbSyncDataResponse>;\n\nexport async function* adbSyncPullGenerator(\n    socket: AdbSyncSocket,\n    path: string,\n): AsyncGenerator<Uint8Array, void, void> {\n    const locked = await socket.lock();\n    let done = false;\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.Receive, path);\n        for await (const packet of adbSyncReadResponses(\n            locked,\n            AdbSyncResponseId.Data,\n            AdbSyncDataResponse,\n        )) {\n            yield packet.data;\n        }\n        done = true;\n    } catch (e) {\n        done = true;\n        throw e;\n    } finally {\n        if (!done) {\n            // sync pull can't be cancelled, so we have to read all data\n            for await (const packet of adbSyncReadResponses(\n                locked,\n                AdbSyncResponseId.Data,\n                AdbSyncDataResponse,\n            )) {\n                void packet;\n            }\n        }\n        locked.release();\n    }\n}\n\nexport function adbSyncPull(\n    socket: AdbSyncSocket,\n    path: string,\n): ReadableStream<Uint8Array> {\n    return ReadableStream.from(adbSyncPullGenerator(socket, path));\n}\n", "import type { ReadableStream } from \"@yume-chan/stream-extra\";\nimport {\n    AbortController,\n    DistributionStream,\n    MaybeConsumable,\n} from \"@yume-chan/stream-extra\";\nimport { struct, u32 } from \"@yume-chan/struct\";\n\nimport { NOOP } from \"../../utils/index.js\";\n\nimport { AdbSyncRequestId, adbSyncWriteRequest } from \"./request.js\";\nimport { AdbSyncResponseId, adbSyncReadResponse } from \"./response.js\";\nimport type { AdbSyncSocket, AdbSyncSocketLocked } from \"./socket.js\";\nimport { LinuxFileType } from \"./stat.js\";\n\nexport const ADB_SYNC_MAX_PACKET_SIZE = 64 * 1024;\n\nexport interface AdbSyncPushV1Options {\n    socket: AdbSyncSocket;\n    filename: string;\n    file: ReadableStream<MaybeConsumable<Uint8Array>>;\n    type?: LinuxFileType;\n    permission?: number;\n    mtime?: number;\n    packetSize?: number;\n}\n\nexport const AdbSyncOkResponse = struct(\n    { unused: u32 },\n    { littleEndian: true },\n);\n\nasync function pipeFileData(\n    locked: AdbSyncSocketLocked,\n    file: ReadableStream<MaybeConsumable<Uint8Array>>,\n    packetSize: number,\n    mtime: number,\n) {\n    // Read and write in parallel,\n    // allow error response to abort the write.\n    const abortController = new AbortController();\n    file.pipeThrough(new DistributionStream(packetSize, true))\n        .pipeTo(\n            new MaybeConsumable.WritableStream({\n                write(chunk) {\n                    return adbSyncWriteRequest(\n                        locked,\n                        AdbSyncRequestId.Data,\n                        chunk,\n                    );\n                },\n            }),\n            { signal: abortController.signal },\n        )\n        .then(async () => {\n            await adbSyncWriteRequest(locked, AdbSyncRequestId.Done, mtime);\n            await locked.flush();\n        }, NOOP);\n\n    await adbSyncReadResponse(\n        locked,\n        AdbSyncResponseId.Ok,\n        AdbSyncOkResponse,\n    ).catch((e) => {\n        abortController.abort();\n        throw e;\n    });\n}\n\nexport async function adbSyncPushV1({\n    socket,\n    filename,\n    file,\n    type = LinuxFileType.File,\n    permission = 0o666,\n    mtime = (Date.now() / 1000) | 0,\n    packetSize = ADB_SYNC_MAX_PACKET_SIZE,\n}: AdbSyncPushV1Options) {\n    const locked = await socket.lock();\n    try {\n        const mode = (type << 12) | permission;\n        const pathAndMode = `${filename},${mode.toString()}`;\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.Send, pathAndMode);\n        await pipeFileData(locked, file, packetSize, mtime);\n    } finally {\n        locked.release();\n    }\n}\n\nexport const AdbSyncSendV2Flags = {\n    None: 0,\n    Brotli: 1,\n    /**\n     * 2\n     */\n    Lz4: 1 << 1,\n    /**\n     * 4\n     */\n    Zstd: 1 << 2,\n    DryRun: 0x80000000,\n} as const;\n\nexport type AdbSyncSendV2Flags =\n    (typeof AdbSyncSendV2Flags)[keyof typeof AdbSyncSendV2Flags];\n\nexport interface AdbSyncPushV2Options extends AdbSyncPushV1Options {\n    /**\n     * Don't write the file to disk. Requires the `sendrecv_v2` feature.\n     *\n     * It was used during ADB development to benchmark the performance of\n     * compression algorithms.\n     */\n    dryRun?: boolean;\n}\n\nexport const AdbSyncSendV2Request = struct(\n    { id: u32, mode: u32, flags: u32<AdbSyncSendV2Flags>() },\n    { littleEndian: true },\n);\n\nexport async function adbSyncPushV2({\n    socket,\n    filename,\n    file,\n    type = LinuxFileType.File,\n    permission = 0o666,\n    mtime = (Date.now() / 1000) | 0,\n    packetSize = ADB_SYNC_MAX_PACKET_SIZE,\n    dryRun = false,\n}: AdbSyncPushV2Options) {\n    const locked = await socket.lock();\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.SendV2, filename);\n\n        const mode = (type << 12) | permission;\n        let flags: AdbSyncSendV2Flags = AdbSyncSendV2Flags.None;\n        if (dryRun) {\n            flags |= AdbSyncSendV2Flags.DryRun;\n        }\n        await locked.write(\n            AdbSyncSendV2Request.serialize({\n                id: AdbSyncRequestId.SendV2,\n                mode,\n                flags,\n            }),\n        );\n\n        await pipeFileData(locked, file, packetSize, mtime);\n    } finally {\n        locked.release();\n    }\n}\n\nexport interface AdbSyncPushOptions extends AdbSyncPushV2Options {\n    /**\n     * Whether to use the v2 protocol. Requires the `sendrecv_v2` feature.\n     */\n    v2: boolean;\n}\n\nexport function adbSyncPush(options: AdbSyncPushOptions) {\n    if (options.v2) {\n        return adbSyncPushV2(options);\n    }\n\n    if (options.dryRun) {\n        throw new Error(\"dryRun is not supported in v1\");\n    }\n\n    return adbSyncPushV1(options);\n}\n", "import type {\n    MaybeConsumable,\n    WritableStreamDefaultWriter,\n} from \"@yume-chan/stream-extra\";\nimport {\n    BufferCombiner,\n    BufferedReadableStream,\n    Consumable,\n} from \"@yume-chan/stream-extra\";\nimport type { AsyncExactReadable } from \"@yume-chan/struct\";\n\nimport type { AdbSocket } from \"../../adb.js\";\nimport { AutoResetEvent } from \"../../utils/index.js\";\n\nexport class AdbSyncSocketLocked implements AsyncExactReadable {\n    readonly #writer: WritableStreamDefaultWriter<MaybeConsumable<Uint8Array>>;\n    readonly #readable: BufferedReadableStream;\n    readonly #socketLock: AutoResetEvent;\n    readonly #writeLock = new AutoResetEvent();\n    readonly #combiner: BufferCombiner;\n\n    get position() {\n        return this.#readable.position;\n    }\n\n    constructor(\n        writer: WritableStreamDefaultWriter<MaybeConsumable<Uint8Array>>,\n        readable: BufferedReadableStream,\n        bufferSize: number,\n        lock: AutoResetEvent,\n    ) {\n        this.#writer = writer;\n        this.#readable = readable;\n        this.#socketLock = lock;\n        this.#combiner = new BufferCombiner(bufferSize);\n    }\n\n    #write(buffer: Uint8Array) {\n        // `#combiner` will reuse the buffer, so we need to use the Consumable pattern\n        return Consumable.WritableStream.write(this.#writer, buffer);\n    }\n\n    async flush() {\n        try {\n            await this.#writeLock.wait();\n            const buffer = this.#combiner.flush();\n            if (buffer) {\n                await this.#write(buffer);\n            }\n        } finally {\n            this.#writeLock.notifyOne();\n        }\n    }\n\n    async write(data: Uint8Array) {\n        try {\n            await this.#writeLock.wait();\n            for (const buffer of this.#combiner.push(data)) {\n                await this.#write(buffer);\n            }\n        } finally {\n            this.#writeLock.notifyOne();\n        }\n    }\n\n    async readExactly(length: number) {\n        // The request may still be in the internal buffer.\n        // Call `flush` to send it before starting reading\n        await this.flush();\n        return await this.#readable.readExactly(length);\n    }\n\n    release(): void {\n        // In theory, the writer shouldn't leave anything in the buffer,\n        // but to be safe, call `flush` to throw away any remaining data.\n        this.#combiner.flush();\n        this.#socketLock.notifyOne();\n    }\n\n    async close() {\n        await this.#readable.cancel();\n    }\n}\n\nexport class AdbSyncSocket {\n    readonly #lock = new AutoResetEvent();\n    readonly #socket: AdbSocket;\n    readonly #locked: AdbSyncSocketLocked;\n\n    constructor(socket: AdbSocket, bufferSize: number) {\n        this.#socket = socket;\n        this.#locked = new AdbSyncSocketLocked(\n            socket.writable.getWriter(),\n            new BufferedReadableStream(socket.readable),\n            bufferSize,\n            this.#lock,\n        );\n    }\n\n    async lock() {\n        await this.#lock.wait();\n        return this.#locked;\n    }\n\n    async close() {\n        await this.#locked.close();\n        await this.#socket.close();\n    }\n}\n", "import type { MaybeConsumable, ReadableStream } from \"@yume-chan/stream-extra\";\n\nimport type { Adb, AdbSocket } from \"../../adb.js\";\nimport { AdbFeature } from \"../../features.js\";\nimport { escapeArg } from \"../subprocess/index.js\";\n\nimport type { AdbSyncEntry } from \"./list.js\";\nimport { adbSyncOpenDir } from \"./list.js\";\nimport { adbSyncPull } from \"./pull.js\";\nimport { adbSyncPush } from \"./push.js\";\nimport type { AdbSyncSocketLocked } from \"./socket.js\";\nimport { AdbSyncSocket } from \"./socket.js\";\nimport type { AdbSyncStat, LinuxFileType } from \"./stat.js\";\nimport { adbSyncLstat, adbSyncStat } from \"./stat.js\";\n\n/**\n * A simplified `dirname` function that only handles absolute unix paths.\n * @param path an absolute unix path\n * @returns the directory name of the input path\n */\nexport function dirname(path: string): string {\n    const end = path.lastIndexOf(\"/\");\n    if (end === -1) {\n        throw new Error(`Invalid path`);\n    }\n    if (end === 0) {\n        return \"/\";\n    }\n    return path.substring(0, end);\n}\n\nexport interface AdbSyncWriteOptions {\n    filename: string;\n    file: ReadableStream<MaybeConsumable<Uint8Array>>;\n    type?: LinuxFileType;\n    permission?: number;\n    mtime?: number;\n    dryRun?: boolean;\n}\n\nexport class AdbSync {\n    protected _adb: Adb;\n    protected _socket: AdbSyncSocket;\n\n    readonly #supportsStat: boolean;\n    readonly #supportsListV2: boolean;\n    readonly #fixedPushMkdir: boolean;\n    readonly #supportsSendReceiveV2: boolean;\n    readonly #needPushMkdirWorkaround: boolean;\n\n    get supportsStat(): boolean {\n        return this.#supportsStat;\n    }\n\n    get supportsListV2(): boolean {\n        return this.#supportsListV2;\n    }\n\n    get fixedPushMkdir(): boolean {\n        return this.#fixedPushMkdir;\n    }\n\n    get supportsSendReceiveV2(): boolean {\n        return this.#supportsSendReceiveV2;\n    }\n\n    get needPushMkdirWorkaround(): boolean {\n        return this.#needPushMkdirWorkaround;\n    }\n\n    constructor(adb: Adb, socket: AdbSocket) {\n        this._adb = adb;\n        this._socket = new AdbSyncSocket(socket, adb.maxPayloadSize);\n\n        this.#supportsStat = adb.canUseFeature(AdbFeature.StatV2);\n        this.#supportsListV2 = adb.canUseFeature(AdbFeature.ListV2);\n        this.#fixedPushMkdir = adb.canUseFeature(AdbFeature.FixedPushMkdir);\n        this.#supportsSendReceiveV2 = adb.canUseFeature(\n            AdbFeature.SendReceiveV2,\n        );\n        // https://android.googlesource.com/platform/packages/modules/adb/+/91768a57b7138166e0a3d11f79cd55909dda7014/client/file_sync_client.cpp#1361\n        this.#needPushMkdirWorkaround =\n            this._adb.canUseFeature(AdbFeature.ShellV2) && !this.fixedPushMkdir;\n    }\n\n    /**\n     * Gets information of a file or folder.\n     *\n     * If `path` points to a symbolic link, the returned information is about the link itself (with `type` being `LinuxFileType.Link`).\n     */\n    async lstat(path: string): Promise<AdbSyncStat> {\n        return await adbSyncLstat(this._socket, path, this.#supportsStat);\n    }\n\n    /**\n     * Gets the information of a file or folder.\n     *\n     * If `path` points to a symbolic link, it will be resolved and the returned information is about the target (with `type` being `LinuxFileType.File` or `LinuxFileType.Directory`).\n     */\n    async stat(path: string) {\n        if (!this.#supportsStat) {\n            throw new Error(\"Not supported\");\n        }\n\n        return await adbSyncStat(this._socket, path);\n    }\n\n    /**\n     * Checks if `path` is a directory, or a symbolic link to a directory.\n     *\n     * This uses `lstat` internally, thus works on all Android versions.\n     */\n    async isDirectory(path: string): Promise<boolean> {\n        try {\n            await this.lstat(path + \"/\");\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    opendir(path: string): AsyncGenerator<AdbSyncEntry, void, void> {\n        return adbSyncOpenDir(this._socket, path, this.supportsListV2);\n    }\n\n    async readdir(path: string) {\n        const results: AdbSyncEntry[] = [];\n        for await (const entry of this.opendir(path)) {\n            results.push(entry);\n        }\n        return results;\n    }\n\n    /**\n     * Reads the content of a file on device.\n     *\n     * @param filename The full path of the file on device to read.\n     * @returns A `ReadableStream` that contains the file content.\n     */\n    read(filename: string): ReadableStream<Uint8Array> {\n        return adbSyncPull(this._socket, filename);\n    }\n\n    /**\n     * Writes a file on device. If the file name already exists, it will be overwritten.\n     *\n     * @param options The content and options of the file to write.\n     */\n    async write(options: AdbSyncWriteOptions): Promise<void> {\n        if (this.needPushMkdirWorkaround) {\n            // It may fail if `filename` already exists.\n            // Ignore the result.\n            // TODO: sync: test push mkdir workaround (need an Android 8 device)\n            await this._adb.subprocess.noneProtocol.spawnWait([\n                \"mkdir\",\n                \"-p\",\n                escapeArg(dirname(options.filename)),\n            ]);\n        }\n\n        await adbSyncPush({\n            v2: this.supportsSendReceiveV2,\n            socket: this._socket,\n            ...options,\n        });\n    }\n\n    lockSocket(): Promise<AdbSyncSocketLocked> {\n        return this._socket.lock();\n    }\n\n    dispose() {\n        return this._socket.close();\n    }\n}\n", "import { AdbServiceBase } from \"./base.js\";\n\n/**\n * ADB daemon checks for the following properties in the order of\n *\n * * `serviceListenAddresses` (`service.adb.listen_addrs`)\n * * `servicePort` (`service.adb.tcp.port`)\n * * `persistPort` (`persist.adb.tcp.port`)\n *\n * Once it finds a non-empty value, it will use it and ignore the rest.\n *\n * `serviceListenAddresses` and `persistPort` are fixed at build time,\n * only `servicePort` can be changed using `setPort` and `disable`.\n * This means if either `serviceListenAddresses` or `persistPort` is non-empty,\n * ADB over WiFi is always enabled.\n */\nexport interface AdbTcpIpListenAddresses {\n    serviceListenAddresses: string[];\n    servicePort: number | undefined;\n    persistPort: number | undefined;\n}\n\nfunction parsePort(value: string): number | undefined {\n    if (!value || value === \"0\") {\n        return undefined;\n    }\n    return Number.parseInt(value, 10);\n}\n\nexport class AdbTcpIpService extends AdbServiceBase {\n    async getListenAddresses(): Promise<AdbTcpIpListenAddresses> {\n        const serviceListenAddresses = await this.adb.getProp(\n            \"service.adb.listen_addrs\",\n        );\n        const servicePort = await this.adb.getProp(\"service.adb.tcp.port\");\n        const persistPort = await this.adb.getProp(\"persist.adb.tcp.port\");\n\n        return {\n            serviceListenAddresses:\n                serviceListenAddresses != \"\"\n                    ? serviceListenAddresses.split(\",\")\n                    : [],\n            servicePort: parsePort(servicePort),\n            persistPort: parsePort(persistPort),\n        };\n    }\n\n    async setPort(port: number): Promise<string> {\n        if (port <= 0) {\n            throw new TypeError(`Invalid port ${port}`);\n        }\n\n        const output = await this.adb.createSocketAndWait(`tcpip:${port}`);\n        if (output !== `restarting in TCP mode port: ${port}\\n`) {\n            throw new Error(output);\n        }\n        return output;\n    }\n\n    async disable(): Promise<string> {\n        const output = await this.adb.createSocketAndWait(\"usb:\");\n        if (output !== \"restarting in USB mode\\n\") {\n            throw new Error(output);\n        }\n        return output;\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport type {\n    MaybeConsumable,\n    ReadableWritablePair,\n} from \"@yume-chan/stream-extra\";\nimport { ConcatStringStream, TextDecoderStream } from \"@yume-chan/stream-extra\";\n\nimport type { AdbBanner } from \"./banner.js\";\nimport type { AdbFrameBuffer } from \"./commands/index.js\";\nimport {\n    AdbPower,\n    AdbReverseService,\n    AdbSubprocessService,\n    AdbSync,\n    AdbTcpIpService,\n    escapeArg,\n    framebuffer,\n} from \"./commands/index.js\";\nimport type { AdbFeature } from \"./features.js\";\n\nexport interface Closeable {\n    close(): MaybePromiseLike<void>;\n}\n\n/**\n * Represents an ADB socket.\n */\nexport interface AdbSocket\n    extends ReadableWritablePair<Uint8Array, MaybeConsumable<Uint8Array>>,\n        Closeable {\n    get service(): string;\n\n    get closed(): Promise<undefined>;\n}\n\nexport type AdbIncomingSocketHandler = (\n    socket: AdbSocket,\n) => MaybePromiseLike<void>;\n\nexport interface AdbTransport extends Closeable {\n    readonly serial: string;\n\n    readonly maxPayloadSize: number;\n\n    readonly banner: AdbBanner;\n\n    readonly disconnected: Promise<void>;\n\n    readonly clientFeatures: readonly AdbFeature[];\n\n    connect(service: string): MaybePromiseLike<AdbSocket>;\n\n    addReverseTunnel(\n        handler: AdbIncomingSocketHandler,\n        address?: string,\n    ): MaybePromiseLike<string>;\n\n    removeReverseTunnel(address: string): MaybePromiseLike<void>;\n\n    clearReverseTunnels(): MaybePromiseLike<void>;\n}\n\nexport class Adb implements Closeable {\n    readonly #transport: AdbTransport;\n    get transport(): AdbTransport {\n        return this.#transport;\n    }\n\n    get serial() {\n        return this.#transport.serial;\n    }\n\n    get maxPayloadSize() {\n        return this.#transport.maxPayloadSize;\n    }\n\n    get banner() {\n        return this.#transport.banner;\n    }\n\n    get disconnected() {\n        return this.#transport.disconnected;\n    }\n\n    public get clientFeatures() {\n        return this.#transport.clientFeatures;\n    }\n\n    public get deviceFeatures() {\n        return this.banner.features;\n    }\n\n    readonly subprocess: AdbSubprocessService;\n    readonly power: AdbPower;\n    readonly reverse: AdbReverseService;\n    readonly tcpip: AdbTcpIpService;\n\n    constructor(transport: AdbTransport) {\n        this.#transport = transport;\n\n        this.subprocess = new AdbSubprocessService(this);\n        this.power = new AdbPower(this);\n        this.reverse = new AdbReverseService(this);\n        this.tcpip = new AdbTcpIpService(this);\n    }\n\n    canUseFeature(feature: AdbFeature): boolean {\n        return (\n            this.clientFeatures.includes(feature) &&\n            this.deviceFeatures.includes(feature)\n        );\n    }\n\n    /**\n     * Creates a new ADB Socket to the specified service or socket address.\n     */\n    async createSocket(service: string): Promise<AdbSocket> {\n        return this.#transport.connect(service);\n    }\n\n    async createSocketAndWait(service: string): Promise<string> {\n        const socket = await this.createSocket(service);\n        return await socket.readable\n            .pipeThrough(new TextDecoderStream())\n            .pipeThrough(new ConcatStringStream());\n    }\n\n    getProp(key: string): Promise<string> {\n        return this.subprocess.noneProtocol\n            .spawnWaitText([\"getprop\", key])\n            .then((output) => output.trim());\n    }\n\n    rm(\n        filenames: string | readonly string[],\n        options?: { recursive?: boolean; force?: boolean },\n    ): Promise<string> {\n        const args = [\"rm\"];\n        if (options?.recursive) {\n            args.push(\"-r\");\n        }\n        if (options?.force) {\n            args.push(\"-f\");\n        }\n        if (Array.isArray(filenames)) {\n            for (const filename of filenames) {\n                // https://github.com/microsoft/typescript/issues/17002\n                args.push(escapeArg(filename as string));\n            }\n        } else {\n            // https://github.com/microsoft/typescript/issues/17002\n            args.push(escapeArg(filenames as string));\n        }\n        // https://android.googlesource.com/platform/packages/modules/adb/+/1a0fb8846d4e6b671c8aa7f137a8c21d7b248716/client/adb_install.cpp#984\n        args.push(\"</dev/null\");\n\n        return this.subprocess.noneProtocol.spawnWaitText(args);\n    }\n\n    async sync(): Promise<AdbSync> {\n        const socket = await this.createSocket(\"sync:\");\n        return new AdbSync(this, socket);\n    }\n\n    async framebuffer(): Promise<AdbFrameBuffer> {\n        return framebuffer(this);\n    }\n\n    async close(): Promise<void> {\n        await this.#transport.close();\n    }\n}\n", "import type { AdbFeature } from \"./features.js\";\n\nexport const AdbBannerKey = {\n    Product: \"ro.product.name\",\n    Model: \"ro.product.model\",\n    Device: \"ro.product.device\",\n    Features: \"features\",\n} as const;\n\nexport type AdbBannerKey = (typeof AdbBannerKey)[keyof typeof AdbBannerKey];\n\nexport class AdbBanner {\n    static parse(banner: string) {\n        let product: string | undefined;\n        let model: string | undefined;\n        let device: string | undefined;\n        let features: AdbFeature[] = [];\n\n        const pieces = banner.split(\"::\");\n        if (pieces.length > 1) {\n            const props = pieces[1]!;\n            for (const prop of props.split(\";\")) {\n                // istanbul ignore if\n                if (!prop) {\n                    continue;\n                }\n\n                const keyValue = prop.split(\"=\");\n                if (keyValue.length !== 2) {\n                    continue;\n                }\n\n                const [key, value] = keyValue;\n                switch (key) {\n                    case AdbBannerKey.Product:\n                        product = value;\n                        break;\n                    case AdbBannerKey.Model:\n                        model = value;\n                        break;\n                    case AdbBannerKey.Device:\n                        device = value;\n                        break;\n                    case AdbBannerKey.Features:\n                        features = value!.split(\",\") as AdbFeature[];\n                        break;\n                }\n            }\n        }\n\n        return new AdbBanner(product, model, device, features);\n    }\n\n    readonly #product: string | undefined;\n    get product() {\n        return this.#product;\n    }\n\n    readonly #model: string | undefined;\n    get model() {\n        return this.#model;\n    }\n\n    readonly #device: string | undefined;\n    get device() {\n        return this.#device;\n    }\n\n    readonly #features: readonly AdbFeature[] = [];\n    get features() {\n        return this.#features;\n    }\n\n    constructor(\n        product: string | undefined,\n        model: string | undefined,\n        device: string | undefined,\n        features: readonly AdbFeature[],\n    ) {\n        this.#product = product;\n        this.#model = model;\n        this.#device = device;\n        this.#features = features;\n    }\n}\n", "import {\n    getUint64BigEndian,\n    setInt64BigEndian,\n    setInt64LittleEndian,\n} from \"@yume-chan/no-data-view\";\n\n/**\n * Gets the `BigInt` value at the specified byte offset and length from the start of the view. There is\n * no alignment constraint; multi-byte values may be fetched from any offset.\n *\n * Only supports Big-Endian, because that's what ADB uses.\n * @param byteOffset The place in the buffer at which the value should be retrieved.\n */\nexport function getBigUint(\n    array: Uint8Array,\n    byteOffset: number,\n    length: number,\n): bigint {\n    let result = 0n;\n\n    // Currently `length` must be a multiplication of 8\n    // Support for arbitrary length can be easily added\n\n    for (let i = byteOffset; i < byteOffset + length; i += 8) {\n        result <<= 64n;\n        const value = getUint64BigEndian(array, i);\n        result |= value;\n    }\n\n    return result;\n}\n\n/**\n * Stores an arbitrary-precision positive `BigInt` value at the specified byte offset from the start of the view.\n * @param byteOffset The place in the buffer at which the value should be set.\n * @param length The number of bytes to set.\n * @param value The value to set.\n * @param littleEndian If `false` or `undefined`, a big-endian value should be written,\n * otherwise a little-endian value should be written.\n */\n\n// eslint-disable-next-line @typescript-eslint/max-params\nexport function setBigUint(\n    array: Uint8Array,\n    byteOffset: number,\n    length: number,\n    value: bigint,\n    littleEndian?: boolean,\n) {\n    if (littleEndian) {\n        while (value > 0n) {\n            setInt64LittleEndian(array, byteOffset, value);\n            byteOffset += 8;\n            value >>= 64n;\n        }\n    } else {\n        let position = byteOffset + length - 8;\n        while (value > 0n) {\n            setInt64BigEndian(array, position, value);\n            position -= 8;\n            value >>= 64n;\n        }\n    }\n}\n\n// These values are correct only if\n// modulus length is 2048 and\n// public exponent (e) is 65537\n// Anyway, that's how this library generates keys\n\n// To support other parameters,\n// a proper ASN.1 parser can be used\n\n// References:\n//\n//   https://tools.ietf.org/html/rfc8017#appendix-A.1.2\n//   PKCS #1: RSA Cryptography Specifications Version 2.2\n//     A.1.2.  RSA Private Key Syntax\n//\n//   https://lapo.it/asn1js/\n//   https://github.com/lapo-luchini/asn1js\n//   ASN.1 JavaScript decoder\n//\n//   https://www.itu.int/rec/T-REC-X.690-201508-I/en\n//   X.690: Specification of Distinguished Encoding Rules (DER)\n\nconst RsaPrivateKeyNOffset = 38;\nconst RsaPrivateKeyNLength = 2048 / 8;\nconst RsaPrivateKeyDOffset = 303;\nconst RsaPrivateKeyDLength = 2048 / 8;\n\nexport function rsaParsePrivateKey(key: Uint8Array): [n: bigint, d: bigint] {\n    const n = getBigUint(key, RsaPrivateKeyNOffset, RsaPrivateKeyNLength);\n    const d = getBigUint(key, RsaPrivateKeyDOffset, RsaPrivateKeyDLength);\n    return [n, d];\n}\n\nfunction nonNegativeMod(m: number, d: number) {\n    const r = m % d;\n    if (r > 0) {\n        return r;\n    }\n    return r + (d > 0 ? d : -d);\n}\n\n// https://en.wikipedia.org/wiki/Modular_multiplicative_inverse\n// Solve for the smallest positive `x` in the equation `a * x  1 (mod m)`,\n// or in other words, `a * x % m = 1`\n// Taken from https://stackoverflow.com/a/51562038\n// Only used with numbers smaller than 2^32 so doesn't need BigInt\nexport function modInverse(a: number, m: number) {\n    a = nonNegativeMod(a, m);\n    if (!a || m < 2) {\n        return NaN; // invalid input\n    }\n    // find the gcd\n    const s = [];\n    let b = m;\n    while (b) {\n        [a, b] = [b, a % b];\n        s.push({ a, b });\n    }\n    /* istanbul ignore next */\n    if (a !== 1) {\n        return NaN; // inverse does not exists\n    }\n    // find the inverse\n    let x = 1;\n    let y = 0;\n    for (let i = s.length - 2; i >= 0; i -= 1) {\n        [x, y] = [y, x - y * Math.floor(s[i]!.a / s[i]!.b)];\n    }\n    return nonNegativeMod(y, m);\n}\n\nconst ModulusLengthInBytes = 2048 / 8;\nconst ModulusLengthInWords = ModulusLengthInBytes / 4;\n\nexport function adbGetPublicKeySize() {\n    return 4 + 4 + ModulusLengthInBytes + ModulusLengthInBytes + 4;\n}\n\nexport function adbGeneratePublicKey(\n    privateKey: Uint8Array,\n): Uint8Array<ArrayBuffer>;\nexport function adbGeneratePublicKey(\n    privateKey: Uint8Array,\n    output: Uint8Array,\n): number;\nexport function adbGeneratePublicKey(\n    privateKey: Uint8Array,\n    output?: Uint8Array,\n): Uint8Array | number {\n    // cspell: ignore: mincrypt\n    // Android 6 and earlier has its own encryption library called mincrypt\n    // This is the RSA public key format used by mincrypt:\n    // https://android.googlesource.com/platform/system/core/+/bb0c180e62703c2068a1b2c9f8ba6d634bf1553c/include/mincrypt/rsa.h#46\n    // `n0inv` and `rr` are pre-calculated to speed up RSA operations\n\n    // Android 7 switched its encryption library to BoringSSL, but still keeps the key format:\n    // https://android.googlesource.com/platform/system/core.git/+/91784040db2b9273687f88d8b95f729d4a61ecc2/libcrypto_utils/android_pubkey.cpp#38\n    // Except when reading a key, `n0inv` and `rr` are ignored (they are still populated when generating a key):\n    // https://android.googlesource.com/platform/system/core.git/+/91784040db2b9273687f88d8b95f729d4a61ecc2/libcrypto_utils/android_pubkey.cpp#55\n\n    // The public key is a struct (in little endian) of:\n    //\n    // [\n    //   modulusLengthInWords, // 32-bit integer, a \"word\" is 32-bit so it must be 2048 / 8 / 4\n    //                         // (the comment in Android source code is incorrect saying \"This must be ANDROID_PUBKEY_MODULUS_SIZE\")\n    //   n0inv,                // 32-bit integer, the modular inverse of (lower 32 bits of `n`)\n    //   modulus,              // `n`\n    //   rr,                   // Montgomery parameter R^2\n    //   exponent,             // 32-bit integer, must be 3 or 65537\n    // ]\n\n    let outputType: \"Uint8Array\" | \"number\";\n    const outputLength = adbGetPublicKeySize();\n    if (!output) {\n        output = new Uint8Array(outputLength);\n        outputType = \"Uint8Array\";\n    } else {\n        if (output.length < outputLength) {\n            throw new TypeError(\"output buffer is too small\");\n        }\n\n        outputType = \"number\";\n    }\n\n    const outputView = new DataView(\n        output.buffer,\n        output.byteOffset,\n        output.length,\n    );\n    let outputOffset = 0;\n\n    // modulusLengthInWords\n    outputView.setUint32(outputOffset, ModulusLengthInWords, true);\n    outputOffset += 4;\n\n    // extract `n` from private key\n    const [n] = rsaParsePrivateKey(privateKey);\n\n    // Calculate `n0inv`\n    const n0inv = -modInverse(Number(n % 2n ** 32n), 2 ** 32);\n    outputView.setInt32(outputOffset, n0inv, true);\n    outputOffset += 4;\n\n    // Write `n` (a.k.a. `modulus`)\n    setBigUint(output, outputOffset, ModulusLengthInBytes, n, true);\n    outputOffset += ModulusLengthInBytes;\n\n    // Calculate rr = (2 ** (rsa_size)) ** 2 % n\n    const rr = 2n ** 4096n % n;\n    setBigUint(output, outputOffset, ModulusLengthInBytes, rr, true);\n    outputOffset += ModulusLengthInBytes;\n\n    // exponent\n    outputView.setUint32(outputOffset, 65537, true);\n    outputOffset += 4;\n\n    if (outputType === \"Uint8Array\") {\n        return output;\n    } else {\n        return outputLength;\n    }\n}\n\n/**\n * Modular exponentiation.\n *\n * Calculate `(base ** exponent) % modulus` without actually calculating `(base ** exponent)`.\n *\n * See https://en.wikipedia.org/wiki/Modular_exponentiation#Implementation_in_Lua\n */\nexport function powMod(\n    base: bigint,\n    exponent: bigint,\n    modulus: bigint,\n): bigint {\n    if (modulus === 1n) {\n        return 0n;\n    }\n\n    let r = 1n;\n    base = base % modulus;\n\n    while (exponent > 0n) {\n        if (BigInt.asUintN(1, exponent) === 1n) {\n            r = (r * base) % modulus;\n        }\n\n        base = (base * base) % modulus;\n        exponent >>= 1n;\n    }\n\n    return r;\n}\n\nexport const SHA1_DIGEST_LENGTH = 20;\n\nexport const ASN1_SEQUENCE = 0x30;\nexport const ASN1_OCTET_STRING = 0x04;\nexport const ASN1_NULL = 0x05;\nexport const ASN1_OID = 0x06;\n\n// PKCS#1 SHA-1 hash digest info\nexport const SHA1_DIGEST_INFO = new Uint8Array([\n    ASN1_SEQUENCE,\n    0x0d + SHA1_DIGEST_LENGTH,\n    ASN1_SEQUENCE,\n    0x09,\n    // SHA-1 (1 3 14 3 2 26)\n    ASN1_OID,\n    0x05,\n    1 * 40 + 3,\n    14,\n    3,\n    2,\n    26,\n    ASN1_NULL,\n    0x00,\n    ASN1_OCTET_STRING,\n    SHA1_DIGEST_LENGTH,\n]);\n\n// SubtleCrypto.sign() will hash the given data and sign the hash\n// But we don't need the hashing step\n// (In another word, ADB just requires the client to\n// encrypt the given data with its private key)\n// However SubtileCrypto.encrypt() doesn't accept 'RSASSA-PKCS1-v1_5' algorithm\n// So we need to implement the encryption by ourself\nexport function rsaSign(\n    privateKey: Uint8Array,\n    data: Uint8Array,\n): Uint8Array<ArrayBuffer> {\n    const [n, d] = rsaParsePrivateKey(privateKey);\n\n    // PKCS#1 padding\n    const padded = new Uint8Array(256);\n    let index = 0;\n\n    padded[index] = 0;\n    index += 1;\n\n    padded[index] = 1;\n    index += 1;\n\n    const fillLength =\n        padded.length - SHA1_DIGEST_INFO.length - data.length - 1;\n    while (index < fillLength) {\n        padded[index] = 0xff;\n        index += 1;\n    }\n\n    padded[index] = 0;\n    index += 1;\n\n    padded.set(SHA1_DIGEST_INFO, index);\n    index += SHA1_DIGEST_INFO.length;\n\n    padded.set(data, index);\n\n    // Encryption\n    // signature = padded ** d % n\n    const signature = powMod(getBigUint(padded, 0, padded.length), d, n);\n\n    // `padded` is not used anymore,\n    // re-use the buffer to store the result\n    setBigUint(padded, 0, padded.length, signature, false);\n\n    return padded;\n}\n", "import { Consumable, TransformStream } from \"@yume-chan/stream-extra\";\nimport type { StructInit, StructValue } from \"@yume-chan/struct\";\nimport { buffer, extend, s32, struct, u32 } from \"@yume-chan/struct\";\n\nexport const AdbCommand = {\n    Auth: 0x48545541, // 'AUTH'\n    Close: 0x45534c43, // 'CLSE'\n    Connect: 0x4e584e43, // 'CNXN'\n    Okay: 0x59414b4f, // 'OKAY'\n    Open: 0x4e45504f, // 'OPEN'\n    Write: 0x45545257, // 'WRTE'\n} as const;\n\nexport type AdbCommand = (typeof AdbCommand)[keyof typeof AdbCommand];\n\nexport const AdbPacketHeader = struct(\n    {\n        command: u32,\n        arg0: u32,\n        arg1: u32,\n        payloadLength: u32,\n        checksum: u32,\n        magic: s32,\n    },\n    { littleEndian: true },\n);\n\nexport type AdbPacketHeader = StructValue<typeof AdbPacketHeader>;\n\ntype AdbPacketHeaderInit = StructInit<typeof AdbPacketHeader>;\n\nexport const AdbPacket = extend(AdbPacketHeader, {\n    payload: buffer(\"payloadLength\"),\n});\n\nexport type AdbPacket = StructValue<typeof AdbPacket>;\n\n/**\n * `AdbPacketData` contains all the useful fields of `AdbPacket`.\n *\n * `AdvDaemonConnection#connect` will return a `ReadableStream<AdbPacketData>`,\n * allow each connection to encode `AdbPacket` in different methods.\n *\n * `AdbDaemonConnection#connect` will return a `WritableStream<AdbPacketInit>`,\n * however, `AdbDaemonTransport` will transform `AdbPacketData` to `AdbPacketInit` for you,\n * so `AdbSocket#writable#write` only needs `AdbPacketData`.\n */\nexport type AdbPacketData = Omit<\n    StructInit<typeof AdbPacket>,\n    \"checksum\" | \"magic\"\n>;\n\nexport type AdbPacketInit = StructInit<typeof AdbPacket>;\n\nexport function calculateChecksum(payload: Uint8Array): number {\n    return payload.reduce((result, item) => result + item, 0);\n}\n\nexport class AdbPacketSerializeStream extends TransformStream<\n    Consumable<AdbPacketInit>,\n    Consumable<Uint8Array>\n> {\n    constructor() {\n        const headerBuffer = new Uint8Array(AdbPacketHeader.size);\n        super({\n            transform: async (chunk, controller) => {\n                await chunk.tryConsume(async (chunk) => {\n                    const init = chunk as AdbPacketInit & AdbPacketHeaderInit;\n                    init.payloadLength = init.payload.length;\n\n                    AdbPacketHeader.serialize(init, headerBuffer);\n                    await Consumable.ReadableStream.enqueue(\n                        controller,\n                        headerBuffer,\n                    );\n\n                    if (init.payloadLength) {\n                        // USB protocol preserves packet boundaries,\n                        // so we must write payload separately as native ADB does,\n                        // otherwise the read operation on device will fail.\n                        await Consumable.ReadableStream.enqueue(\n                            controller,\n                            init.payload,\n                        );\n                    }\n                });\n            },\n        });\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { PromiseResolver } from \"@yume-chan/async\";\nimport type { Disposable } from \"@yume-chan/event\";\nimport { EmptyUint8Array } from \"@yume-chan/struct\";\n\nimport {\n    calculateBase64EncodedLength,\n    encodeBase64,\n    encodeUtf8,\n} from \"../utils/index.js\";\n\nimport {\n    adbGeneratePublicKey,\n    adbGetPublicKeySize,\n    rsaSign,\n} from \"./crypto.js\";\nimport type { AdbPacketData } from \"./packet.js\";\nimport { AdbCommand } from \"./packet.js\";\n\nexport interface AdbPrivateKey {\n    /**\n     * The private key in PKCS #8 format.\n     */\n    buffer: Uint8Array;\n    name?: string | undefined;\n}\n\nexport type AdbKeyIterable =\n    | Iterable<AdbPrivateKey>\n    | AsyncIterable<AdbPrivateKey>;\n\nexport interface AdbCredentialStore {\n    /**\n     * Generates and stores a RSA private key with modulus length `2048` and public exponent `65537`.\n     */\n    generateKey(): MaybePromiseLike<AdbPrivateKey>;\n\n    /**\n     * Synchronously or asynchronously iterates through all stored RSA private keys.\n     *\n     * Each call to `iterateKeys` must return a different iterator that iterate through all stored keys.\n     */\n    iterateKeys(): AdbKeyIterable;\n}\n\nexport const AdbAuthType = {\n    Token: 1,\n    Signature: 2,\n    PublicKey: 3,\n} as const;\n\nexport type AdbAuthType = (typeof AdbAuthType)[keyof typeof AdbAuthType];\n\nexport interface AdbAuthenticator {\n    /**\n     * @param getNextRequest\n     *\n     * Call this function to get the next authentication request packet from device.\n     *\n     * After calling `getNextRequest`, authenticator can `yield` a packet as response, or `return` to indicate its incapability of handling the request.\n     *\n     * After `return`, the `AdbAuthenticatorHandler` will move on to next authenticator and never go back.\n     *\n     * Calling `getNextRequest` multiple times without `yield` or `return` will always return the same request.\n     */\n    (\n        credentialStore: AdbCredentialStore,\n        getNextRequest: () => Promise<AdbPacketData>,\n    ): AsyncIterable<AdbPacketData>;\n}\n\nexport const AdbSignatureAuthenticator: AdbAuthenticator = async function* (\n    credentialStore: AdbCredentialStore,\n    getNextRequest: () => Promise<AdbPacketData>,\n): AsyncIterable<AdbPacketData> {\n    for await (const key of credentialStore.iterateKeys()) {\n        const packet = await getNextRequest();\n\n        if (packet.arg0 !== AdbAuthType.Token) {\n            return;\n        }\n\n        const signature = rsaSign(key.buffer, packet.payload);\n        yield {\n            command: AdbCommand.Auth,\n            arg0: AdbAuthType.Signature,\n            arg1: 0,\n            payload: signature,\n        };\n    }\n};\n\nexport const AdbPublicKeyAuthenticator: AdbAuthenticator = async function* (\n    credentialStore: AdbCredentialStore,\n    getNextRequest: () => Promise<AdbPacketData>,\n): AsyncIterable<AdbPacketData> {\n    const packet = await getNextRequest();\n\n    if (packet.arg0 !== AdbAuthType.Token) {\n        return;\n    }\n\n    let privateKey: AdbPrivateKey | undefined;\n    for await (const key of credentialStore.iterateKeys()) {\n        privateKey = key;\n        break;\n    }\n\n    if (!privateKey) {\n        privateKey = await credentialStore.generateKey();\n    }\n\n    const publicKeyLength = adbGetPublicKeySize();\n    const [publicKeyBase64Length] =\n        calculateBase64EncodedLength(publicKeyLength);\n\n    const nameBuffer = privateKey.name?.length\n        ? encodeUtf8(privateKey.name)\n        : EmptyUint8Array;\n    const publicKeyBuffer = new Uint8Array(\n        publicKeyBase64Length +\n            (nameBuffer.length ? nameBuffer.length + 1 : 0) + // Space character + name\n            1, // Null character\n    );\n\n    adbGeneratePublicKey(privateKey.buffer, publicKeyBuffer);\n    encodeBase64(publicKeyBuffer.subarray(0, publicKeyLength), publicKeyBuffer);\n\n    if (nameBuffer.length) {\n        publicKeyBuffer[publicKeyBase64Length] = 0x20;\n        publicKeyBuffer.set(nameBuffer, publicKeyBase64Length + 1);\n    }\n\n    yield {\n        command: AdbCommand.Auth,\n        arg0: AdbAuthType.PublicKey,\n        arg1: 0,\n        payload: publicKeyBuffer,\n    };\n};\n\nexport const ADB_DEFAULT_AUTHENTICATORS: readonly AdbAuthenticator[] = [\n    AdbSignatureAuthenticator,\n    AdbPublicKeyAuthenticator,\n];\n\nexport class AdbAuthenticationProcessor implements Disposable {\n    readonly authenticators: readonly AdbAuthenticator[];\n\n    readonly #credentialStore: AdbCredentialStore;\n\n    #pendingRequest = new PromiseResolver<AdbPacketData>();\n    #iterator: AsyncIterator<AdbPacketData, void, void> | undefined;\n\n    constructor(\n        authenticators: readonly AdbAuthenticator[],\n        credentialStore: AdbCredentialStore,\n    ) {\n        this.authenticators = authenticators;\n        this.#credentialStore = credentialStore;\n    }\n\n    #getNextRequest = (): Promise<AdbPacketData> => {\n        return this.#pendingRequest.promise;\n    };\n\n    async *#invokeAuthenticator(): AsyncGenerator<AdbPacketData, void, void> {\n        for (const authenticator of this.authenticators) {\n            for await (const packet of authenticator(\n                this.#credentialStore,\n                this.#getNextRequest,\n            )) {\n                // If the authenticator yielded a response\n                // Prepare `nextRequest` for next authentication request\n                this.#pendingRequest = new PromiseResolver();\n\n                // Yield the response to outer layer\n                yield packet;\n            }\n\n            // If the authenticator returned,\n            // Next authenticator will be given the same `pendingRequest`\n        }\n    }\n\n    async process(packet: AdbPacketData): Promise<AdbPacketData> {\n        if (!this.#iterator) {\n            this.#iterator = this.#invokeAuthenticator();\n        }\n\n        this.#pendingRequest.resolve(packet);\n\n        const result = await this.#iterator.next();\n        if (result.done) {\n            throw new Error(\"No authenticator can handle the request\");\n        }\n\n        return result.value;\n    }\n\n    dispose() {\n        void this.#iterator?.return?.();\n    }\n}\n", "import { PromiseResolver } from \"@yume-chan/async\";\nimport type { Disposable } from \"@yume-chan/event\";\nimport type {\n    PushReadableStreamController,\n    ReadableStream,\n    WritableStream,\n    WritableStreamDefaultController,\n} from \"@yume-chan/stream-extra\";\nimport { MaybeConsumable, PushReadableStream } from \"@yume-chan/stream-extra\";\nimport { EmptyUint8Array } from \"@yume-chan/struct\";\n\nimport type { AdbSocket } from \"../adb.js\";\n\nimport type { AdbPacketDispatcher } from \"./dispatcher.js\";\nimport { AdbCommand } from \"./packet.js\";\n\nexport interface AdbDaemonSocketInfo {\n    localId: number;\n    remoteId: number;\n\n    localCreated: boolean;\n    service: string;\n}\n\nexport interface AdbDaemonSocketInit extends AdbDaemonSocketInfo {\n    dispatcher: AdbPacketDispatcher;\n\n    highWaterMark?: number | undefined;\n\n    /**\n     * The initial delayed ack byte count, or `Infinity` if delayed ack is disabled.\n     */\n    availableWriteBytes: number;\n}\n\nexport class AdbDaemonSocketController\n    implements AdbDaemonSocketInfo, AdbSocket, Disposable\n{\n    readonly #dispatcher!: AdbPacketDispatcher;\n\n    readonly localId!: number;\n    readonly remoteId!: number;\n    readonly localCreated!: boolean;\n    readonly service!: string;\n\n    readonly #readable: ReadableStream<Uint8Array>;\n    #readableController!: PushReadableStreamController<Uint8Array>;\n    get readable() {\n        return this.#readable;\n    }\n\n    #writableController!: WritableStreamDefaultController;\n    readonly writable: WritableStream<MaybeConsumable<Uint8Array>>;\n\n    #closed = false;\n\n    readonly #closedPromise = new PromiseResolver<undefined>();\n    get closed() {\n        return this.#closedPromise.promise;\n    }\n\n    readonly #socket: AdbDaemonSocket;\n    get socket() {\n        return this.#socket;\n    }\n\n    #availableWriteBytesChanged: PromiseResolver<void> | undefined;\n    /**\n     * When delayed ack is disabled, returns `Infinity` if the socket is ready to write\n     * (exactly one packet can be written no matter how large it is), or `-1` if the socket\n     * is waiting for ack message.\n     *\n     * When delayed ack is enabled, returns a non-negative finite number indicates the number of\n     * bytes that can be written to the socket before waiting for ack message.\n     */\n    #availableWriteBytes = 0;\n\n    constructor(options: AdbDaemonSocketInit) {\n        this.#dispatcher = options.dispatcher;\n        this.localId = options.localId;\n        this.remoteId = options.remoteId;\n        this.localCreated = options.localCreated;\n        this.service = options.service;\n\n        this.#readable = new PushReadableStream((controller) => {\n            this.#readableController = controller;\n        });\n\n        this.writable = new MaybeConsumable.WritableStream<Uint8Array>({\n            start: (controller) => {\n                this.#writableController = controller;\n                controller.signal.addEventListener(\"abort\", () => {\n                    this.#availableWriteBytesChanged?.reject(\n                        controller.signal.reason,\n                    );\n                });\n            },\n            write: async (data) => {\n                const size = data.length;\n                const chunkSize = this.#dispatcher.options.maxPayloadSize;\n                for (\n                    let start = 0, end = chunkSize;\n                    start < size;\n                    start = end, end += chunkSize\n                ) {\n                    const chunk = data.subarray(start, end);\n                    await this.#writeChunk(chunk);\n                }\n            },\n        });\n\n        this.#socket = new AdbDaemonSocket(this);\n        this.#availableWriteBytes = options.availableWriteBytes;\n    }\n\n    async #writeChunk(data: Uint8Array) {\n        const length = data.length;\n        while (this.#availableWriteBytes < length) {\n            // Only one lock is required because Web Streams API guarantees\n            // that `write` is not reentrant.\n            const resolver = new PromiseResolver<void>();\n            this.#availableWriteBytesChanged = resolver;\n            await resolver.promise;\n        }\n\n        if (this.#availableWriteBytes === Infinity) {\n            this.#availableWriteBytes = -1;\n        } else {\n            this.#availableWriteBytes -= length;\n        }\n\n        await this.#dispatcher.sendPacket(\n            AdbCommand.Write,\n            this.localId,\n            this.remoteId,\n            data,\n        );\n    }\n\n    async enqueue(data: Uint8Array) {\n        await this.#readableController.enqueue(data);\n    }\n\n    public ack(bytes: number) {\n        this.#availableWriteBytes += bytes;\n        this.#availableWriteBytesChanged?.resolve();\n    }\n\n    async close(): Promise<void> {\n        if (this.#closed) {\n            return;\n        }\n        this.#closed = true;\n\n        this.#availableWriteBytesChanged?.reject(new Error(\"Socket closed\"));\n\n        try {\n            this.#writableController.error(new Error(\"Socket closed\"));\n        } catch {\n            // ignore\n        }\n\n        await this.#dispatcher.sendPacket(\n            AdbCommand.Close,\n            this.localId,\n            this.remoteId,\n            EmptyUint8Array,\n        );\n    }\n\n    dispose() {\n        this.#readableController.close();\n        this.#closedPromise.resolve(undefined);\n    }\n}\n\n/**\n * A duplex stream representing a socket to ADB daemon.\n */\nexport class AdbDaemonSocket implements AdbDaemonSocketInfo, AdbSocket {\n    readonly #controller: AdbDaemonSocketController;\n\n    get localId(): number {\n        return this.#controller.localId;\n    }\n    get remoteId(): number {\n        return this.#controller.remoteId;\n    }\n    get localCreated(): boolean {\n        return this.#controller.localCreated;\n    }\n    get service(): string {\n        return this.#controller.service;\n    }\n\n    get readable(): ReadableStream<Uint8Array> {\n        return this.#controller.readable;\n    }\n    get writable(): WritableStream<MaybeConsumable<Uint8Array>> {\n        return this.#controller.writable;\n    }\n\n    get closed(): Promise<undefined> {\n        return this.#controller.closed;\n    }\n\n    constructor(controller: AdbDaemonSocketController) {\n        this.#controller = controller;\n    }\n\n    close() {\n        return this.#controller.close();\n    }\n}\n", "import {\n    AsyncOperationManager,\n    PromiseResolver,\n    delay,\n} from \"@yume-chan/async\";\nimport {\n    getUint32LittleEndian,\n    setUint32LittleEndian,\n} from \"@yume-chan/no-data-view\";\nimport type {\n    ReadableWritablePair,\n    WritableStreamDefaultController,\n    WritableStreamDefaultWriter,\n} from \"@yume-chan/stream-extra\";\nimport {\n    AbortController,\n    Consumable,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport { EmptyUint8Array, decodeUtf8, encodeUtf8 } from \"@yume-chan/struct\";\n\nimport type { AdbIncomingSocketHandler, AdbSocket, Closeable } from \"../adb.js\";\n\nimport type { AdbPacketData, AdbPacketInit } from \"./packet.js\";\nimport { AdbCommand, calculateChecksum } from \"./packet.js\";\nimport { AdbDaemonSocketController } from \"./socket.js\";\n\nexport interface AdbPacketDispatcherOptions {\n    /**\n     * From Android 9.0, ADB stopped checking the checksum in packet header to improve performance.\n     *\n     * The value should be inferred from the device's ADB protocol version.\n     */\n    calculateChecksum: boolean;\n\n    /**\n     * Before Android 9.0, ADB uses `char*` to parse service strings,\n     * thus requires a null character to terminate.\n     *\n     * The value should be inferred from the device's ADB protocol version.\n     * Usually it should have the same value as `calculateChecksum`, since they both changed\n     * in Android 9.0.\n     */\n    appendNullToServiceString: boolean;\n\n    maxPayloadSize: number;\n\n    /**\n     * Whether to keep the `connection` open (don't call `writable.close` and `readable.cancel`)\n     * when `AdbPacketDispatcher.close` is called.\n     *\n     * @default false\n     */\n    preserveConnection?: boolean | undefined;\n\n    /**\n     * The number of bytes the device can send before receiving an ack packet.\n     * Using delayed ack can improve the throughput,\n     * especially when the device is connected over Wi-Fi (so the latency is higher).\n     *\n     * This must be the negotiated value between the client and device. If the device enabled\n     * delayed ack but the client didn't, the device will throw an error when the client sends\n     * the first `WRTE` packet. And vice versa.\n     */\n    initialDelayedAckBytes: number;\n\n    /**\n     * When set, the dispatcher will throw an error when\n     * one of the socket readable stalls for this amount of milliseconds.\n     *\n     * Because ADB is a multiplexed protocol, blocking one socket will also block all other sockets.\n     * It's important to always read from all sockets to prevent stalling.\n     *\n     * This option is helpful to detect bugs in the client code.\n     *\n     * @default false\n     */\n    readTimeLimit?: number | undefined;\n}\n\ninterface SocketOpenResult {\n    remoteId: number;\n    availableWriteBytes: number;\n}\n\n/**\n * The dispatcher is the \"dumb\" part of the connection handling logic.\n *\n * Except some options to change some minor behaviors,\n * its only job is forwarding packets between authenticated underlying streams\n * and abstracted socket objects.\n *\n * The `Adb` class is responsible for doing the authentication,\n * negotiating the options, and has shortcuts to high-level services.\n */\nexport class AdbPacketDispatcher implements Closeable {\n    // ADB socket id starts from 1\n    // (0 means open failed)\n    readonly #initializers = new AsyncOperationManager(1);\n    /**\n     * Socket local ID to the socket controller.\n     */\n    readonly #sockets = new Map<number, AdbDaemonSocketController>();\n\n    readonly #writer: WritableStreamDefaultWriter<Consumable<AdbPacketInit>>;\n\n    readonly options: AdbPacketDispatcherOptions;\n\n    #closed = false;\n    readonly #disconnected = new PromiseResolver<void>();\n    get disconnected() {\n        return this.#disconnected.promise;\n    }\n\n    readonly #incomingSocketHandlers = new Map<\n        string,\n        AdbIncomingSocketHandler\n    >();\n    readonly #readAbortController = new AbortController();\n\n    constructor(\n        connection: ReadableWritablePair<\n            AdbPacketData,\n            Consumable<AdbPacketInit>\n        >,\n        options: AdbPacketDispatcherOptions,\n    ) {\n        this.options = options;\n        // Don't allow negative values in dispatcher\n        if (this.options.initialDelayedAckBytes < 0) {\n            this.options.initialDelayedAckBytes = 0;\n        }\n\n        connection.readable\n            .pipeTo(\n                new WritableStream<AdbPacketData>({\n                    write: async (\n                        packet: AdbPacketData,\n                        controller: WritableStreamDefaultController,\n                    ) => {\n                        switch (packet.command) {\n                            case AdbCommand.Close:\n                                await this.#handleClose(packet);\n                                break;\n                            case AdbCommand.Okay:\n                                this.#handleOkay(packet);\n                                break;\n                            case AdbCommand.Open:\n                                await this.#handleOpen(packet);\n                                break;\n                            case AdbCommand.Write:\n                                // Don't await - let each socket handle its own backpressure\n                                // without blocking other sockets' packet processing.\n                                // Fatal errors are propagated via WritableStream's controller.\n                                this.#handleWrite(packet).catch((e) => {\n                                    controller.error(e);\n                                });\n                                break;\n                            default:\n                                // Junk data may only appear in the authentication phase,\n                                // since the dispatcher only works after authentication,\n                                // all packets should have a valid command.\n                                // (although it's possible that Adb added new commands in the future)\n                                throw new Error(\n                                    `Unknown command: ${packet.command.toString(\n                                        16,\n                                    )}`,\n                                );\n                        }\n                    },\n                }),\n                {\n                    preventCancel: options.preserveConnection ?? false,\n                    signal: this.#readAbortController.signal,\n                },\n            )\n            .then(\n                () => {\n                    this.#dispose();\n                },\n                (e) => {\n                    if (!this.#closed) {\n                        this.#disconnected.reject(e);\n                    }\n                    this.#dispose();\n                },\n            );\n\n        this.#writer = connection.writable.getWriter();\n    }\n\n    async #handleClose(packet: AdbPacketData) {\n        // If the socket is still pending\n        if (\n            packet.arg0 === 0 &&\n            this.#initializers.reject(\n                packet.arg1,\n                new Error(\"Socket open failed\"),\n            )\n        ) {\n            // Device failed to create the socket\n            // (unknown service string, failed to execute command, etc.)\n            // it doesn't break the connection,\n            // so only reject the socket creation promise,\n            // don't throw an error here.\n            return;\n        }\n\n        // From https://android.googlesource.com/platform/packages/modules/adb/+/65d18e2c1cc48b585811954892311b28a4c3d188/adb.cpp#459\n        /* According to protocol.txt, p->msg.arg0 might be 0 to indicate\n         * a failed OPEN only. However, due to a bug in previous ADB\n         * versions, CLOSE(0, remote-id, \"\") was also used for normal\n         * CLOSE() operations.\n         */\n\n        // Ignore `arg0` and search for the socket\n        const socket = this.#sockets.get(packet.arg1);\n        if (socket) {\n            await socket.close();\n            socket.dispose();\n            this.#sockets.delete(packet.arg1);\n            return;\n        }\n\n        // TODO: adb: is double closing an socket a catastrophic error?\n        // If the client sends two `CLSE` packets for one socket,\n        // the device may also respond with two `CLSE` packets.\n    }\n\n    #handleOkay(packet: AdbPacketData) {\n        let ackBytes: number;\n        if (this.options.initialDelayedAckBytes !== 0) {\n            if (packet.payload.length !== 4) {\n                throw new Error(\n                    \"Invalid OKAY packet. Payload size should be 4\",\n                );\n            }\n            ackBytes = getUint32LittleEndian(packet.payload, 0);\n        } else {\n            if (packet.payload.length !== 0) {\n                throw new Error(\n                    \"Invalid OKAY packet. Payload size should be 0\",\n                );\n            }\n            ackBytes = Infinity;\n        }\n\n        if (\n            this.#initializers.resolve(packet.arg1, {\n                remoteId: packet.arg0,\n                availableWriteBytes: ackBytes,\n            } satisfies SocketOpenResult)\n        ) {\n            // Device successfully created the socket\n            return;\n        }\n\n        const socket = this.#sockets.get(packet.arg1);\n        if (socket) {\n            // When delayed ack is enabled, `ackBytes` is a positive number represents\n            // how many bytes the device has received from this socket.\n            // When delayed ack is disabled, `ackBytes` is always `Infinity` represents\n            // the device has received last `WRTE` packet from the socket.\n            socket.ack(ackBytes);\n            return;\n        }\n\n        // Maybe the device is responding to a packet of last connection\n        // Tell the device to close the socket\n        void this.sendPacket(\n            AdbCommand.Close,\n            packet.arg1,\n            packet.arg0,\n            EmptyUint8Array,\n        );\n    }\n\n    #sendOkay(localId: number, remoteId: number, ackBytes: number) {\n        let payload: Uint8Array;\n        if (this.options.initialDelayedAckBytes !== 0) {\n            // TODO: try reusing this buffer to reduce memory allocation\n            // However, that requires blocking reentrance of `sendOkay`, which might be more expensive\n            payload = new Uint8Array(4);\n            setUint32LittleEndian(payload, 0, ackBytes);\n        } else {\n            payload = EmptyUint8Array;\n        }\n\n        return this.sendPacket(AdbCommand.Okay, localId, remoteId, payload);\n    }\n\n    async #handleOpen(packet: AdbPacketData) {\n        // Allocate a local ID for the socket from `#initializers`.\n        // `AsyncOperationManager` doesn't directly support returning the next ID,\n        // so use `add` + `resolve` to simulate this\n        const [localId] = this.#initializers.add<number>();\n        this.#initializers.resolve(localId, undefined);\n\n        const remoteId = packet.arg0;\n        let availableWriteBytes = packet.arg1;\n        let service = decodeUtf8(packet.payload);\n        // ADB Daemon still adds a null character to the service string\n        if (service.endsWith(\"\\0\")) {\n            service = service.substring(0, service.length - 1);\n        }\n\n        // Check remote delayed ack enablement is consistent with local\n        if (this.options.initialDelayedAckBytes === 0) {\n            if (availableWriteBytes !== 0) {\n                throw new Error(\"Invalid OPEN packet. arg1 should be 0\");\n            }\n            availableWriteBytes = Infinity;\n        } else {\n            if (availableWriteBytes === 0) {\n                throw new Error(\n                    \"Invalid OPEN packet. arg1 should be greater than 0\",\n                );\n            }\n        }\n\n        const handler = this.#incomingSocketHandlers.get(service);\n        if (!handler) {\n            await this.sendPacket(\n                AdbCommand.Close,\n                0,\n                remoteId,\n                EmptyUint8Array,\n            );\n            return;\n        }\n\n        const controller = new AdbDaemonSocketController({\n            dispatcher: this,\n            localId,\n            remoteId,\n            localCreated: false,\n            service,\n            availableWriteBytes,\n        });\n\n        try {\n            await handler(controller.socket);\n            this.#sockets.set(localId, controller);\n            await this.#sendOkay(\n                localId,\n                remoteId,\n                this.options.initialDelayedAckBytes,\n            );\n        } catch {\n            await this.sendPacket(\n                AdbCommand.Close,\n                0,\n                remoteId,\n                EmptyUint8Array,\n            );\n        }\n    }\n\n    async #handleWrite(packet: AdbPacketData) {\n        const socket = this.#sockets.get(packet.arg1);\n        if (!socket) {\n            throw new Error(`Unknown local socket id: ${packet.arg1}`);\n        }\n\n        let handled = false;\n\n        const promises: Promise<void>[] = [\n            (async () => {\n                await socket.enqueue(packet.payload);\n                await this.#sendOkay(\n                    packet.arg1,\n                    packet.arg0,\n                    packet.payload.length,\n                );\n                handled = true;\n            })(),\n        ];\n\n        if (this.options.readTimeLimit) {\n            promises.push(\n                (async () => {\n                    await delay(this.options.readTimeLimit!);\n                    if (!handled) {\n                        throw new Error(\n                            `readable of \\`${socket.service}\\` has stalled for ${this.options.readTimeLimit} milliseconds`,\n                        );\n                    }\n                })(),\n            );\n        }\n\n        await Promise.race(promises);\n    }\n\n    async createSocket(service: string): Promise<AdbSocket> {\n        if (this.options.appendNullToServiceString) {\n            service += \"\\0\";\n        }\n\n        const [localId, initializer] =\n            this.#initializers.add<SocketOpenResult>();\n        await this.sendPacket(\n            AdbCommand.Open,\n            localId,\n            this.options.initialDelayedAckBytes,\n            service,\n        );\n\n        // Fulfilled by `handleOkay`\n        const { remoteId, availableWriteBytes } = await initializer;\n        const controller = new AdbDaemonSocketController({\n            dispatcher: this,\n            localId,\n            remoteId,\n            localCreated: true,\n            service,\n            availableWriteBytes,\n        });\n        this.#sockets.set(localId, controller);\n\n        return controller.socket;\n    }\n\n    addReverseTunnel(service: string, handler: AdbIncomingSocketHandler) {\n        this.#incomingSocketHandlers.set(service, handler);\n    }\n\n    removeReverseTunnel(address: string) {\n        this.#incomingSocketHandlers.delete(address);\n    }\n\n    clearReverseTunnels() {\n        this.#incomingSocketHandlers.clear();\n    }\n\n    async sendPacket(\n        command: AdbCommand,\n        arg0: number,\n        arg1: number,\n        // PERF: It's slightly faster to not use default parameter values\n        payload: string | Uint8Array,\n    ): Promise<void> {\n        if (typeof payload === \"string\") {\n            payload = encodeUtf8(payload);\n        }\n\n        if (payload.length > this.options.maxPayloadSize) {\n            throw new TypeError(\"payload too large\");\n        }\n\n        await Consumable.WritableStream.write(this.#writer, {\n            command,\n            arg0,\n            arg1,\n            payload,\n            checksum: this.options.calculateChecksum\n                ? calculateChecksum(payload)\n                : 0,\n            magic: command ^ 0xffffffff,\n        });\n    }\n\n    async close() {\n        // Send `CLSE` packets for all sockets\n        await Promise.all(\n            Array.from(this.#sockets.values(), (socket) => socket.close()),\n        );\n\n        // Stop receiving\n        // It's possible that we haven't received all `CLSE` confirm packets,\n        // but it doesn't matter, the next connection can cope with them.\n        this.#closed = true;\n\n        this.#readAbortController.abort();\n        if (this.options.preserveConnection) {\n            this.#writer.releaseLock();\n        } else {\n            await this.#writer.close();\n        }\n\n        // `pipe().then()` will call `dispose`\n    }\n\n    #dispose() {\n        for (const socket of this.#sockets.values()) {\n            socket.dispose();\n        }\n\n        this.#disconnected.resolve();\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { PromiseResolver } from \"@yume-chan/async\";\nimport type { ReadableWritablePair } from \"@yume-chan/stream-extra\";\nimport {\n    AbortController,\n    Consumable,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport { decodeUtf8, encodeUtf8 } from \"@yume-chan/struct\";\n\nimport type {\n    AdbIncomingSocketHandler,\n    AdbSocket,\n    AdbTransport,\n} from \"../adb.js\";\nimport { AdbBanner } from \"../banner.js\";\nimport { AdbFeature } from \"../features.js\";\n\nimport type { AdbAuthenticator, AdbCredentialStore } from \"./auth.js\";\nimport {\n    ADB_DEFAULT_AUTHENTICATORS,\n    AdbAuthenticationProcessor,\n} from \"./auth.js\";\nimport { AdbPacketDispatcher } from \"./dispatcher.js\";\nimport type { AdbPacketData, AdbPacketInit } from \"./packet.js\";\nimport { AdbCommand, calculateChecksum } from \"./packet.js\";\n\nexport const ADB_DAEMON_VERSION_OMIT_CHECKSUM = 0x01000001;\n// https://android.googlesource.com/platform/packages/modules/adb/+/79010dc6d5ca7490c493df800d4421730f5466ca/transport.cpp#1252\n// There are some other feature constants, but some of them are only used by ADB server, not devices (daemons).\nexport const ADB_DAEMON_DEFAULT_FEATURES = /* #__PURE__ */ (() =>\n    [\n        AdbFeature.ShellV2,\n        AdbFeature.Cmd,\n        AdbFeature.StatV2,\n        AdbFeature.ListV2,\n        AdbFeature.FixedPushMkdir,\n        \"apex\",\n        AdbFeature.Abb,\n        // only tells the client the symlink timestamp issue in `adb push --sync` has been fixed.\n        // No special handling required.\n        \"fixed_push_symlink_timestamp\",\n        AdbFeature.AbbExec,\n        \"remount_shell\",\n        \"track_app\",\n        AdbFeature.SendReceiveV2,\n        \"sendrecv_v2_brotli\",\n        \"sendrecv_v2_lz4\",\n        \"sendrecv_v2_zstd\",\n        \"sendrecv_v2_dry_run_send\",\n        AdbFeature.DelayedAck,\n    ] as readonly AdbFeature[])();\nexport const ADB_DAEMON_DEFAULT_INITIAL_PAYLOAD_SIZE = 32 * 1024 * 1024;\n\nexport type AdbDaemonConnection = ReadableWritablePair<\n    AdbPacketData,\n    Consumable<AdbPacketInit>\n>;\n\nexport interface AdbDaemonAuthenticationOptions {\n    serial: string;\n    connection: AdbDaemonConnection;\n    credentialStore: AdbCredentialStore;\n    authenticators?: readonly AdbAuthenticator[];\n    features?: readonly AdbFeature[];\n\n    /**\n     * The number of bytes the device can send before receiving an ack packet.\n     * Using delayed ack can improve the throughput,\n     * especially when the device is connected over Wi-Fi (so the latency is higher).\n     *\n     * Set to 0 or any negative value to disable delayed ack in handshake.\n     * Otherwise the value must be in the range of unsigned 32-bit integer.\n     *\n     * Delayed ack was added in Android 14,\n     * this option will be ignored when the device doesn't support it.\n     *\n     * @default ADB_DAEMON_DEFAULT_INITIAL_PAYLOAD_SIZE\n     */\n    initialDelayedAckBytes?: number;\n\n    /**\n     * Whether to keep the `connection` open (don't call `writable.close` and `readable.cancel`)\n     * when `AdbDaemonTransport.close` is called.\n     *\n     * Note that when `authenticate` fails,\n     * no matter which value this option has,\n     * the `connection` is always kept open, so it can be used in another `authenticate` call.\n     *\n     * @default false\n     */\n    preserveConnection?: boolean | undefined;\n\n    /**\n     * When set, the transport will throw an error when\n     * one of the socket readable stalls for this amount of milliseconds.\n     *\n     * Because ADB is a multiplexed protocol, blocking one socket will also block all other sockets.\n     * It's important to always read from all sockets to prevent stalling.\n     *\n     * This option is helpful to detect bugs in the client code.\n     *\n     * @default undefined\n     */\n    readTimeLimit?: number | undefined;\n}\n\ninterface AdbDaemonSocketConnectorConstructionOptions {\n    serial: string;\n    connection: AdbDaemonConnection;\n    version: number;\n    maxPayloadSize: number;\n    banner: string;\n    features?: readonly AdbFeature[];\n\n    /**\n     * The number of bytes the device can send before receiving an ack packet.\n     *\n     * On Android 14 and newer, the Delayed Acknowledgement feature is added to\n     * improve performance, especially for high-latency connections like ADB over Wi-Fi.\n     *\n     * When `features` doesn't include `AdbFeature.DelayedAck`, it must be set to 0. Otherwise,\n     * the value must be in the range of unsigned 32-bit integer.\n     *\n     * If the device enabled delayed ack but the client didn't, the device will throw an error\n     * when the client sends the first data packet. And vice versa.\n     */\n    initialDelayedAckBytes: number;\n\n    /**\n     * Whether to keep the `connection` open (don't call `writable.close` and `readable.cancel`)\n     * when `AdbDaemonTransport.close` is called.\n     *\n     * @default false\n     */\n    preserveConnection?: boolean | undefined;\n\n    /**\n     * When set, the transport will throw an error when\n     * one of the socket readable stalls for this amount of milliseconds.\n     *\n     * Because ADB is a multiplexed protocol, blocking one socket will also block all other sockets.\n     * It's important to always read from all sockets to prevent stalling.\n     *\n     * This option is helpful to detect bugs in the client code.\n     *\n     * @default undefined\n     */\n    readTimeLimit?: number | undefined;\n}\n\n/**\n * An ADB Transport that connects to ADB Daemons directly.\n */\nexport class AdbDaemonTransport implements AdbTransport {\n    /**\n     * Authenticate with the ADB Daemon and create a new transport.\n     */\n    static async authenticate({\n        serial,\n        connection,\n        credentialStore,\n        authenticators = ADB_DEFAULT_AUTHENTICATORS,\n        features = ADB_DAEMON_DEFAULT_FEATURES,\n        initialDelayedAckBytes = ADB_DAEMON_DEFAULT_INITIAL_PAYLOAD_SIZE,\n        ...options\n    }: AdbDaemonAuthenticationOptions): Promise<AdbDaemonTransport> {\n        // Initially, set to highest-supported version and payload size.\n        let version = 0x01000001;\n        // Android 4: 4K, Android 7: 256K, Android 9: 1M\n        let maxPayloadSize = 1024 * 1024;\n\n        const resolver = new PromiseResolver<string>();\n        const authProcessor = new AdbAuthenticationProcessor(\n            authenticators,\n            credentialStore,\n        );\n\n        // Here is similar to `AdbPacketDispatcher`,\n        // But the received packet types and send packet processing are different.\n        const abortController = new AbortController();\n        const pipe = connection.readable\n            .pipeTo(\n                new WritableStream({\n                    async write(packet) {\n                        switch (packet.command) {\n                            case AdbCommand.Connect:\n                                version = Math.min(version, packet.arg0);\n                                maxPayloadSize = Math.min(\n                                    maxPayloadSize,\n                                    packet.arg1,\n                                );\n                                resolver.resolve(decodeUtf8(packet.payload));\n                                break;\n                            case AdbCommand.Auth: {\n                                const response =\n                                    await authProcessor.process(packet);\n                                await sendPacket(response);\n                                break;\n                            }\n                            default:\n                                // Maybe the previous ADB client exited without reading all packets,\n                                // so they are still waiting in OS internal buffer.\n                                // Just ignore them.\n                                // Because a `Connect` packet will reset the device,\n                                // Eventually there will be `Connect` and `Auth` response packets.\n                                break;\n                        }\n                    },\n                }),\n                {\n                    // Don't cancel the source ReadableStream on AbortSignal abort.\n                    preventCancel: true,\n                    signal: abortController.signal,\n                },\n            )\n            .then(\n                () => {\n                    // If `resolver` is already settled, call `reject` won't do anything.\n                    resolver.reject(\n                        new Error(\"Connection closed unexpectedly\"),\n                    );\n                },\n                (e) => {\n                    resolver.reject(e);\n                },\n            );\n\n        const writer = connection.writable.getWriter();\n        async function sendPacket(init: AdbPacketData) {\n            // Always send checksum in auth steps\n            // Because we don't know if the device needs it or not.\n            (init as AdbPacketInit).checksum = calculateChecksum(init.payload);\n            (init as AdbPacketInit).magic = init.command ^ 0xffffffff;\n            await Consumable.WritableStream.write(\n                writer,\n                init as AdbPacketInit,\n            );\n        }\n\n        const actualFeatures = features.slice();\n        if (initialDelayedAckBytes <= 0) {\n            const index = features.indexOf(AdbFeature.DelayedAck);\n            if (index !== -1) {\n                actualFeatures.splice(index, 1);\n            }\n        }\n\n        let banner: string;\n        try {\n            await sendPacket({\n                command: AdbCommand.Connect,\n                arg0: version,\n                arg1: maxPayloadSize,\n                // The terminating `;` is required in formal definition\n                // But ADB daemon (all versions) can still work without it\n                payload: encodeUtf8(\n                    `host::features=${actualFeatures.join(\",\")}`,\n                ),\n            });\n\n            banner = await resolver.promise;\n        } finally {\n            // When failed, release locks on `connection` so the caller can try again.\n            // When success, also release locks so `AdbPacketDispatcher` can use them.\n            abortController.abort();\n            writer.releaseLock();\n\n            // Wait until pipe stops (`ReadableStream` lock released)\n            await pipe;\n        }\n\n        return new AdbDaemonTransport({\n            serial,\n            connection,\n            version,\n            maxPayloadSize,\n            banner,\n            features: actualFeatures,\n            initialDelayedAckBytes,\n            ...options,\n        });\n    }\n\n    #connection: AdbDaemonConnection;\n    get connection() {\n        return this.#connection;\n    }\n\n    readonly #dispatcher: AdbPacketDispatcher;\n\n    #serial: string;\n    get serial() {\n        return this.#serial;\n    }\n\n    #protocolVersion: number;\n    get protocolVersion() {\n        return this.#protocolVersion;\n    }\n\n    get maxPayloadSize() {\n        return this.#dispatcher.options.maxPayloadSize;\n    }\n\n    #banner: AdbBanner;\n    get banner() {\n        return this.#banner;\n    }\n\n    get disconnected() {\n        return this.#dispatcher.disconnected;\n    }\n\n    #clientFeatures: readonly AdbFeature[];\n    get clientFeatures() {\n        return this.#clientFeatures;\n    }\n\n    constructor({\n        serial,\n        connection,\n        version,\n        banner,\n        features = ADB_DAEMON_DEFAULT_FEATURES,\n        initialDelayedAckBytes,\n        ...options\n    }: AdbDaemonSocketConnectorConstructionOptions) {\n        this.#serial = serial;\n        this.#connection = connection;\n        this.#banner = AdbBanner.parse(banner);\n        this.#clientFeatures = features;\n\n        if (features.includes(AdbFeature.DelayedAck)) {\n            if (initialDelayedAckBytes <= 0) {\n                throw new TypeError(\n                    \"`initialDelayedAckBytes` must be greater than 0 when DelayedAck feature is enabled.\",\n                );\n            }\n\n            if (!this.#banner.features.includes(AdbFeature.DelayedAck)) {\n                initialDelayedAckBytes = 0;\n            }\n        } else {\n            initialDelayedAckBytes = 0;\n        }\n\n        let calculateChecksum: boolean;\n        let appendNullToServiceString: boolean;\n        if (version >= ADB_DAEMON_VERSION_OMIT_CHECKSUM) {\n            calculateChecksum = false;\n            appendNullToServiceString = false;\n        } else {\n            calculateChecksum = true;\n            appendNullToServiceString = true;\n        }\n\n        this.#dispatcher = new AdbPacketDispatcher(connection, {\n            calculateChecksum,\n            appendNullToServiceString,\n            initialDelayedAckBytes,\n            ...options,\n        });\n\n        this.#protocolVersion = version;\n    }\n\n    connect(service: string): MaybePromiseLike<AdbSocket> {\n        return this.#dispatcher.createSocket(service);\n    }\n\n    addReverseTunnel(\n        handler: AdbIncomingSocketHandler,\n        address?: string,\n    ): string {\n        if (!address) {\n            const id = Math.random().toString().substring(2);\n            address = `localabstract:reverse_${id}`;\n        }\n        this.#dispatcher.addReverseTunnel(address, handler);\n        return address;\n    }\n\n    removeReverseTunnel(address: string): void {\n        this.#dispatcher.removeReverseTunnel(address);\n    }\n\n    clearReverseTunnels(): void {\n        this.#dispatcher.clearReverseTunnels();\n    }\n\n    close(): MaybePromiseLike<void> {\n        return this.#dispatcher.close();\n    }\n}\n", "// cspell:ignore mdns\n\nimport type { AdbServerClient } from \"../client.js\";\n\nexport class MDnsCommands {\n    readonly #client: AdbServerClient;\n\n    constructor(client: AdbServerClient) {\n        this.#client = client;\n    }\n\n    async check() {\n        const connection =\n            await this.#client.createConnection(\"host:mdns:check\");\n        try {\n            const response = await connection.readString();\n            return !response.startsWith(\"ERROR:\");\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    async getServices() {\n        const connection =\n            await this.#client.createConnection(\"host:mdns:services\");\n        try {\n            const response = await connection.readString();\n            return response\n                .split(\"\\n\")\n                .filter(Boolean)\n                .map((line) => {\n                    const parts = line.split(\"\\t\");\n                    return {\n                        name: parts[0]!,\n                        service: parts[1]!,\n                        address: parts[2]!,\n                    };\n                });\n        } finally {\n            await connection.dispose();\n        }\n    }\n}\n", "import type { MaybePromiseLike } from \"@yume-chan/async\";\nimport type { WritableStreamDefaultWriter } from \"@yume-chan/stream-extra\";\nimport {\n    BufferedReadableStream,\n    tryCancel,\n    tryClose,\n} from \"@yume-chan/stream-extra\";\nimport {\n    bipedal,\n    decodeUtf8,\n    encodeUtf8,\n    TextDecoder,\n} from \"@yume-chan/struct\";\n\nimport { hexToNumber, sequenceEqual, write4HexDigits } from \"../utils/index.js\";\n\nimport type { AdbServerClient } from \"./client.js\";\n\nconst OKAY = encodeUtf8(\"OKAY\");\nexport const FAIL = encodeUtf8(\"FAIL\");\n\nexport class AdbServerStream {\n    #connection: AdbServerClient.ServerConnection;\n    #buffered: BufferedReadableStream;\n    #writer: WritableStreamDefaultWriter<Uint8Array>;\n\n    constructor(connection: AdbServerClient.ServerConnection) {\n        this.#connection = connection;\n        this.#buffered = new BufferedReadableStream(connection.readable);\n        this.#writer = connection.writable.getWriter();\n    }\n\n    readExactly(length: number): MaybePromiseLike<Uint8Array> {\n        return this.#buffered.readExactly(length);\n    }\n\n    readString = bipedal(function* (this: AdbServerStream, then) {\n        const data = yield* then(this.readExactly(4));\n        const length = hexToNumber(data);\n        if (length === 0) {\n            return \"\";\n        } else {\n            const decoder = new TextDecoder();\n            let result = \"\";\n            const iterator = this.#buffered.iterateExactly(length);\n            while (true) {\n                const { done, value } = iterator.next();\n                if (done) {\n                    break;\n                }\n                result += decoder.decode(yield* then(value), { stream: true });\n            }\n            result += decoder.decode();\n            return result;\n        }\n    });\n\n    async readOkay(): Promise<void> {\n        const response = await this.readExactly(4);\n        if (sequenceEqual(response, OKAY)) {\n            // `OKAY` is followed by data length and data\n            // But different services want to parse the data differently\n            // So don't read the data here\n            return;\n        }\n\n        if (sequenceEqual(response, FAIL)) {\n            const reason = await this.readString();\n            throw new Error(reason);\n        }\n\n        throw new Error(`Unexpected response: ${decodeUtf8(response)}`);\n    }\n\n    async writeString(value: string): Promise<void> {\n        // TODO: investigate using `encodeUtf8(\"0000\" + value)` then modifying the length\n        // That way allocates a new string (hopefully only a rope) instead of a new buffer\n        const encoded = encodeUtf8(value);\n        const buffer = new Uint8Array(4 + encoded.length);\n        write4HexDigits(buffer, 0, encoded.length);\n        buffer.set(encoded, 4);\n        await this.#writer.write(buffer);\n    }\n\n    release() {\n        this.#writer.releaseLock();\n        return {\n            readable: this.#buffered.release(),\n            writable: this.#connection.writable,\n            closed: this.#connection.closed,\n            close: () => this.#connection.close(),\n        };\n    }\n\n    async dispose() {\n        void tryCancel(this.#buffered);\n        void tryClose(this.#writer);\n        await this.#connection.close();\n    }\n}\n", "// cspell:ignore tport\n\nimport { hexToNumber, sequenceEqual } from \"../../utils/index.js\";\nimport type { AdbServerClient } from \"../client.js\";\nimport { FAIL } from \"../stream.js\";\n\nexport class NetworkError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"NetworkError\";\n    }\n}\n\nexport class UnauthorizedError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"UnauthorizedError\";\n    }\n}\n\nexport class AlreadyConnectedError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"AlreadyConnectedError\";\n    }\n}\n\nexport class WirelessCommands {\n    readonly #client: AdbServerClient;\n\n    constructor(client: AdbServerClient) {\n        this.#client = client;\n    }\n\n    /**\n     * `adb pair <password> <address>`\n     */\n    async pair(address: string, password: string): Promise<void> {\n        const connection = await this.#client.createConnection(\n            `host:pair:${password}:${address}`,\n        );\n        try {\n            const response = await connection.readExactly(4);\n            // `response` is either `FAIL`, or 4 hex digits for length of the string\n            if (sequenceEqual(response, FAIL)) {\n                throw new Error(await connection.readString());\n            }\n            const length = hexToNumber(response);\n            // Ignore the string as it's always `Successful ...`\n            await connection.readExactly(length);\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    /**\n     * `adb connect <address>`\n     */\n    async connect(address: string): Promise<void> {\n        const connection = await this.#client.createConnection(\n            `host:connect:${address}`,\n        );\n        try {\n            const response = await connection.readString();\n            switch (response) {\n                case `already connected to ${address}`:\n                    throw new AlreadyConnectedError(response);\n                case `failed to connect to ${address}`: // `adb pair` mode not authorized\n                case `failed to authenticate to ${address}`: // `adb tcpip` mode not authorized\n                    throw new UnauthorizedError(response);\n                case `connected to ${address}`:\n                    return;\n                default:\n                    throw new NetworkError(response);\n            }\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    /**\n     * `adb disconnect <address>`\n     */\n    async disconnect(address: string): Promise<void> {\n        const connection = await this.#client.createConnection(\n            `host:disconnect:${address}`,\n        );\n        try {\n            await connection.readString();\n        } finally {\n            await connection.dispose();\n        }\n    }\n}\n", "import { EventEmitter, StickyEventEmitter } from \"@yume-chan/event\";\n\nimport { Ref } from \"../utils/index.js\";\n\nimport { AdbServerClient } from \"./client.js\";\nimport type { AdbServerStream } from \"./stream.js\";\n\nexport function unorderedRemove<T>(array: T[], index: number) {\n    if (index < 0 || index >= array.length) {\n        return;\n    }\n    array[index] = array[array.length - 1]!;\n    array.length -= 1;\n}\n\ninterface Observer {\n    includeStates: readonly AdbServerClient.ConnectionState[];\n    onDeviceAdd: EventEmitter<readonly AdbServerClient.Device[]>;\n    onDeviceRemove: EventEmitter<readonly AdbServerClient.Device[]>;\n    onListChange: EventEmitter<readonly AdbServerClient.Device[]>;\n    onError: EventEmitter<Error>;\n}\n\nfunction filterDeviceStates(\n    devices: readonly AdbServerClient.Device[],\n    states: readonly AdbServerClient.ConnectionState[],\n) {\n    return devices.filter((device) => states.includes(device.state));\n}\n\nexport class AdbServerDeviceObserverOwner {\n    current: readonly AdbServerClient.Device[] = [];\n\n    readonly #client: AdbServerClient;\n\n    #stream: Promise<AdbServerStream> | undefined;\n    #observers: Observer[] = [];\n\n    constructor(client: AdbServerClient) {\n        this.#client = client;\n    }\n\n    async #receive(stream: AdbServerStream) {\n        const response = await stream.readString();\n        const next = AdbServerClient.parseDeviceList(response);\n\n        const removed = this.current.slice();\n        const added: AdbServerClient.Device[] = [];\n        for (const nextDevice of next) {\n            const index = removed.findIndex(\n                (device) => device.transportId === nextDevice.transportId,\n            );\n\n            if (index === -1) {\n                added.push(nextDevice);\n                continue;\n            }\n\n            unorderedRemove(removed, index);\n        }\n\n        this.current = next;\n\n        if (added.length) {\n            for (const observer of this.#observers) {\n                const filtered = filterDeviceStates(\n                    added,\n                    observer.includeStates,\n                );\n                if (filtered.length) {\n                    observer.onDeviceAdd.fire(filtered);\n                }\n            }\n        }\n        if (removed.length) {\n            for (const observer of this.#observers) {\n                const filtered = filterDeviceStates(\n                    removed,\n                    observer.includeStates,\n                );\n                if (filtered.length) {\n                    observer.onDeviceRemove.fire(removed);\n                }\n            }\n        }\n\n        for (const observer of this.#observers) {\n            const filtered = filterDeviceStates(\n                this.current,\n                observer.includeStates,\n            );\n            observer.onListChange.fire(filtered);\n        }\n    }\n\n    async #receiveLoop(stream: AdbServerStream) {\n        try {\n            while (true) {\n                await this.#receive(stream);\n            }\n        } catch (e) {\n            this.#stream = undefined;\n\n            for (const observer of this.#observers) {\n                observer.onError.fire(e as Error);\n            }\n        }\n    }\n\n    async #connect() {\n        const stream = await this.#client.createConnection(\n            \"host:track-devices-l\",\n            // Each individual observer will ref depending on their options\n            { unref: true },\n        );\n\n        // Set `current` and `onListChange` value before returning\n        await this.#receive(stream);\n\n        // Then start receive loop\n        void this.#receiveLoop(stream);\n\n        return stream;\n    }\n\n    async #handleObserverStop(stream: AdbServerStream) {\n        if (this.#observers.length === 0) {\n            this.#stream = undefined;\n            await stream.dispose();\n        }\n    }\n\n    async createObserver(\n        options?: AdbServerDeviceObserverOwner.Options,\n    ): Promise<AdbServerClient.DeviceObserver> {\n        options?.signal?.throwIfAborted();\n\n        let current: readonly AdbServerClient.Device[] = [];\n        const onDeviceAdd = new EventEmitter<\n            readonly AdbServerClient.Device[]\n        >();\n        const onDeviceRemove = new EventEmitter<\n            readonly AdbServerClient.Device[]\n        >();\n        const onListChange = new StickyEventEmitter<\n            readonly AdbServerClient.Device[]\n        >();\n        const onError = new StickyEventEmitter<Error>();\n\n        const includeStates = options?.includeStates ?? [\n            \"device\",\n            \"unauthorized\",\n        ];\n        const observer = {\n            includeStates,\n            onDeviceAdd,\n            onDeviceRemove,\n            onListChange,\n            onError,\n        } satisfies Observer;\n        // Register `observer` before `#connect`.\n        // So `#handleObserverStop` knows if there is any observer.\n        this.#observers.push(observer);\n\n        // Read the filtered `current` value from `onListChange` event\n        onListChange.event((value) => (current = value));\n\n        let stream: AdbServerStream;\n        if (!this.#stream) {\n            // `#connect` will initialize `onListChange` and `current`\n            this.#stream = this.#connect();\n\n            try {\n                stream = await this.#stream;\n            } catch (e) {\n                this.#stream = undefined;\n                throw e;\n            }\n        } else {\n            stream = await this.#stream;\n            // Initialize `onListChange` and `current` ourselves\n            onListChange.fire(filterDeviceStates(this.current, includeStates));\n        }\n\n        const ref = new Ref(options);\n\n        const stop = async () => {\n            unorderedRemove(this.#observers, this.#observers.indexOf(observer));\n            await this.#handleObserverStop(stream);\n            ref.unref();\n        };\n\n        if (options?.signal) {\n            if (options.signal.aborted) {\n                await stop();\n                throw options.signal.reason;\n            }\n\n            options.signal.addEventListener(\"abort\", () => void stop());\n        }\n\n        return {\n            onDeviceAdd: onDeviceAdd.event,\n            onDeviceRemove: onDeviceRemove.event,\n            onListChange: onListChange.event,\n            onError: onError.event,\n            get current() {\n                return current;\n            },\n            stop,\n        };\n    }\n}\n\nexport namespace AdbServerDeviceObserverOwner {\n    export interface Options extends AdbServerClient.ServerConnectionOptions {\n        includeStates?: readonly AdbServerClient.ConnectionState[];\n    }\n}\n", "import { PromiseResolver } from \"@yume-chan/async\";\n\nimport type {\n    AdbIncomingSocketHandler,\n    AdbSocket,\n    AdbTransport,\n} from \"../adb.js\";\nimport type { AdbBanner } from \"../banner.js\";\nimport { AdbFeature } from \"../features.js\";\n\nimport type { AdbServerClient } from \"./client.js\";\n\nexport const ADB_SERVER_DEFAULT_FEATURES = /* #__PURE__ */ (() =>\n    [\n        AdbFeature.ShellV2,\n        AdbFeature.Cmd,\n        AdbFeature.StatV2,\n        AdbFeature.ListV2,\n        AdbFeature.FixedPushMkdir,\n        \"apex\",\n        AdbFeature.Abb,\n        // only tells the client the symlink timestamp issue in `adb push --sync` has been fixed.\n        // No special handling required.\n        \"fixed_push_symlink_timestamp\",\n        AdbFeature.AbbExec,\n        \"remount_shell\",\n        \"track_app\",\n        AdbFeature.SendReceiveV2,\n        \"sendrecv_v2_brotli\",\n        \"sendrecv_v2_lz4\",\n        \"sendrecv_v2_zstd\",\n        \"sendrecv_v2_dry_run_send\",\n    ] as readonly AdbFeature[])();\n\nexport class AdbServerTransport implements AdbTransport {\n    #client: AdbServerClient;\n\n    readonly serial: string;\n\n    readonly transportId: bigint;\n\n    readonly maxPayloadSize: number = 1 * 1024 * 1024;\n\n    readonly banner: AdbBanner;\n\n    #sockets: AdbSocket[] = [];\n\n    #closed = new PromiseResolver<void>();\n    #disconnected: Promise<void>;\n    get disconnected() {\n        return this.#disconnected;\n    }\n\n    get clientFeatures() {\n        // No need to get host features (features supported by ADB server)\n        // Because we create all ADB packets ourselves\n        return ADB_SERVER_DEFAULT_FEATURES;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/max-params\n    constructor(\n        client: AdbServerClient,\n        serial: string,\n        banner: AdbBanner,\n        transportId: bigint,\n        disconnected: Promise<void>,\n    ) {\n        this.#client = client;\n        this.serial = serial;\n        this.banner = banner;\n        this.transportId = transportId;\n\n        this.#disconnected = Promise.race([this.#closed.promise, disconnected]);\n    }\n\n    async connect(service: string): Promise<AdbSocket> {\n        const socket = await this.#client.createDeviceConnection(\n            { transportId: this.transportId },\n            service,\n        );\n        this.#sockets.push(socket);\n        return socket;\n    }\n\n    async addReverseTunnel(\n        handler: AdbIncomingSocketHandler,\n        address?: string,\n    ): Promise<string> {\n        return await this.#client.connector.addReverseTunnel(handler, address);\n    }\n\n    async removeReverseTunnel(address: string): Promise<void> {\n        await this.#client.connector.removeReverseTunnel(address);\n    }\n\n    async clearReverseTunnels(): Promise<void> {\n        await this.#client.connector.clearReverseTunnels();\n    }\n\n    async close(): Promise<void> {\n        for (const socket of this.#sockets) {\n            await socket.close();\n        }\n        this.#sockets.length = 0;\n        this.#closed.resolve();\n    }\n}\n", "// cspell:ignore tport\n\nimport type { MaybePromiseLike } from \"@yume-chan/async\";\nimport { PromiseResolver } from \"@yume-chan/async\";\nimport type { Event } from \"@yume-chan/event\";\nimport { getUint64LittleEndian } from \"@yume-chan/no-data-view\";\nimport type {\n    AbortSignal,\n    MaybeConsumable,\n    ReadableWritablePair,\n} from \"@yume-chan/stream-extra\";\nimport { AbortController } from \"@yume-chan/stream-extra\";\n\nimport type { AdbIncomingSocketHandler, AdbSocket, Closeable } from \"../adb.js\";\nimport { Adb } from \"../adb.js\";\nimport { AdbBanner } from \"../banner.js\";\nimport type { DeviceObserver as DeviceObserverBase } from \"../device-observer.js\";\nimport type { AdbFeature } from \"../features.js\";\nimport { hexToNumber } from \"../utils/index.js\";\n\nimport {\n    MDnsCommands,\n    WirelessCommands,\n    AlreadyConnectedError as _AlreadyConnectedError,\n    NetworkError as _NetworkError,\n    UnauthorizedError as _UnauthorizedError,\n} from \"./commands/index.js\";\nimport { AdbServerDeviceObserverOwner } from \"./observer.js\";\nimport { AdbServerStream } from \"./stream.js\";\nimport { AdbServerTransport } from \"./transport.js\";\n\n/**\n * Client for the ADB Server.\n */\nexport class AdbServerClient {\n    static NetworkError = _NetworkError;\n    static UnauthorizedError = _UnauthorizedError;\n    static AlreadyConnectedError = _AlreadyConnectedError;\n\n    static parseDeviceList(\n        value: string,\n        includeStates: readonly AdbServerClient.ConnectionState[] = [\n            \"device\",\n            \"unauthorized\",\n        ],\n    ): AdbServerClient.Device[] {\n        const devices: AdbServerClient.Device[] = [];\n        for (const line of value.split(\"\\n\")) {\n            if (!line) {\n                continue;\n            }\n\n            const parts = line.split(\" \").filter(Boolean);\n            const serial = parts[0]!;\n            const state = parts[1]! as AdbServerClient.ConnectionState;\n            if (!includeStates.includes(state)) {\n                continue;\n            }\n\n            let product: string | undefined;\n            let model: string | undefined;\n            let device: string | undefined;\n            let transportId: bigint | undefined;\n            for (let i = 2; i < parts.length; i += 1) {\n                const [key, value] = parts[i]!.split(\":\");\n                switch (key) {\n                    case \"product\":\n                        product = value;\n                        break;\n                    case \"model\":\n                        model = value;\n                        break;\n                    case \"device\":\n                        device = value;\n                        break;\n                    case \"transport_id\":\n                        transportId = BigInt(value!);\n                        break;\n                }\n            }\n            if (!transportId) {\n                throw new Error(`No transport id for device ${serial}`);\n            }\n            devices.push({\n                serial,\n                state,\n                authenticating: state === \"unauthorized\",\n                product,\n                model,\n                device,\n                transportId,\n            });\n        }\n        return devices;\n    }\n\n    static formatDeviceService(\n        device: AdbServerClient.DeviceSelector,\n        command: string,\n    ) {\n        if (!device) {\n            return `host:${command}`;\n        }\n        if (\"transportId\" in device) {\n            return `host-transport-id:${device.transportId}:${command}`;\n        }\n        if (\"serial\" in device) {\n            return `host-serial:${device.serial}:${command}`;\n        }\n        if (\"usb\" in device) {\n            return `host-usb:${command}`;\n        }\n        if (\"tcp\" in device) {\n            return `host-local:${command}`;\n        }\n        throw new TypeError(\"Invalid device selector\");\n    }\n\n    readonly connector: AdbServerClient.ServerConnector;\n\n    readonly wireless = new WirelessCommands(this);\n    readonly mDns = new MDnsCommands(this);\n    readonly #observerOwner = new AdbServerDeviceObserverOwner(this);\n\n    constructor(connector: AdbServerClient.ServerConnector) {\n        this.connector = connector;\n    }\n\n    async createConnection(\n        request: string,\n        options?: AdbServerClient.ServerConnectionOptions,\n    ): Promise<AdbServerStream> {\n        const connection = await this.connector.connect(options);\n        const stream = new AdbServerStream(connection);\n\n        try {\n            await stream.writeString(request);\n        } catch (e) {\n            await stream.dispose();\n            throw e;\n        }\n\n        try {\n            // `raceSignal` throws when the signal is aborted,\n            // so the `catch` block can close the connection.\n            await raceSignal(() => stream.readOkay(), options?.signal);\n            return stream;\n        } catch (e) {\n            await stream.dispose();\n            throw e;\n        }\n    }\n\n    /**\n     * `adb version`\n     */\n    async getVersion(): Promise<number> {\n        const connection = await this.createConnection(\"host:version\");\n        try {\n            const length = hexToNumber(await connection.readExactly(4));\n            const version = hexToNumber(await connection.readExactly(length));\n            return version;\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    async validateVersion(minimalVersion: number) {\n        const version = await this.getVersion();\n        if (version < minimalVersion) {\n            throw new Error(\n                `adb server version (${version}) doesn't match this client (${minimalVersion})`,\n            );\n        }\n    }\n\n    /**\n     * `adb kill-server`\n     */\n    async killServer(): Promise<void> {\n        const connection = await this.createConnection(\"host:kill\");\n        await connection.dispose();\n    }\n\n    /**\n     * `adb host-features`\n     */\n    async getServerFeatures(): Promise<AdbFeature[]> {\n        const connection = await this.createConnection(\"host:host-features\");\n        try {\n            const response = await connection.readString();\n            return response.split(\",\") as AdbFeature[];\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    /**\n     * Get a list of connected devices from ADB Server.\n     *\n     * Equivalent ADB Command: `adb devices -l`\n     */\n    async getDevices(\n        includeStates: readonly AdbServerClient.ConnectionState[] = [\n            \"device\",\n            \"unauthorized\",\n        ],\n    ): Promise<AdbServerClient.Device[]> {\n        const connection = await this.createConnection(\"host:devices-l\");\n        try {\n            const response = await connection.readString();\n            return AdbServerClient.parseDeviceList(response, includeStates);\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    /**\n     * Monitors device list changes.\n     */\n    async trackDevices(\n        options?: AdbServerDeviceObserverOwner.Options,\n    ): Promise<AdbServerClient.DeviceObserver> {\n        return this.#observerOwner.createObserver(options);\n    }\n\n    /**\n     * `adb -s <device> reconnect` or `adb reconnect offline`\n     */\n    async reconnectDevice(device: AdbServerClient.DeviceSelector | \"offline\") {\n        const connection = await this.createConnection(\n            device === \"offline\"\n                ? \"host:reconnect-offline\"\n                : AdbServerClient.formatDeviceService(device, \"reconnect\"),\n        );\n        try {\n            await connection.readString();\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    /**\n     * Gets the features supported by the device.\n     * The transport ID of the selected device is also returned,\n     * so the caller can execute other commands against the same device.\n     * @param device The device selector\n     * @returns The transport ID of the selected device, and the features supported by the device.\n     */\n    async getDeviceFeatures(\n        device: AdbServerClient.DeviceSelector,\n    ): Promise<{ transportId: bigint; features: readonly AdbFeature[] }> {\n        // On paper, `host:features` is a host service (device features are cached in host),\n        // so it shouldn't use `createDeviceConnection`,\n        // which is used to forward the service to the device.\n        //\n        // However, `createDeviceConnection` is a two step process:\n        //\n        //    1. Send a switch device service to host, to switch the connection to the device.\n        //    2. Send the actual service to host, let it forward the service to the device.\n        //\n        // In step 2, the host only forward the service to device if the service is unknown to host.\n        // If the service is a host service, it's still handled by host.\n        //\n        // Even better, if the service needs a device selector, but the selector is not provided,\n        // the service will be executed against the device selected by the switch device service.\n        // So we can use all device selector formats for the host service,\n        // and get the transport ID in the same time.\n        const connection = await this.createDeviceConnection(\n            device,\n            \"host:features\",\n        );\n        // Luckily `AdbServerClient.Socket` is compatible with `AdbServerClient.ServerConnection`\n        const stream = new AdbServerStream(connection);\n        try {\n            const featuresString = await stream.readString();\n            const features = featuresString.split(\",\") as AdbFeature[];\n            return { transportId: connection.transportId, features };\n        } finally {\n            await stream.dispose();\n        }\n    }\n\n    /**\n     * Creates a connection that will forward the service to device.\n     * @param device The device selector\n     * @param service The service to forward\n     * @returns An `AdbServerClient.Socket` that can be used to communicate with the service\n     */\n    async createDeviceConnection(\n        device: AdbServerClient.DeviceSelector,\n        service: string,\n    ): Promise<AdbServerClient.Socket> {\n        let switchService: string;\n        let transportId: bigint | undefined;\n        if (!device) {\n            await this.validateVersion(41);\n            switchService = `host:tport:any`;\n        } else if (\"transportId\" in device) {\n            switchService = `host:transport-id:${device.transportId}`;\n            transportId = device.transportId;\n        } else if (\"serial\" in device) {\n            await this.validateVersion(41);\n            switchService = `host:tport:serial:${device.serial}`;\n        } else if (\"usb\" in device) {\n            await this.validateVersion(41);\n            switchService = `host:tport:usb`;\n        } else if (\"tcp\" in device) {\n            await this.validateVersion(41);\n            switchService = `host:tport:local`;\n        } else {\n            throw new TypeError(\"Invalid device selector\");\n        }\n\n        const connection = await this.createConnection(switchService);\n\n        try {\n            await connection.writeString(service);\n        } catch (e) {\n            await connection.dispose();\n            throw e;\n        }\n\n        try {\n            if (transportId === undefined) {\n                const array = await connection.readExactly(8);\n                transportId = getUint64LittleEndian(array, 0);\n            }\n\n            await connection.readOkay();\n\n            const socket = connection.release();\n\n            return {\n                transportId,\n                service,\n                readable: socket.readable,\n                writable: socket.writable,\n                get closed() {\n                    return socket.closed;\n                },\n                async close() {\n                    await socket.close();\n                },\n            };\n        } catch (e) {\n            await connection.dispose();\n            throw e;\n        }\n    }\n    async #waitForUnchecked(\n        device: AdbServerClient.DeviceSelector,\n        state: \"device\" | \"disconnect\",\n        options?: AdbServerClient.ServerConnectionOptions,\n    ): Promise<void> {\n        let type: string;\n        if (!device) {\n            type = \"any\";\n        } else if (\"transportId\" in device) {\n            type = \"any\";\n        } else if (\"serial\" in device) {\n            type = \"any\";\n        } else if (\"usb\" in device) {\n            type = \"usb\";\n        } else if (\"tcp\" in device) {\n            type = \"local\";\n        } else {\n            throw new TypeError(\"Invalid device selector\");\n        }\n\n        // `waitFor` can't use `connectDevice`, because the device\n        // might not be available yet.\n        const service = AdbServerClient.formatDeviceService(\n            device,\n            `wait-for-${type}-${state}`,\n        );\n\n        const connection = await this.createConnection(service, options);\n        try {\n            await connection.readOkay();\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    /**\n     * Wait for a device to be connected or disconnected.\n     *\n     * `adb wait-for-<state>`\n     *\n     * @param device The device selector\n     * @param state The state to wait for\n     * @param options The options\n     * @returns A promise that resolves when the condition is met.\n     */\n    async waitFor(\n        device: AdbServerClient.DeviceSelector,\n        state: \"device\" | \"disconnect\",\n        options?: AdbServerClient.ServerConnectionOptions,\n    ): Promise<void> {\n        if (state === \"disconnect\") {\n            await this.validateVersion(41);\n        }\n\n        return this.#waitForUnchecked(device, state, options);\n    }\n\n    async waitForDisconnect(\n        transportId: bigint,\n        options?: AdbServerClient.ServerConnectionOptions,\n    ): Promise<void> {\n        const serverVersion = await this.getVersion();\n        if (serverVersion >= 41) {\n            return this.#waitForUnchecked(\n                { transportId },\n                \"disconnect\",\n                options,\n            );\n        } else {\n            const observer = await this.trackDevices(options);\n            return new Promise<void>((resolve, reject) => {\n                observer.onDeviceRemove((devices) => {\n                    if (\n                        devices.some(\n                            (device) => device.transportId === transportId,\n                        )\n                    ) {\n                        observer.stop();\n                        resolve();\n                    }\n                });\n                observer.onError((e) => {\n                    observer.stop();\n                    reject(e);\n                });\n            });\n        }\n    }\n\n    /**\n     * Creates an ADB Transport for the specified device.\n     */\n    async createTransport(\n        device: AdbServerClient.DeviceSelector,\n    ): Promise<AdbServerTransport> {\n        const { transportId, features } = await this.getDeviceFeatures(device);\n\n        const devices = await this.getDevices();\n        const info = devices.find(\n            (device) => device.transportId === transportId,\n        );\n\n        const banner = new AdbBanner(\n            info?.product,\n            info?.model,\n            info?.device,\n            features,\n        );\n\n        const waitAbortController = new AbortController();\n        const disconnected = this.waitForDisconnect(transportId, {\n            unref: true,\n            signal: waitAbortController.signal,\n        });\n\n        const transport = new AdbServerTransport(\n            this,\n            info?.serial ?? \"\",\n            banner,\n            transportId,\n            disconnected,\n        );\n\n        void transport.disconnected.finally(() => waitAbortController.abort());\n\n        return transport;\n    }\n\n    async createAdb(device: AdbServerClient.DeviceSelector) {\n        const transport = await this.createTransport(device);\n        return new Adb(transport);\n    }\n}\n\nexport async function raceSignal<T>(\n    callback: () => PromiseLike<T>,\n    ...signals: (AbortSignal | undefined)[]\n): Promise<T> {\n    const abortPromise = new PromiseResolver<never>();\n    function abort(this: AbortSignal) {\n        abortPromise.reject(this.reason);\n    }\n\n    try {\n        for (const signal of signals) {\n            if (!signal) {\n                continue;\n            }\n            if (signal.aborted) {\n                throw signal.reason;\n            }\n            signal.addEventListener(\"abort\", abort);\n        }\n\n        return await Promise.race([callback(), abortPromise.promise]);\n    } finally {\n        for (const signal of signals) {\n            if (!signal) {\n                continue;\n            }\n            signal.removeEventListener(\"abort\", abort);\n        }\n    }\n}\n\nexport namespace AdbServerClient {\n    export interface ServerConnectionOptions {\n        unref?: boolean | undefined;\n        signal?: AbortSignal | undefined;\n    }\n\n    export interface ServerConnection\n        extends ReadableWritablePair<Uint8Array, MaybeConsumable<Uint8Array>>,\n            Closeable {\n        get closed(): Promise<undefined>;\n    }\n\n    export interface ServerConnector {\n        connect(\n            options?: ServerConnectionOptions,\n        ): MaybePromiseLike<ServerConnection>;\n\n        addReverseTunnel(\n            handler: AdbIncomingSocketHandler,\n            address?: string,\n        ): MaybePromiseLike<string>;\n\n        removeReverseTunnel(address: string): MaybePromiseLike<void>;\n\n        clearReverseTunnels(): MaybePromiseLike<void>;\n    }\n\n    export interface Socket extends AdbSocket {\n        transportId: bigint;\n    }\n\n    /**\n     * A union type for selecting a device.\n     */\n    export type DeviceSelector =\n        | { transportId: bigint }\n        | { serial: string }\n        | { usb: true }\n        | { tcp: true }\n        | undefined;\n\n    export type ConnectionState = \"unauthorized\" | \"offline\" | \"device\";\n\n    export interface Device {\n        serial: string;\n        state: ConnectionState;\n        /** @deprecated Use {@link state} instead */\n        authenticating: boolean;\n        product?: string | undefined;\n        model?: string | undefined;\n        device?: string | undefined;\n        transportId: bigint;\n    }\n\n    export interface DeviceObserver extends DeviceObserverBase<Device> {\n        onError: Event<Error>;\n    }\n\n    export type NetworkError = _NetworkError;\n    export type UnauthorizedError = _UnauthorizedError;\n    export type AlreadyConnectedError = _AlreadyConnectedError;\n}\n"],
  "mappings": "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",
  "names": ["value", "result", "buffer", "field", "deserialize", "init", "buffer", "field", "context", "index", "size", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "field", "ReadableStream", "_writable", "_readable", "_resolver", "_readableController", "chunk", "chunk", "_resolver", "chunk", "chunk", "chunk", "buffer", "struct", "charToIndex", "indexToChar", "paddingChar", "buffer", "buffer", "_socket", "_adb", "_socket", "_writer", "_exited", "_socket", "_writer", "_input", "_stdout", "_exited", "_spawn", "_adb", "_adb", "buffer", "_writer", "_readable", "buffer", "_socket", "chunk", "_readable", "_readableController", "_socket", "_writer", "_closed", "_dispatcher", "calculateChecksum", "OKAY", "_connection", "_buffered", "_writer", "buffer", "_client", "_client", "_client", "_sockets", "_closed", "_disconnected", "value", "device"]
}
